%注意一些命令比如\cmd，\file，<| |>，而$符号直接用\$表示即可。

%\section{Author Guide}
\section{样式作者指南}
\label{aut}

%This part of the manual documents the author interface of the \biblatex package. The author guide covers everything you need to know in order to write new citation and bibliography styles or localisation modules. You should read the user guide first before continuing with this part of the manual.

本节是样式作者指南，主要介绍\biblatex 包的接口。该指南囊括了设计参考文献著录和标注样式或者本地化模型所需了解的所有知识。在阅读本节内容前最好先阅读上一节的用户手册。

\subsection{概述}%Overview
\label{aut:int}
在讨论\biblatex 提供的命令和工具之前，我们首先介绍一些基本概念。\biblatex 包以一种特殊方式使用辅助文件。最值得注意的是当使用\bibtex 后端程序时，\file{bbl} 文件的使用方式存在差别，即只有一个\file{bst} 文件可用来实现结构化的数据接口，该文件并非用来输出可打印数据。

使用\latex 的标准参考文献工具，一个文档通常包含任意数量的文献引用命令，以及常放在文档末尾的\cmd{bibliographystyle} 和\cmd{bibliography} 命令。文献引用命令在文档中的位置是任意的，而\cmd{bibliographystyle} 和\cmd{bibliography} 命令则标记了打印参考文献表的位置，比如:
Before we get to the commands and facilities provided by \biblatex, we will have a look at some of its fundamental concepts. The \biblatex package uses auxiliary files in a special way. Most notably, the \file{bbl} file is used differently and there is no concept of a style-dependent \file{bst} file. With \latex's standard bibliographic facilities, a document includes any number of citation commands in the document body plus \cmd{bibliographystyle} and \cmd{bibliography}, usually towards the end of the document. The location of the former is arbitrary, the latter marks the spot where the list of references is to be printed:


\begin{ltxexample}
\documentclass{...}
\begin{document}
\cite{...}
...
\bibliographystyle{...}
\bibliography{...}
\end{document}
\end{ltxexample}
%

%Processing this files requires that a certain procedure be followed. This procedure is as follows:
处理这些文件遵循一定的流程，其过程如下:

\begin{enumerate}

\item 运行\bin{latex}: 第一次运行\bin{latex}， 在\file{aux} 文件中写入\cmd{bibstyle} 和 \cmd{bibdata} 命令，以及所有标注的\cmd{citation} 命令。这时，各引文标注\footnote{译者:这里的references译为引文标注，指引用命令在正文中产生的标注，这个标注由标签label构成。} 是未定义的，因为 \latex 等待\bibtex 提供需要的数据，当然参考文献表也未生成。
    %Run \bin{latex}: On the first run, \cmd{bibstyle} and \cmd{bibdata} commands are written to the \file{aux} file, along with \cmd{citation} commands for all citations. At this point, the references are undefined because \latex is waiting for \bibtex to supply the required data. There is also no bibliography yet.


\item 运行\bin{bibtex}: \bibtex 在\file{bbl} 文件中写入一个\env{thebibliography} 环境，用以为\file{aux} 文件中\cmd{citation} 命令提供所需的所有\gls{条目}，这些条目的数据来自\file{bib} 文件。
    %Run \bin{bibtex}: \bibtex writes a \env{thebibliography} environment to the \file{bbl} file, supplying all entries from the \file{bib} file which were requested by the \cmd{citation} commands in the \file{aux} file.


\item 运行\bin{latex}: 第二次运行\bin{latex}，\env{thebibliography} 环境中的\cmd{bibitem} 命令为各参考文献条目在\file{aux} 文件中写入\cmd{bibcite} 命令。这些\cmd{bibcite} 命令定义的标签将用于\cmd{cite} 命令。然而，各引文标注仍然未定义，因为这些标签在最后一次运行\bin{latex} 前仍是未知的。
    %Run \bin{latex}: Starting with the second run, the \cmd{bibitem} commands in the \env{thebibliography} environment write one \cmd{bibcite} command for each bibliography entry to the \file{aux} file. These \cmd{bibcite} commands define the citation labels used by \cmd{cite}. However, the references are still undefined because the labels are not available until the end of this run.


\item 运行\bin{latex}: 第三次运行，随着导言区最后读入了\file{aux} 文件，引文标注的标签定义完成。至此所有的标注可以正确打印。
    %Run \bin{latex}: Starting with the third run, the citation labels are defined as the \file{aux} file is read in at the end of the preamble. All citations can now be printed.

\end{enumerate}

注意到所有的参考文献数据都以最终格式(指最后打印出的格式)写入\file{bbl} 文件。该文件的读取和处理如同任何文档中的可打印章节。例如，考虑在一个\file{bib} 文件中有如下条目:
%Note that all bibliographic data is written to the \file{bbl} file in the final format. The \file{bbl} file is read in and processed like any printable section of the document. For example, consider the following entry in a \file{bib} file:

\begin{lstlisting}[style=bibtex]{}
@Book{companion,
  author    = {Michel Goossens and Frank Mittelbach and Alexander Samarin},
  title     = {The LaTeX Companion},
  publisher = {Addison-Wesley},
  address   = {Reading, Mass.},
  year      = {1994},
}
\end{lstlisting}
%
根据\path{plain.bst} 样式，\bibtex 在\file{bbl} 文件中输出该条目如下:
%With the \path{plain.bst} style, \bibtex exports this entry to the \file{bbl} file as follows:

\begin{ltxexample}
\bibitem{companion}
Michel Goossens, Frank Mittelbach, and Alexander Samarin.
\newblock {\em The LaTeX Companion}.
\newblock Addison-Wesley, Reading, Mass., 1994.
\end{ltxexample}
%
默认情况下，\latex 生成顺序编码制标注标签，因此\cmd{bibitem} 命令在\file{aux} 文件中写入的行如下所示:
%By default, \latex generates numeric citation labels, hence \cmd{bibitem} writes lines such as the following to the \file{aux} file:

\begin{ltxexample}
\bibcite{companion}{1}
\end{ltxexample}
%
要实现一个不同的标注标签样式，意味着需要通过\file{aux} 文件传递更多的数据。比如，当使用\sty{natbib} 包时，\file{aux} 文件包含的标注(或引用)信息行，如下所示:
%Implementing a different citation style implies that more data has to be transferred via the \file{aux} file. With the \sty{natbib} package, for example, the \file{aux} file contains lines like this one:

\begin{ltxexample}
\bibcite{companion}{{1}{1994}{{Goossens et~al.}}{{Goossens, Mittelbach,
and Samarin}}}
\end{ltxexample}
%

\biblatex 包支持任何格式的标注标签，因此标注命令需要访问完整的参考文献数据。观察同样需要在标注中提供完整参考文献数据的\sty{jurabib} 包的输出，我们会更理解这一需求对上述处理过程意味着什么。
%The \biblatex package supports citations in any arbitrary format, hence citation commands need access to all bibliographic data. What this would mean within the scope of the procedure outlined above becomes obvious when looking at the output of the \sty{jurabib} package which also makes all bibliographic data available in citations:

\begin{ltxexample}
\bibcite{companion}{{Goossens\jbbfsasep Mittelbach\jbbstasep Samarin}%
  {}{{0}{}{book}{1994}{}{}{}{}{Reading, Mass.\bpubaddr{}Addison-Wesley%
  \bibbdsep{} 1994}}{{The LaTeX Companion}{}{}{2}{}{}{}{}{}}{\bibnf
  {Goossens}{Michel}{M.}{}{}\Bibbfsasep\bibnf{Mittelbach}{Frank}{F.}%
  {}{}\Bibbstasep\bibnf{Samarin}{Alexander}{A.}{}{}}{\bibtfont{The
  LaTeX Companion}.\ \apyformat{Reading, Mass.\bpubaddr{}
  Addison-Wesley\bibbdsep{} 1994}}}
\end{ltxexample}
%

在这种情况下，整个\env{thebibliography} 环境的内容是通过\file{aux} 文件进行有效传递的。数据首先从\file{bbl} 文件中读取出来，写入到\file{aux} 中，然后再从\file{aux} 读出保存到内存中。参考文献表本身的生成也需要先读入\file{bbl} 文件。这也使得\biblatex 包被迫通过\file{aux} 文件回收所有数据。这意味着上述过程处理过度且多余，因为不管怎样数据都需要保存到内存中。
%In this case, the contents of the entire \env{thebibliography} environment are effectively transferred via the \file{aux} file. The data is read from the \file{bbl} file, written to the \file{aux} file, read back from the \file{aux} file and then kept in memory. The bibliography itself is still generated as the \file{bbl} file is read in. The \biblatex package would also be forced to cycle all data through the \file{aux} file. This implies processing overhead and is also redundant because the data has to be kept in memory anyway.

这种传统的处理过程都基于一个假设，即条目的完整数据只是参考文献表需要而所有的标注都使用短标签。这对于有内存限制的情况是非常高效的，但也意味着它很难扩展。这就是\biblatex 采取另一种方式的原因。采用新的方式，首先文档结构略有变化。取消在文档内使用\cmd{bibliography} 命令，数据库文件由导言区的\cmd{addbibresource} 命令指定，完全忽略\cmd{bibliographystyle} 命令(所有的功能都将由包选项控制)，参考文献表则使用\cmd{printbibliography} 命令打印:
%The traditional procedure is based on the assumption that the full bibliographic data of an entry is only required in the bibliography and that all citations use short labels. This makes it very effective in terms of memory requirements, but it also implies that it does not scale well. That is why \biblatex takes a different approach. First of all, the document structure is slightly different. Instead of using \cmd{bibliography} in the document body, database files are specified in the preamble with \cmd{addbibresource}, \cmd{bibliographystyle} is omitted entirely (all features are controlled by package options), and the bibliography is printed using \cmd{printbibliography}:

\begin{ltxexample}
\documentclass{...}
\usepackage[...]{biblatex}
\addbibresource{...}
\begin{document}
\cite{...}
...
\printbibliography
\end{document}
\end{ltxexample}
%

为简化整个过程，\biblatex 基本上以应用\file{aux} 文件的方式应用\file{bbl} 文件，并舍弃了\cmd{bibcite} 命令。于是，我们得到如下流程:
%In order to streamline the whole procedure, \biblatex essentially employs the \file{bbl} file like an \file{aux} file, rendering \cmd{bibcite} obsolete. We then get the following procedure:

\begin{enumerate}

\item 运行\bin{latex}:第一步类似于上述的传统方式:将\cmd{bibstyle} 和 \cmd{bibdata} 以及所有引用的\cmd{citation} 命令写入到\file{aux} 文件中(以\bibtex 为后端程序)或者写到\file{bcf} 文件中(以\biber 为后端程序)。然后等待后端程序提供需要的数据。当以\bibtex 为后端程序时，\biblatex 使用一个特殊的\file{bst} 文件，该文件用于实现\bibtex 后端程序的数据接口，因此\cmd{bibstyle} 命令必须是|\bibstyle{biblatex}|。

Run \bin{latex}: The first step is similar to the traditional procedure described above: \cmd{bibstyle} and \cmd{bibdata} commands are written to th \file{bcf} file, along with \cmd{citation} commands for all citations. We then wait for the backend to supply the required data.


\item 运行\bin{biber} 或 \bin{bibtex}:后端程序为辅助文件中所有\cmd{citation} 命令提供所需的条目，这些条目的数据来自\file{bib} 文件。然而，它并不在\file{bbl} 文件中写出一个可打印的参考文献表，而是一个结构化表达的参考文献数据。类似于\file{aux} 文件，读入该\file{bbl} 文件时不打印任何东西，仅是将数据存入内存中。
    %Run \bin{biber} or \bin{bibtex}: The backend supplies those entries from the \file{bib} file which were requested by the \cmd{citation} commands in the auxiliary file. However, it does not write a printable bibliography to the \file{bbl} file, but rather a structured representation of the bibliographic data. Just like an \file{aux} file, this \file{bbl} file does not print anything when read in. It merely puts data in memory.


\item 运行\bin{latex}: 第二次运行，\file{bbl} 文件在文档正文开始的时候处理，类似于\file{aux} 文件。从这开始，所有参考文献数据都已在内存中，所以所有的引用标注都可以正确打印。\footnote{如果\opt{defernumbers} 包选项启用， \biblatex 以类似于传统过程的一种算法来生成顺序制标签。这种情况下，这些数字将在参考文献表打印时指定，且需从后端辅助文件中回收。因此需要额外再运行一次\latex 以在标注中应用。 } 引用命令不仅可以访问预定义的标签，还可以访问完整的参考文献数据。参考文献表由内存中的相同数据生成，可以根据需要进行筛选和划分。
    %Run \bin{latex}: Starting with the second run, the \file{bbl} file is processed right at the beginning of the document body, just like an \file{aux} file. From this point on, all bibliographic data is available in memory so that all citations can be printed right away.\footnote{If the \opt{defernumbers} package option is enabled \biblatex uses an algorithm similar to the traditional procedure to generate numeric labels. In this case, the numbers are assigned as the bibliography is printed and then cycled through the backend auxiliary file. It will take an additional \latex run for them to be picked up in citations.} The citation commands have access to the complete bibliographic data, not only to a predefined label. The bibliography is generated from memory using the same data and may be filtered or split as required.
\end{enumerate}

我们再次观察上面给出的条目示例:
%Let's consider the sample entry given above once more:

\begin{lstlisting}[style=bibtex]{}
@Book{companion,
  author    = {Michel Goossens and Frank Mittelbach and Alexander Samarin},
  title     = {The LaTeX Companion},
  publisher = {Addison-Wesley},
  address   = {Reading, Mass.},
  year      = {1994},
}
\end{lstlisting}
%
使用\biblatex 及\biber 后端程序，这一条目实际上以如下格式输出:
%With \biblatex and the \biber backend, this entry is essentially exported in the following format:

\begin{ltxexample}
\entry{companion}{book}{}
  \labelname{author}{3}{}{%
    {{uniquename=0,hash=...}{Goossens}{G.}{Michel}{M.}{}{}{}{}}%
    {{uniquename=0,hash=...}{Mittelbach}{M.}{Frank}{F.}{}{}{}{}}%
    {{uniquename=0,hash=...}{Samarin}{S.}{Alexander}{A.}{}{}{}{}}%
  }
  \name{author}{3}{}{%
    {{uniquename=0,hash=...}{Goossens}{G.}{Michel}{M.}{}{}{}{}}%
    {{uniquename=0,hash=...}{Mittelbach}{M.}{Frank}{F.}{}{}{}{}}%
    {{uniquename=0,hash=...}{Samarin}{S.}{Alexander}{A.}{}{}{}{}}%
  }
  \list{publisher}{1}{%
    {Addison-Wesley}%
  }
  \list{location}{1}{%
    {Reading, Mass.}%
  }
  \field{title}{The LaTeX Companion}
  \field{year}{1994}
\endentry
\end{ltxexample}
%

由该示例可见，某种程度上，结构化的数据构成了\file{bbl} 文件内容\footnote{译者:这里应该是bbl文件而不是原文的bib文件}。此时关于参考文献条目最终格式的任何决定都未作出。而参考文献表和引用标注的格式化最终由 \latex 宏控制，这些宏则定义在参考文献著录和标注样式文件中。
%As seen in this example, the data is presented in a structured format that resembles the structure of a \file{bib} file to some extent. At this point, no decision concerning the final format of the bibliography entry has been made. The formatting of the bibliography and all citations is controlled by \latex macros, which are defined in bibliography and citation style files.

\subsection{参考文献著录样式}%Bibliography Styles
\label{aut:bbx}

\gls{参考文献著录样式} 是用于控制打印参考文献表条目的宏的集合，定义在扩展名为\file{bbx} 的文件中。\biblatex 包在其末尾加载所选择的参考文献著录样式文件。需要注意: 多个标准样式共享的一些常用宏定义在\path{biblatex.def} 文件中。该文件同样在宏包末尾加载，但先于所选的著录样式文件。
%A bibliography style is a set of macros which print the entries in the bibliography. Such styles are defined in files with the suffix \file{bbx}. The \biblatex package loads the selected bibliography style file at the end of the package. Note that a small repertory of frequently used macros shared by several of the standard bibliography styles is included in \path{biblatex.def}. This file is loaded at the end of the package as well, prior to the selected bibliography style.

\subsubsection{参考文献著录样式文件}% Bibliography Style Files
\label{aut:bbx:bbx}

在我们讨论参考文献著录样式的各部分内容之前，先观察一个典型\file{bbx} 文件的总体结构:
%Before we go over the individual components of a bibliography style, consider this example of the overall structure of a typical \file{bbx} file:

\begin{ltxexample}
\ProvidesFile{example.bbx}[2006/03/15 v1.0 biblatex bibliography style]

\defbibenvironment{bibliography}
  {...}
  {...}
  {...}
\defbibenvironment{shorthand}
  {...}
  {...}
  {...}
\InitializeBibliographyStyle{...}
\DeclareBibliographyDriver{article}{...}
\DeclareBibliographyDriver{book}{...}
\DeclareBibliographyDriver{inbook}{...}
...
\DeclareBibliographyDriver{shorthand}{...}
\endinput
\end{ltxexample}
%
参考文献著录样式文件的主要结构包含如下命令:
%The main structure of a bibliography style file consists of the following commands:

\begin{ltxsyntax}

\cmditem{RequireBibliographyStyle}{style}

该命令是可选的，用于引入一些建立在更一般的参考文献样式上的特殊样式。该命令加载了样式文件\path{style.bbx}。
%This command is optional and intended for specialized bibliography styles built on top of a more generic style. It loads the bibliography style \path{style.bbx}.

\cmditem{InitializeBibliographyStyle}{code}

该命令在参考文献表开始之前插入任意给定的\prm{code}，但在参考文献表所形成的组内。该命令是可选的。它可以用于共享不同参考文献驱动需要的一些相同定义，但不能用于参考文献组外。记住，文档中可以有多个参考文献表，如果在某个文献表中对参考文献驱动进行了一些全局设置，最好在下一个参考文献表开始前进行重设。
%Specifies arbitrary \prm{code} to be inserted at the beginning of the bibliography, but inside the group formed by the bibliography. This command is optional. It may be useful for definitions which are shared by several bibliography drivers but not used outside the bibliography. Keep in mind that there may be several bibliographies in a document. If the bibliography drivers make any global assignments, they should be reset at the beginning of the next bibliography.

\cmditem{DeclareBibliographyDriver}{entrytype}{code}

定义一个参考文献驱动。一个驱动 <driver> 是一个宏，用于控制某一具体的参考文献条目(当打印参考文献表时)或者某一具体命名了的参考文献表(当打印多个参考文献表时)。\prm{entrytype} 与\file{bib} 文件中使用的条目类型对应，以小写字母给出(见\secref{bib:typ})。\prm{entrytype} 变量可以是一个星号。这种情况下，该驱动将作为未定义具体驱动的条目类型的驱动。\prm{code} 是用于打印各自\prm{entrytype} 的参考文献条目的任意代码。该命令是必须的。每个参考文献著录样式都应提供所用到的每类条目的驱动。
%Defines a bibliography driver. A <driver> is a macro which handles a specific entry type (when printing bibliography lists) or a specific named bibliography list (when printing bibliography lists). The \prm{entrytype} corresponds to the entry type used in \file{bib} files, specified in lowercase letters (see \secref{bib:typ}). The \prm{entrytype} argument may also be an asterisk. In this case, the driver serves as a fallback which is used if no specific driver for the entry type has been defined. The \prm{code} is arbitrary code which typesets all bibliography entries of the respective \prm{entrytype}. This command is mandatory. Every bibliography style should provide a driver for each entry type.

\cmditem{DeclareBibliographyAlias}{alias}{entrytype}

如果一个参考文献驱动用于处理多个条目类型，该命令可以用来定义以\prm{entrytype} 命名的驱动的别名。\prm{alias} 选项可以是一个星号，这种情况下，该驱动将作为未定义具体驱动的条目类型的驱动。
%If a bibliography driver covers more than one entry type, this command may be used to define an alias where \prm{entrytype} is the name of a defined driver. This command is optional. The \prm{alias} argument may also be an asterisk. In this case, the \prm{entrytype} driver serves as a fallback which is used if no specific driver for an entry has been defined.

Note that an alias declared with \cmd{DeclareBibliographyAlias} only <reroutes> the bibliography driver from \prm{alias} to \prm{entrytype}. Type-specific formatting directives still operate with the old \prm{alias} name. \cmd{DeclareBibliographyAlias} thus provides only a <soft> alias. If a complete alias is desired so that \prm{alias} and \prm{entrytype} are completely indistinguishable and use the same type-specific formatting, an approach with source mapping would be more appropriate (cf.~the mappings for \secref{bib:typ:als} in \secref{apx:maps:bibtex}, this would give a <hard> alias).
\cmditem{DeclareBibliographyOption}[datatype]{key}[value]{code}

该命令以\keyval 格式定义额外的导言区选项。\prm{key} 是选项键。\prm{code} 是当使用该选项时执行的任意\tex 代码。键值作为|#1|传递给\prm{code}。可选的\prm{value} 是当该选项仅有键名而无键值给出时的默认键值。这对于布尔选项非常有用。\prm{datatype} 是选项的数据类型(datatype)，如果缺省，那么默认为 <boolean>(布尔类型)。一个定义示例如下:

%This command defines additional preamble options in \keyval format. The \prm{key} is the option key. The \prm{code} is arbitrary \tex code to be executed whenever the option is used. The value passed to the option is passed on to the \prm{code} as |#1|. The optional \prm{value} is a default value to be used if the bare key is given without any value. This is useful for boolean switches.
%The \prm{datatype} is a the datatype for the option. If omitted, it defaults to <boolean>. For example, with a definition like the following:

\begin{ltxexample}
\DeclareBibliographyOption[boolean]{somekey}[true]{...}
\end{ltxexample}
%
给出<\texttt{somekey}>而没有键值等价于<\kvopt{somekey}{true}>。有效的\prm{datatype} 在默认的\biber 数据模型中定义，包括:
%giving <\texttt{somekey}> without a value is equivalent to <\kvopt{somekey}{true}>. Valid \prm{datatype} values are defined in the default \biber Datamodel as:

\begin{ltxexample}
\DeclareDatamodelConstant[type=list]{optiondatatypes}{boolean,integer,string,xml}
\end{ltxexample}

\cmditem{DeclareTypeOption}[datatype]{key}[value]{code}

Similar to \cmd{DeclareBibliographyOption} but defines options which are settable on a per"=type basis using the optional argument of \cmd{ExecuteBibliographyOptions} (see \secref{use:cfg:opt}). The \prm{code} is executed whenever \biblatex prepares the data of an entry of the type for which the option has been set for use by a citation command or a bibliography driver.
\cmditem{DeclareEntryOption}[datatype]{key}[value]{code}

类似于\cmd{DeclareBibliographyOption}，但用于定义具体条目类型的\bibfield{options} 域(见\secref{bib:fld:spc} 节)中的可设选项。\prm{code} 在\biblatex 为标注命令和参考文献驱动准备数据时执行。
%Similar to \cmd{DeclareBibliographyOption} but defines options which are settable on a per"=entry basis in the \bibfield{options} field from \secref{bib:fld:spc}. The \prm{code} is executed whenever \biblatex prepares the data of the entry for use by a citation command or a bibliography driver.

\cmditem{DeclareBiblatexOption}{scope,\dots}[datatype]{key}[value]{code}

This command is a convenient interface to declare an option for several scopes at once. The \prm{scope} argument may be a comma"=separated list of scopes for which the option will be declared. Currently the scopes \opt{global}, \opt{type}, \opt{entry}, \opt{namelist} and \opt{name} are supported, the first three of which are equivalent to defining the option with \cmd{DeclareBibliographyOption}, \cmd{DeclareTypeOption} and \cmd{DeclareEntryOption}, respectively.
\end{ltxsyntax}

\subsubsection{参考文献表环境}%Bibliography Environments
\label{aut:bbx:env}

除了定义参考文献驱动，参考文献著录样式也要定义参考文献表环境用于控制参考文献表的输出。这些环境由\cmd{defbibenvironment} 命令定义。默认情况下，\cmd{printbibliography} 使用\opt{bibliography} 环境。下面是一个适用于不打印标签的参考文献表的环境定义:
%Apart from defining bibliography drivers, the bibliography style is also responsible for the environments which control the layout of the bibliography and bibliography lists. These environments are defined with \cmd{defbibenvironment}. By default, \cmd{printbibliography} uses the environment \opt{bibliography}. Here is a definition suitable for a bibliography style which does not print any labels in the bibliography:

\begin{ltxexample}
\defbibenvironment{bibliography}
  {\list
     {}
     {\setlength{\leftmargin}{\bibhang}%
      \setlength{\itemindent}{-\leftmargin}%
      \setlength{\itemsep}{\bibitemsep}%
      \setlength{\parsep}{\bibparsep}}}
  {\endlist}
  {\item}
\end{ltxexample}
%
该定义使用\biblatex 提供的\cmd{bibhang}\gls{尺寸}，应用了一个带悬挂缩进的\env{list} 环境。它允许使用\cmd{bibitemsep} 和 \cmd{bibparsep} 来进行一定程度的布局调整，\biblatex 提供的这两个尺寸的目的也在于此(见 \secref{aut:fmt:len})。作者年制(\texttt{authoryear})和作者题名制(\texttt{authortitle})的参考文献样式使用类似于该例的定义。
%This definition employs a \env{list} environment with hanging indentation, using the \cmd{bibhang} length register provided by \biblatex. It allows for a certain degree of configurability by using \cmd{bibitemsep} and \cmd{bibparsep}, two length registers provided by \biblatex for this very purpose (see \secref{aut:fmt:len}). The \texttt{authoryear} and \texttt{authortitle} bibliography styles use a definition similar to this example.

\begin{ltxexample}
\defbibenvironment{bibliography}
  {\list
     {\printfield[labelnumberwidth]{labelnumber}}
     {\setlength{\labelwidth}{\labelnumberwidth}%
      \setlength{\leftmargin}{\labelwidth}%
      \setlength{\labelsep}{\biblabelsep}%
      \addtolength{\leftmargin}{\labelsep}%
      \setlength{\itemsep}{\bibitemsep}%
      \setlength{\parsep}{\bibparsep}}%
      \renewcommand*{\makelabel}[1]{\hss##1}}
  {\endlist}
  {\item}
\end{ltxexample}
%
一些参考文献样式在参考文献表中打印标签。比如，设计一个顺序编码的参考文献样式需要在参考文献表中每个条目前面打印顺序编码数字，这样参考文献表看起来就像一个顺序列表。在第一个示例中，\cmd{list} 命令的第一个参数是空的。在上面这个示例中，我们需要在其中插入数字，这些数字由\biblatex 的\bibfield{labelnumber} 域提供。我们也应用\biblatex 提供的几个尺寸和工具，详见 \secref{aut:fmt:ich, aut:fmt:ilc}。顺序编码制(\texttt{numeric})参考文献样式使用如上的定义。顺序字母制(\texttt{alphabetic})的样式也是类似的，只是用\texttt{labelalpha} 和\texttt{labelalphawidth} 代替了\textsf{\texttt{labelnumber}} 和\texttt{labelnumberwidth}。
%Some bibliography styles print labels in the bibliography. For example, a bibliography style designed for a numeric citation scheme will print the number of every entry such that the bibliography looks like a numbered list. In the first example, the first argument to \cmd{list} was empty. In this example, we need it to insert the number, which is provided by \biblatex in the \bibfield{labelnumber} field. We also employ several length registers and other facilities provided by \biblatex, see \secref{aut:fmt:ich, aut:fmt:ilc} for details. The \texttt{numeric} bibliography style uses the definition given above. The \texttt{alphabetic} style is similar, except that \textsf{\texttt{labelnumber}} is replaced by \texttt{labelalpha} and \texttt{labelnumberwidth} by \texttt{labelalphawidth}.

参考文献列表以类似方式处理。\cmd{printbiblist} 命令默认使用以bibliography list命名的环境。
%(当使用\bibtex 时，\cmd{printshorthands} 总是使用\texttt{shorthand} 环境)。
一个典型示例如下，其中的尺寸和工具定义详见第\secref{aut:fmt:ich, aut:fmt:ilc} 节。
%Bibliography lists are handled in a similar way. \cmd{printbiblist} uses the environment named after the bibliography list by default. A typical example is given below. See \secref{aut:fmt:ich, aut:fmt:ilc} for details on the length registers and facilities used in this example.

\begin{ltxexample}
\defbibenvironment{shorthand}
  {\list
     {\printfield[shorthandwidth]{shorthand}}
     {\setlength{\labelwidth}{\shorthandwidth}%
      \setlength{\leftmargin}{\labelwidth}%
      \setlength{\labelsep}{\biblabelsep}%
      \addtolength{\leftmargin}{\labelsep}%
      \setlength{\itemsep}{\bibitemsep}%
      \setlength{\parsep}{\bibparsep}%
      \renewcommand*{\makelabel}[1]{##1\hss}}}
  {\endlist}
  {\item}
\end{ltxexample}

\subsubsection{参考文献驱动} %Bibliography Drivers
\label{aut:bbx:drv}

在讨论\biblatex 包的数据接口命令前，了解一下参考文献驱动的结构是有益的。注意，虽然下面给出的示例是大为简化的，但仍具有说明价值。为可读性考虑，我们忽略了一些可能是\bibtype{book} 条目的域，并且简化处理没有忽略的域。主要是为了说明驱动的结构。关于\bibtex 文件格式域与\biblatex 宏包数据类型的映射信息，见\secref{bib:fld}。
%Before we go over the commands which form the data interface of the \biblatex package, it may be instructive to have a look at the structure of a bibliography driver. Note that the example given below is greatly simplified, but still functional. For the sake of readability, we omit several fields which may be part of a \bibtype{book} entry and also simplify the handling of those which are considered. The main point is to give you an idea of how a driver is structured. For information about the mapping of the \bibtex file format fields to \biblatex's data types, see \secref{bib:fld}.

\begin{ltxexample}
\DeclareBibliographyDriver{book}{%
  \printnames{author}%
  \newunit\newblock
  \printfield{title}%
  \newunit\newblock
  \printlist{publisher}%
  \newunit
  \printlist{location}%
  \newunit
  \printfield{year}%
  \finentry}
\end{ltxexample}
%
标准的参考文献样式应用两个参考文献宏\texttt{begentry} 和\texttt{finentry}:
%The standard bibliography styles employ two bibliography macros \texttt{begentry} and \texttt{finentry}:

\begin{ltxexample}
\DeclareBibliographyDriver{<<entrytype>>}{%
  \usebibmacro{begentry}
  ...
  \usebibmacro{finentry}}
\end{ltxexample}
%
默认定义为:
%with the default definitions
\begin{ltxexample}
\newbibmacro*{begentry}{}
\newbibmacro*{finentry}{\finentry}
\end{ltxexample}
%
为方便在驱动开始或结束时使用钩子，推荐使用这两个宏。
%Use of these macros is recommended for easy hooks into the beginning and end of the driver.

上述给出的\texttt{book} 条目类型的驱动中存在有一些缺省: 即\cmd{printnames}, \cmd{printlist}, 和 \cmd{printfield} 命令所使用的格式化指令。为了说明一个格式化指令是什么，这里给出上述驱动示例中所使用的指令。域格式是很直接的，域的值直接作为参数传递给能实现期望格式的指令。下面的指令简单地将输入参数用一个\cmd{emph} 命令包裹:
%Returning to the driver for the \texttt{book} entrytype above, there is still one piece missing: the formatting directives used by \cmd{printnames}, \cmd{printlist}, and \cmd{printfield}. To give you an idea of what a formatting directive looks like, here are some fictional ones used by our sample driver. Field formats are straightforward, the value of the field is passed to the formatting directive as an argument which may be formatted as desired. The following directive will simply wrap its argument in an \cmd{emph} command:

\begin{ltxexample}
\DeclareFieldFormat{title}{\emph{#1}}
\end{ltxexample}
%
列表格式则稍微要复杂一些。在将列表划分为独立的项后，\biblatex 将对列表中的每一项执行格式化指令。各项作为参数传递给格式化指令。列表中各项间的分隔符由相应的指令控制，因此我们在插入分隔符前必须要检查当前位置是位于列表中还是位于列表末尾。
%List formats are slightly more complex. After splitting up the list into individual items, \biblatex will execute the formatting directive once for every item in the list. The item is passed to the directive as an argument. The separator to be inserted between the individual items in the list is also handled by the corresponding directive, hence we have to check whether we are in the middle of the list or at the end when inserting it.

\begin{ltxexample}
\DeclareListFormat{location}{%
  #1%
  \ifthenelse{\value{listcount}<\value{liststop}}
    {\addcomma\space}
    {}}
\end{ltxexample}
%
%姓名(name)的格式化命令类似于这种抄录列表，但列表中的单个项是姓名，因此需要自动的解析为姓名的不同组成部分。列表格式化命令对列表中每个姓名都执行一次，信吗的各个部分以分开的参数传递给该命令。比如，|#1|是姓(last name)和|#3|是名(first name)。下面给出一个简化的格式化命令示例:
%上述各格式化命令调换了第一个作者的姓名前后顺序«Last, First»)，而其余姓名则是常规顺序(«First Last»)。注意:必须要保证提供的姓名部分是姓(last name)，因此我们必须要检查实际数据中姓名的哪些部分是存在的。如果姓名的一些部分不存在，则相关的变量就为空。如同抄录列表的命令，在各独立项之间插入的分隔符也由格式化命令控制，因为我们也要检查是否处于列表中还是在其末尾，这也是第二个\cmd{ifthenelse} 命令做的事情。

姓名(name)的格式化指令类似于抄录列表。
%Formatting directives for names are similar to those for literal lists.

依赖于数据模型常量<nameparts>的姓名有如下默认定义:
%Names depend on the datamodel constant <nameparts> which has the default definition:

\begin{ltxexample}
\DeclareDatamodelConstant[type=list]{nameparts}
                                    {prefix,family,suffix,given}
\end{ltxexample}
%
可以对其进行设置，比如添加更多姓名成分来处理类似父系姓的问题(见文件\file{93-nameparts.tex})。自然的，数据源需要一个扩展的姓名格式。\biblatexml (\secref{apx:biblatexml})可以处理该问题，其中有一个扩展的姓名格式，当使用\biber 后端时(见\biber 文档)，可以处理自定义的姓名成分。
This can be customised to add more name parts to deal with things like patronymics (see the example file \file{93-nameparts.tex}). This needs an extended name format for data sources since the standard \bibtex name format is very limited. \biblatexml (\secref{apx:biblatexml}) handles this natively and there is an extended name format which can handle custom nameparts when using \biber (see \secref{use:enf}).


在姓名格式中，姓名成分常量声明将为数据模型中定义的每个姓名成分提供两个宏:
%Inside name formats, the nameparts constant declaration makes available two macros for each name part defined in the datamodel:

\begin{ltxexample}
\namepart<namepart>   \% The full <namepart>
\namepart<namepart>i  \% The initials of the <namepart>
\namepart<namepart>un \% Numeric value indicating uniqueness level for <namepart>
\end{ltxexample}
%
%\cmd{namepart<namepart>un} only exists if the package option \opt{uniquename} is not set to <false> and can take the following values.
\cmd{namepart<namepart>un}仅当\opt{uniquename}包选项未设置成<false>时存在，可以设置为如下值:

\begin{argumentlist}{00}
\item[0] 不用于消除姓名歧义的<namepart>(因为在\cmd{DeclareUniquenameTemplate}中设置了\opt{disambiguation=none}，见\secref{aut:cav:amb}))。这种情况下，样式需要确定对应这一<namepart>需打印的内容。
%<namepart> was not used in disambiguating the name (because \opt{disambiguation=none} was set in \cmd{DeclareUniquenameTemplate}, see \secref{aut:cav:amb}). In this case the style should decide what to print for this <namepart>
\item[1] 仅需要为<namepart>打印首字母，用以根据\opt{uniquename}选项设置来确保唯一性。
%Initials only should be printed for <namepart> to ensure uniqueness according to the \opt{uniquename} package option setting
\item[2] 需要打印完整的<namepart>，用以根据\opt{uniquename}选项设置来确保唯一性。
%The full <namepart> should be printed to ensure uniqueness according to the \opt{uniquename} package option setting
\end{argumentlist}

%Note these per-namepart uniqueness macros are essentially an override of the \opt{uniquename} value (see \secref{aut:aux:tst}) for the name as a whole. Styles can choose to use either the less granular \opt{uniquename} value or the more detailed per-namepart values. Usually the general \opt{uniquename} value is enough for ordinary Western names but the more granular information per-namepart is provided to allow sophisticated name uniqueness processing for more complex name schemata.
注意，这些按姓名成分处理唯一性的宏实质上是对用于整个姓名的\opt{uniquename}值的覆盖(见\secref{aut:aux:tst})。样式可以选择使用更粗粒度的\opt{uniquename} 值或者更详细的依照姓名成分的值。通常情况下，\opt{uniquename}对于一般的西方姓名已经足够，但也提供了更细粒度的信息用于在复杂姓名格式中进行姓名唯一性的精细处理。
%The name formatting directive is executed once for each name in the name list. Here is a simplified example---the standard name formats are more intricate:
姓名的格式化指令对姓名列表中的每一个姓名进行处理，下面是一个简单示例，标准的格式化处理要更复杂:

\begin{ltxexample}
\DeclareNameFormat{author}{%
  \ifthenelse{\value{listcount}=1}
    {\namepartfamily%
     \ifdefvoid{\namepartgiven}{}{\addcomma\space\namepartgiven}}
    {\ifdefvoid{\namepartgiven}{}{\namepartgiven\space}%
     \namepartfamily}%
  \ifthenelse{\value{listcount}<\value{liststop}}
    {\addcomma\space}
    {}}
\end{ltxexample}
%
%The above directive reverses the name of the first author («Family, Given»)/(«Last, First») and prints the remaining names in their regular sequence («Given Family»)/(«First Last»). Note that the only component which is guaranteed to be available is the last/family name, hence we have to check which parts of the name are actually present. If a certain name part is not available, the corresponding macro will be empty. As with directives for literal lists, the separator to be inserted between the individual items in the name list is also handled by the formatting directive, hence we have to check whether we are in the middle of the list or at the end when inserting it. This is what the second \cmd{ifthenelse} test does. See also \secref{aut:bib:fmt}.
上述格式化指令调换了第一个作者的姓名前后顺序(«Last, First»)，而其余姓名则是常规顺序(«First Last»)。
注意: 当仅有一个姓名成分时，必须确保要它是姓(last name)，因此我们需要检查实际数据中姓名的哪些成分存在。
如果姓名的一些成分不存在，则相应的宏就为空。如同抄录列表的指令，在各独立项之间插入的分隔符也由格式化指令控制，
因为我们也要检查当前位置是处于列表中还是在其末尾，这也是第二个\cmd{ifthenelse} 命令做的事情。
另见\secref{aut:bib:fmt}节.



%A similar output that also respects the \cmd{multinamedelim} and \cmd{finalnamedelim} commands as well as the <prefix> and <suffix> name parts can be achieved with

一个涉及到\cmd{multinamedelim}和\cmd{finalnamedelim}命令，
及前缀(<prefix>) 和后缀(<suffix>)姓名成分的类似输出可以通过如下方式实现:

\begin{ltxexample}
\DeclareNameAlias{author}{family-given/given-family}
\end{ltxexample}

\subsubsection{特殊域}%Special Fields
\label{aut:bbx:fld}
下面的列表和域用于\biblatex 给参考文献驱动和标注命令传递数据。它们由宏包自动定义，并不在\file{bib} 文件中使用。但从参考文献著录和标注样式的角度看，它们与\file{bib} 文件中的域并没有什么不同。

%The following lists and fields are used by \biblatex to pass data to bibliography drivers and citation commands. They are not used in \file{bib} files but defined automatically by the package. From the perspective of a bibliography or citation style, they are not different from the fields in a \file{bib} file.

\paragraph{一般域} %Generic Fields
\label{aut:bbx:fld:gen}

\begin{fieldlist}

\fielditem{$<$datetype$>$dateunspecified}{string}

如果$<$datetype$>$date具有一个\acr{ISO8601-2} 4.3 <unspecified>，该域将被设置为\opt{yearindecade}, \opt{yearincentury}, \opt{monthinyear}, \opt{dayinmonth} 或\opt{dayinyear} 之一，这些字符串定义了unspecified 信息的粒度(即表示日期的不确定度，yearincentury表示一个世纪范围内不确定，yearindecade表示10年范围内不确定)。这些字符串可用于日期范围的判断，日期范围自动根据<unspecified>日期创建，一个样式可以选择一种特殊方式来格式化日期。参见\secref{bib:use:dat}。例如:一个条目的日期为:
%If $<$datetype$>$date held an \acr{ISO8601-2} 4.3 <unspecified>, this field will be set to one of \opt{yearindecade}, \opt{yearincentury}, \opt{monthinyear}, \opt{dayinmonth} or \opt{dayinyear} which specifies the granularity of the unspecified information. These strings can be tested for and along with the date ranges which are automatically created for such <unspecified> dates, a style may choose to format the date in a special way. See \secref{bib:use:dat}. For example, an entry with dates such as:

\begin{lstlisting}[style=bibtex]{}
@book{key,
  date     = {19uu},
  origdate = {199u}
}
\end{lstlisting}
%
将在\file{.bbl} 产生如下信息:
%would result in the same information in the \file{.bbl} as:
\begin{lstlisting}[style=bibtex]{}
@book{key,
  date     = {1900/1999},
  origdate = {1990/1999}
}
\end{lstlisting}
%
但也会额外地将\bibfield{dateunspecified} 域设置为<yearincentury>，将\bibfield{origdateunspecified} 设置为<yearindecade>。这一信息可以用来给\bibfield{date} 提供可能的信息<20th century>，给\bibfield{origdate} 提供<The 1990s>，这一信息无法单独从日期范围推算。当<unspecified>元信息给出时，这一自动生成的范围即已知，因此使用该范围值进行特殊的格式化相对容易。但标准样式不做此处理，\file{96-dates.tex} 给出了一些示例。
%but would additionally have the field \bibfield{dateunspecified} set to <yearincentury> and \bibfield{origdateunspecified} set to <yearindecade>. This information could be used to render the \bibfield{date} as perhaps <20th century> and \bibfield{origdate} as <The 1990s>, information which cannot be derived from the date ranges alone. Since such auto-generated ranges have a know values, given the <unspecified> meta-information, it is relatively easy to use the range values to format special cases. While the standard styles not do this, examples are given in the file \file{96-dates.tex}.

\fielditem{entrykey}{string}

\file{bib} 文件中某一项的条目关键词(entry key)。这是一个字符串，用于\biblatex 及其后端程序确定\file{bib} 文件中的某一条目。
%The entry key of an item in the \file{bib} file. This is the string used by \biblatex and the backend to identify an entry in the \file{bib} file.

 Note that the set of characters allowed and usable in the string for \bibfield{entrykey} depends on the backend (\biber, \bibtex) as well as the \latex engine (\pdflatex, \lualatex, \xelatex).
Generally, ASCII-letters (\texttt{a-z}, \texttt{A-Z}) and numbers (\texttt{0-9}) are safe, so are the punctuation characters full stop (\texttt{.}) and solidus (\texttt{/}). The punctuation characters \texttt{-\_:;!?} are also safe even if they are made active by \sty{babel}/\sty{polyglossia}. If a Unicode engine is used, non-ASCII characters are also acceptable.
Curly braces (\texttt{\{\}}), commas, spaces, backslashes (\texttt{\textbackslash}), hashes (\texttt{\#}), percent characters (\texttt{\%}) and tildes (\texttt{\textasciitilde}) are always forbidden. \biber additionally forbids round brackets (\texttt{()}), quotation marks (\texttt{\textquotedbl}, \texttt{\textquotesingle}), and the equals sign (\texttt{=}).
The \bibfield{entrykey} is case sensitive, but it is not recommended to exploit that fact too much by introducing two different entries whose key differs only in capitalisation (\eg\ \texttt{sigfridsson} and \texttt{Sigfridsson}).
For full portability it is advisable to stick to a scheme of lowercase (and if so desired uppercase) ASCII-letters, numbers and a small set of acceptable punctuation characters, say \texttt{.:-}.

\fielditem{childentrykey}{string}\DeprecatedMark

%This field is no longer necessary or recommended. For backwards
%compatibility, it is merely a copy of the \bibfield{entrykey} field in any
%set children.
该域不再必需的，也不推荐使用。为后向兼容考虑，它仅仅是集中子条目的\bibfield{entrykey}域的副本。


%老版本的信息:
%当引用一个条目集中的子条目时，\biblatex 给标注命令提供\bibtype{set} 父条目集的数据。这意味着\bibfield{entrykey} 将保存父条目集的关键词。而子条目的关键词在\bibfield{childentrykey} 域中提供。该域仅在引用条目集的某一子条目时使用。
%When citing a subentry of an entry set, \biblatex provides the data of the parent \bibtype{set} entry to citation commands. This implies that the \bibfield{entrykey} field holds the entry key of the parent. The entry key of the child entry being cited is provided in the \bibfield{childentrykey} field. This field is only available when citing a subentry of an entry set.

\fielditem{labelnamesource}{literal}

保存给\bibfield{labelname} 提供信息的域的域名，由\cmd{DeclareLabelname} 确定。
%Holds the name of the field used to populate \bibfield{labelname},
%determined by \cmd{DeclareLabelname}.

\fielditem{labeltitlesource}{literal}

保存给\bibfield{labeltitle} 提供信息的域的域名，由\cmd{DeclareLabeltitle} 确定。
%Holds the name of the field used to populate \bibfield{labeltitle},
%determined by \cmd{DeclareLabeltitle}.

\fielditem{labeldatesource}{literal}

保存如下内容之一:
%Holds one of:

\begin{itemize}
\item 由\cmd{DeclareLabeldate} 选择的日期域域名中<date>前的前缀内容。
%The prefix coming before <date> of the date field name chosen by
%\cmd{DeclareLabeldate}
\item 一个域的域名。
%The name of a field
\item 一个抄录或本地化字符串。\footnote{译者: literal 译为抄录}
%A literal or localisation string
\end{itemize}
%

一般情况下保存由\cmd{DeclareLabeldate} 选择的日期域域名中<date>前的前缀内容。例如，如果labeldate域是\bibfield{eventdate}，那么\bibfield{labeldatesource} 就是<event>。如果\cmd{DeclareLabeldate} 命令选择了\bibfield{date} 域，\bibfield{labeldatesource} 将会定义为一个空字符串作为<date>的前缀，因为\bibfield{date} 域名中<date>前内容为空。这就是说\bibfield{labeldatesource} 的内容可以用于构建\cmd{DeclareLabeldate} 选择的域的指针。因为\cmd{DeclareLabeldate} 也可以选择抄录字符串作为备选，\bibfield{labeldatesource} 可以指向一个域或者不进行定义。记住:\cmd{DeclareLabeldate} 命令可以用于选择非日期域作为备选，所以\bibfield{labeldatesource} 也可能包含一个域名。所以，总结起来，规则如下:
%Normally holds the prefix coming before <date> of the date field name chosen by \cmd{DeclareLabeldate}. For example, if the labeldate field is \bibfield{eventdate}, then \bibfield{labeldatesource} will be <event>. In case \cmd{DeclareLabeldate} selects the \bibfield{date} field, then \bibfield{labeldatesource} will be defined but will be an empty string as the prefix coming before <date> in the date label name is empty. This is so that the contents of \bibfield{labeldatesource} can be used in constructing references to the field which \cmd{DeclareLabeldate} chooses. Since \cmd{DeclareLabeldate} can also select literal strings for fallbacks, \bibfield{labeldatesource} may not refer to a field or may be undefined. Bear in mind that \cmd{DeclareLabeldate} can also be used to select non-date fields as a fallback and so \bibfield{labeldatesource} might contain a field name. So, in summary, the rules are

\begin{ltxexample}
\iffieldundef{labeldatesource}
  {}% labeldate package option is not set
  {\iffieldundef{\thefield{labeldatesource}year}
    % \DeclareLabeldate resolved to either a literal/localisation
    % string or a non-date field since
    % if a date is defined by a date field, there is
    % at least a year
    {\iffieldundef{\thefield{labeldatesource}}
       {}% \DeclareLabeldate resolved to a literal/localisation string
       {}% \DeclareLabeldate resolved to a non-date field
    }
    {} % \DeclareLabeldate resolved a date field name prefix like "" or "orig"
  }
\end{ltxexample}

\fielditem{entrytype}{string}

	条目类型(\bibtype{book}, \bibtype{inbook} 等)，以小写字母给出。
%The entry type (\bibtype{book}, \bibtype{inbook}, etc.), given in lowercase letters.

\fielditem{childentrytype}{string}\DeprecatedMark
%This field is no longer necessary or recommended. For backwards
%compatibility, it is merely a copy of the \bibfield{entrytype} field in any
%set children.
该域不再是必需的，也不推荐使用。为后向兼容考虑，它仅仅是集中子条目的\bibfield{entrytype}域的副本。


%老版本信息:
%当引用一个条目集的子条目时，\biblatex 为标注命令提供父集条目的数据。这意味着\bibfield{entrytype} 保存父条目的类型。子条目的类型则由\bibfield{childentrytype} 域提供。该域仅在引用一个条目集的子条目时使用。
%When citing a subentry of an entry set, \biblatex provides the data of the parent \bibtype{set} entry to citation commands. This implies that the \bibfield{entrytype} field holds the entry type of the parent. The entry type of the child entry being cited is provided in the \bibfield{childentrytype} field. This field is only available when citing a subentry of an entry set.

\fielditem{entrysetcount}{integer}

	
%This field holds an integer indicating the position of a set member in the entry set (starting at \texttt{1}). This field is only available in the subentries of an entry set.
该域保存的整数用于指明一个条目集中某个集成员的位置(起始值是\texttt{1})。该域仅对一个条目集的子条目有用。

\fielditem{hash}{string}

%This field is special in that it is only available locally in name formatting directives. It holds a hash string which uniquely identifies individual names in a name list. This information is available for all names in all name lists. See also \bibfield{namehash} and \bibfield{fullhash}.
该域非常特殊，仅在姓名格式化命令中使用。它保存一个hash字符串，用于唯一地确定姓名列表中的各个姓名。姓名列表中的所有姓名都具有该信息。另可参见\bibfield{namehash} 和\bibfield{fullhash}。


\fielditem{namehash}{string}

%A hash string which uniquely identifies the \bibfield{labelname} list. This is useful for recurrence checks. For example, a citation style which replaces recurrent authors or editors with a string like <idem> could save the \bibfield{namehash} field with \cmd{savefield} and use it in a comparison with \cmd{iffieldequals} later (see \secref{aut:aux:dat, aut:aux:tst}). The \bibfield{namehash} is derived from the truncated \bibfield{labelname} list, \ie it is responsive to \opt{maxnames} and \opt{minnames}. See also \bibfield{hash} and \bibfield{fullhash}.
一个hash字符串用于唯一确定\bibfield{labelname} 列表。用于在线检查。比如，一个将再次出现的作者和编者用一个类似<idem>的字符串代替的标注样式，
可以用\cmd{savefield} 命令保存\bibfield{namehash} 域，
并用于后面的\cmd{iffieldequals} 比较中(见\secref{aut:aux:dat, aut:aux:tst})。
\bibfield{namehash} 域由截短的\bibfield{labelname} 列表确定，
即与\opt{maxnames} 和\opt{minnames} 选项相关。
另可参见\bibfield{hash} 和\bibfield{fullhash}。


\fielditem{bibnamehash}{string}

%As \bibfield{namehash} but responsive to \opt{maxbibnames} and
%\opt{minbibnames}. This is not used in standard styles but may be used to
%make tests in bibliography lists (such as those used to determine whether
%dashes should replace repeated authors) behave differently.

类似于 \bibfield{namehash} ，但与\opt{maxbibnames} 和
\opt{minbibnames}相关。不用域标准样式中，但可以用在文献表中做测试
(比如用于判断是否用破折号代替重复作者的情况)


\fielditem{$<$namelist$>$namehash}{string}


%As \bibfield{namehash} for the name list called <namelist>.
类似于\bibfield{namehash}，但用于 <namelist>姓名列表。

\fielditem{$<$namelist$>$bibnamehash}{string}

As \bibfield{bibnamehash} for the name list called <namelist>.

\fielditem{fullhash}{string}

%A hash string which uniquely identifies the \bibfield{labelname} list. This fields differs from \bibfield{namehash} in two details: 1) The \bibfield{shortauthor} and \bibfield{shorteditor} lists are ignored when generating the hash. 2) The hash always refers to the full list, ignoring \opt{maxnames} and \opt{minnames}. See also \bibfield{hash} and \bibfield{namehash}.
一个hash字符串用于唯一确定\bibfield{labelname} 列表。该域与\bibfield{namehash} 有两点不同:1.产生hash时忽略\bibfield{shortauthor} 和\bibfield{shorteditor} 列表。2.该hash指的是完整的列表，忽略\opt{maxnames} 和\opt{minnames} 选项。另可参见\bibfield{hash} 和\bibfield{namehash}。


\fielditem{$<$namelist$>$fullhash}{string}

%As \bibfield{fullhash} for the name list called <namelist>.
类似于\bibfield{fullhash}，但用于 <namelist>姓名列表。


\listitem{pageref}{literal}

%If the \opt{backref} package option is enabled, this list holds the page numbers of the pages on which the respective bibliography entry is cited. If there are \env{refsection} environments in the document, the back references are local to the reference sections.
如果\opt{backref} 包选项启用，该域保存条目被引用所在各页的页码。如果文档中有\env{refsection} 环境，反向引用仅包含当前参考文献节(refsection)内的页码信息。


\fielditem{sortinit}{literal}

%This field holds the initial character of the information used during sorting.
该域保存排序所使用信息的首字符。%使用\bibtex 时，该域也用来代替\bibfield{sortinithash} 域。


\fielditem{sortinithash}{string}

%This field holds a hash of the (locale-specific) Unicode Collation Algorithm primary weight of the first extended grapheme cluster (essentially the first character) of the string used during sorting. This is useful when subdividing the bibliography alphabetically and is used internally by \cmd{bibinitsep} (see \secref{use:fmt:len}).
%使用\biber 时，
该域保存排序字符串的第一个扩展字素集(基本上是第一个字符)的Unicode排序规则算法主权重的hash值。可用于按照字母表顺序划分参考文献列表，该域在\cmd{bibinitsep} 命令内部使用(见\secref{use:fmt:len})。


\fielditem{clonesourcekey}{string}

%This field holds the entry key of the entry from which an entry was cloned. Clones are created for
%entries which are mentioned in \bibfield{related} fields as part of related entry processing, for example.
该域保存复制条目的来源条目的关键词。例如，关联条目处理中\bibfield{related} 域所涉及的条目往往需要进行复制。

\fielditem{urlraw}{verbatim}

%This is the unencoded, raw version of any \bibfield{url}. This is intended for use when the display version and clickable link version of a URL are different. This can be the case when the URL contains special or Unicode characters. In the case where no such characters occur, may be identical to the \bibfield{url}.
\bibfield{url}域的未编码，原始版本。用于当显示的网址与点击时的链接网址不一致的情况，比如网址带有一些特殊的或unicode字符的情况。倘若没有这些特殊字符，它与\bibfield{url}域是一致的。


\end{fieldlist}

\paragraph{标注(引用)标签中使用的域}%Fields for Use in Citation Labels
\label{aut:bbx:fld:lab}

\begin{fieldlist}

\fielditem{labelalpha}{literal}

	%当使用\bibtex 为后端程序时，
一个与传统\bibtex 的\path{alpha.bst} 样式产生标签类似的标签。这一标签默认由\bibfield{labelname} 列表抽取的首字母加上出版年的最后两个数字构成。\bibfield{label} 域可用来重设它的非数字部分(non-numeric portion)。如果定义了\bibfield{label} 域，\biblatex 将使用它的值加上出版年的后两个数字生成\bibfield{labelalpha}。\bibfield{shorthand} 域也可用于重设整个标签。如果定义了该域，\bibfield{labelalpha} 就是\bibfield{shorthand} 域，而不是一个自动生成的标签。用户可以定义一个模板用于构建字母顺序标签(见\secref{aut:ctm:lab})，而默认的模板与上面bibtex标签的格式相同。一个完整的字母顺序(<alphabetic>)标签由\bibfield{labelalpha} 加\bibfield{extraalpha} 域构成。注意: 使用\bibfield{labelalpha} 和\bibfield{extraalpha} 域需要打开\opt{labelalpha} 包选项(\secref{use:opt:pre:int})。另可参见\secref{use:fmt:fmt} 节的\bibfield{extraalpha} 和\cmd{labelalphaothers}。
%A label similar to the labels generated by the \path{alpha.bst} style of traditional \bibtex. This default label consists of initials drawn from the \bibfield{labelname} list plus the last two digits of the publication year. The \bibfield{label} field may be used to override its non"=numeric portion. If the \bibfield{label} field is defined, \biblatex will use its value and append the last two digits of the publication year when generating \bibfield{labelalpha}. The \bibfield{shorthand} field may be used to override the entire label. If defined, \bibfield{labelalpha} is the \bibfield{shorthand} rather than an automatically generated label. Users can specify a template used to construct the alphabetic label (see \secref{aut:ctm:lab}) and the default template mirrors the format mentioned for bibtex above. A complete <alphabetic> label consists of the fields \bibfield{labelalpha} plus \bibfield{extraalpha}. Note that the \bibfield{labelalpha} and \bibfield{extraalpha} fields need to be requested with the package option \opt{labelalpha} (\secref{use:opt:pre:int}). See also \bibfield{extraalpha} as well as \cmd{labelalphaothers} in \secref{use:fmt:fmt}.

\fielditem{extraalpha}{integer}

	当参考文献中包含同一作者同年出版的多个引文时，<alphabetic>标注样式的标签常需要一个额外的字母加以区分。这种情况下\bibfield{extraalpha} 域保存一个整数，该整数可用命令\cmd{mknumalph} 转换成字母或以其他方式格式化。该域类似于在作者年(author-year)样式中\bibfield{extrayear} 的作用。完整的 <alphabetic>的标签由\bibfield{labelalpha} 加 \bibfield{extraalpha} 构成。注意: 使用\bibfield{labelalpha} 和 \bibfield{extraalpha} 域需要启用包选项 \opt{labelalpha}(详见\secref{use:opt:pre:int})。另可参见\secref{use:fmt:fmt} 节的\bibfield{labelalpha} 和 \ cmd{labelalphaothers}。表\ref{use:opt:tab1} 总结了用于消除歧义的不同\opt{extra*}\gls{计数器} 及其记录的信息。
%The <alphabetic> citation scheme usually requires a letter to be appended to the label if the bibliography contains two or more works by the same author which were all published in the same year. In this case, the \bibfield{extraalpha} field holds an integer which may be converted to a letter with \cmd{mknumalph} or formatted in some other way. This field is similar to the role of \bibfield{extradate} in the author"=year scheme. A complete <alphabetic> label consists of the fields \bibfield{labelalpha} plus \bibfield{extraalpha}. Note that the \bibfield{labelalpha} and \bibfield{extraalpha} fields need to be requested with the package option \opt{labelalpha}, see \secref{use:opt:pre:int} for details. See also \bibfield{labelalpha} as well as \cmd{labelalphaothers} in \secref{use:fmt:fmt}. Table \ref{use:opt:tab1} summarises the various \opt{extra*} disambiguation counters and what they track.

\listitem{labelname}{name}

%The name to be printed in citations. This list is a copy of either the \bibfield{shortauthor}, the \bibfield{author}, the \bibfield{shorteditor}, the \bibfield{editor}, or the \bibfield{translator} list, which are normally checked for in this order. If no authors and editors are available, this list is undefined. Note that this list is also responsive to the \opt{use$<$name$>$}, options, see \secref{use:opt:bib}. Citation styles should use this list when printing the name in a citation. This list is provided for convenience only and does not carry any additional meaning.
%This field may be customized. See \secref{aut:ctm:fld} for details.
标注标签中打印的姓名。该列表可以是\bibfield{shortauthor}, \bibfield{author},  \bibfield{shorteditor}, \bibfield{editor}, 或\bibfield{translator} 域的复制值，正常情况以该顺序检测。如果没有作者(authors)和编者(authors)，该列表是未定义的。注意: 该列表也与\opt{use$<$name$>$} 相关，见\secref{use:opt:bib}。标注样式打印引用标签中的姓名时使用这一列表。提供该列表仅为方便起见，没有附加的意义。该域可以定制，详见\secref{aut:ctm:fld}。


\fielditem{extraname}{integer}

%Holds a count of the number of bibliography entries within a refsection which derive from the same \bibfield{labelname} list. This counter takes account of \opt{uniquename} settings (see \secref{use:opt:pre:int}). While not used by any standard styles, this field is useful in styles which wish to number bibliography entries on a per-\bibfield{labelname} basis. This field will only exist if there is a \bibfield{labelname}. The \bibfield{extraname} counter is related to, but conceptually different from \cmd{ifsingletitle} (see \secref{use:opt:pre:int} and \secref{aut:aux:tst}).
保存一个参考文献节内具有相同\bibfield{labelname}姓名列表的文献条目的数量。标准样式不使用。
该域对于希望在每个\bibfield{labelname}层次统计文献条目数很有用。该域仅在\bibfield{labelname}域存在时才会存在，
\bibfield{extraname}计数器逻辑上与 \cmd{ifsingletitle}类似，但概念不同(见\secref{use:opt:pre:int} 和 \secref{aut:aux:tst})。

\fielditem{labelnumber}{literal}

%The number of the bibliography entry, as required by numeric citation schemes. If the \bibfield{shorthand} field is defined, \biblatex does not assign a number to the respective entry. In this case \bibfield{labelnumber} is the shorthand rather than a number. Numeric styles must use the value of this field instead of a counter. Note that this field needs to be requested with the package option \opt{labelnumber}, see \secref{use:opt:pre:int} for details. Also see the package option \opt{defernumbers} in \secref{use:opt:pre:gen}.
参考文献条目的序号，用于顺序编码类的样式。如果定义了\bibfield{shorthand} 域，\biblatex 不再给各条目赋予一个数值。这种情况下，\bibfield{labelnumber} 就是shorthand而不是一个数字。顺序编码类的样式必须使用该域的值而不是一个计数器值。注意: 使用该域需要启用包选项\opt{labelnumber}，详见\secref{use:opt:pre:int}。另可参见\secref{use:opt:pre:gen} 节的\opt{defernumbers} 选项。


\fielditem{labelprefix}{literal}

%If the \opt{labelprefix} option of \cmd{newrefcontext} has been set in order to prefix all entries in a subbibliography with a fixed string, this string is available in the \bibfield{labelprefix} field of all affected entries. If no prefix has been set, the \bibfield{labelprefix} field of the respective entry is undefined. See the \opt{labelprefix} option of \cmd{newrefcontext} in \secref{use:bib:context} for details. If the \bibfield{shorthand} field is defined, \biblatex does not assign the prefix to the \bibfield{labelprefix} field of the respective entry. In this case, the \bibfield{labelprefix} field is undefined.
如果要在一个subbibliography文献表的所有条目前都添加一个固定的字符串，设置了\cmd{newrefcontext} 命令的\opt{labelprefix} 选项，那么所有受影响的\bibfield{labelprefix} 域将提供该字符串。如果未设置前缀，相应条目的\bibfield{labelprefix} 域是未定义的。详见\secref{use:bib:context} 节\cmd{newrefcontext} 命令的\opt{labelprefix} 选项。如果定义了\bibfield{shorthand} 域，\biblatex 不会给相应条目的\bibfield{labelprefix} 域设置前缀。这种情况下\bibfield{labelprefix} 是未定义的。


\fielditem{labeltitle}{literal}
%The printable title of a work. In some circumstances, a style might need to choose a title from a list of a possible title fields. For example, citation styles printing short titles may want to print the \bibfield{shorttitle} field if it exists but otherwise print the \bibfield{title} field. The list of fields to be considered when constructing \bibfield{labeltitle} may be customized. See \secref{aut:ctm:fld} for details. Note that the \bibfield{extratitle} field needs to be requested with the package option \opt{labeltitle}, see \secref{use:opt:pre:int} for details. See also \bibfield{extratitle}. Note also that the \bibfield{extratitleyear} field needs to be requested with the package option \opt{labeltitleyear}. See also \bibfield{extratitleyear}.
一篇文献可打印题名(标题)。在一些环境中，一个样式可能需要在一些可能的标题域中选择一个标题。例如，标注样式打印短标题可能需要打印\bibfield{shorttitle} 域(如果它存在的话)，否则将打印\bibfield{title} 域。构建\bibfield{labeltitle} 时考虑的域的列表可以自定义。详见 \secref{aut:ctm:fld}。注意: 使用\bibfield{extratitle} 域要求启用\opt{labeltitle} 包选项，详见\secref{use:opt:pre:int}。另可参见\bibfield{extratitle}。也要注意使用\bibfield{extratitleyear} 域也需要启用\opt{labeltitleyear} 包选项，另可参见\bibfield{extratitleyear}。


\fielditem{extratitle}{integer}

%It is sometimes useful, for example in author"=title citation schemes, to be able to disambiguate works with the same title. For works by the same \bibfield{labelname} with the same \bibfield{labeltitle}, the \bibfield{extratitle} field holds an integer which may be converted to a letter with \cmd{mknumalph} or formatted in some other way (or it can be merely used as a flag to say that some other field such as a date should be used in conjunction with the \bibfield{labeltitle} field). This field is undefined if there is only one work with the same \bibfield{labeltitle} by the same \bibfield{labelname} in the bibliography. Note that the \bibfield{extratitle} field needs to be requested with the package option \opt{labeltitle}, see \secref{use:opt:pre:int} for details. See also \bibfield{labeltitle}. Table \ref{use:opt:tab1} summarises the various \opt{extra*} disambiguation counters and what they track.
该命令有时很有用，比如在author-title标注样式中，用于区分标题相同的文献。当有文献具有相同的\bibfield{labelname} 和\bibfield{labeltitle} 时，\bibfield{extratitle} 域保存一个整数，可以利用\cmd{mknumalph} 转换为一个字母或者以其它方式格式化(或者可以仅仅作为一个标志，用于表示将一些其它域比如日期与\bibfield{labeltitle} 域合并)。当文献表中具有相同\bibfield{labeltitle} 和\bibfield{labelname} 的文献只有一篇时，该域不定义。注意:使用\bibfield{extratitle} 域需要启用\opt{labeltitle} 包选项，详见\secref{use:opt:pre:int}。另可参见\bibfield{labeltitle}。\ref{use:opt:tab1} 总结了各种\opt{extra*} 计数器及其作用。


\fielditem{extratitleyear}{integer}

%It is sometimes useful, for example in author"=title citation schemes, to be able to disambiguate works with the same title in the same year but with no author. For works with the same \bibfield{labeltitle} and with the same \bibfield{labelyear}, the \bibfield{extratitleyear} field holds an integer which may be converted to a letter with \cmd{mknumalph} or formatted in some other way (or it can be merely used as a flag to say that some other field such as a publisher should be used in conjunction with the \bibfield{labelyear} field). This field is undefined if there is only one work with the same \bibfield{labeltitle} and \bibfield{labelyear} in the bibliography. Note that the \bibfield{extratitleyear} field needs to be requested with the package option \opt{labeltitleyear}, see \secref{use:opt:pre:int} for details. See also \bibfield{labeltitleyear}. Table \ref{use:opt:tab1} summarises the various \opt{extra*} disambiguation counters and what they track.
该命令有时很有用，比如在author-title标注样式中，用于区分标题相同年份相同但没有责任者的文献。当有文献具有相同的\bibfield{labeltitle} 和\bibfield{labelyear}，\bibfield{extratitleyear} 域保存一个整数，可以利用\cmd{mknumalph} 转换为一个字母或者以其它方式格式化(或者可以仅仅作为一个标志，用于表示将一些其它域比如出版者与\bibfield{labelyear} 域合并)。当文献表中具有相同\bibfield{labeltitle} 和\bibfield{labelyear} 的文献只有一篇时，该域不定义。注意: 使用\bibfield{extratitle} 域需要启用\opt{labeltitleyear} 包选项，详见\secref{use:opt:pre:int}。另可参见\bibfield{labeltitleyear}。\ref{use:opt:tab1} 总结了各种\opt{extra*} 计数器及其作用。


\fielditem{labelyear}{literal}

%The year of the date field selected by \cmd{DeclareLabeldate} (\secref{aut:ctm:fld}) or the \bibfield{year} field, for use in author-year labels. A complete author-year label consists of the fields \bibfield{labelyear} plus \bibfield{extradate}. Note that the \bibfield{labelyear} and \bibfield{extradate} fields need to be requested with the package option \opt{labeldateparts}, see \secref{use:opt:pre:int} for details. See also \bibfield{extradate}.
\cmd{DeclareLabeldate}(\secref{aut:ctm:fld})命令选择的日期域的年，或者\bibfield{year} 域，用于作者年制的标签。一个完整的作者年制的标签由\bibfield{labelyear} 加\bibfield{extrayear} 域构成。注意使用\bibfield{labelyear} 和\bibfield{extrayear} 域需要启用\opt{labeldateparts} 包选项，详见\secref{use:opt:pre:int}。另可参见\bibfield{extrayear}。


\fielditem{labelendyear}{literal}

%The end year of the date field selected by \cmd{DeclareLabeldate} (\secref{aut:ctm:fld}) if the selected date is a range.
\cmd{DeclareLabeldate} (\secref{aut:ctm:fld})命令选择的日期域的终止年，如果选择的日期是一个范围。


\fielditem{labelmonth}{datepart}

%The month of the date field selected by \cmd{DeclareLabeldate} (\secref{aut:ctm:fld}), or the \bibfield{month} field for use in author-year labels. Note that the \bibfield{labelmonth} field needs to be requested with the package option \opt{labeldateparts}, see \secref{use:opt:pre:int} for details.
\cmd{DeclareLabeldate}(\secref{aut:ctm:fld})命令选择的日期域的月，或者\bibfield{month} 域，用于作者年制的标签。注意使用\bibfield{labelmonth} 域需要启用 \opt{labeldateparts} 包选项，详见\secref{use:opt:pre:int}。


\fielditem{labelendmonth}{datepart}

%The end month of the date field selected by \cmd{DeclareLabeldate} (\secref{aut:ctm:fld}) if the selected date is a range.
\cmd{DeclareLabeldate} (\secref{aut:ctm:fld})命令选择的日期域的终止月，如果选择的日期是一个范围。


\fielditem{labelday}{datepart}

%The month of the date field selected by \cmd{DeclareLabeldate} (\secref{aut:ctm:fld}) for use in author-year labels. Note that the \bibfield{labelday} field needs to be requested with the package option \opt{labeldateparts}, see \secref{use:opt:pre:int} for details.
\cmd{DeclareLabeldate}(\secref{aut:ctm:fld})命令选择的日期域的日，或者\bibfield{month} 域，用于作者年制的标签。注意使用 \bibfield{labelday} 域要求启用 \opt{labeldateparts} 包选项，详见\secref{use:opt:pre:int}。


\fielditem{labelendday}{datepart}

%The end day of the date field selected by \cmd{DeclareLabeldate} (\secref{aut:ctm:fld}) if the selected date is a range.
\cmd{DeclareLabeldate} (\secref{aut:ctm:fld})命令选择的日期域的终止日，如果选择的日期是一个范围。


\fielditem{extradate}{integer}

%The author"=year citation scheme usually requires a letter to be appended to the year if the bibliography contains two or more works by the same author which were all published in the same year. In this case, the \bibfield{extradate} field holds an integer which may be converted to a letter with \cmd{mknumalph} or formatted in some other way. This field is undefined if there is only one work by the author in the bibliography or if all works by the author have different publication years. A complete author-year label consists of the fields \bibfield{labelyear} plus \bibfield{extradate}. Note that the \bibfield{labelyear} and \bibfield{extradate} fields need to be requested with the package option \opt{labeldateparts}, see \secref{use:opt:pre:int} for details. See also \bibfield{labelyear}. Table \ref{use:opt:tab1} summarises the various \opt{extra*} disambiguation counters and what they track.
当参考文献表中包含两个或更多的具有相同作者的文献且出版年份也相同时，author-year标注样式常需要在年后面附加一个字母以示区分。这种情况下，\bibfield{extradate} 域保存一个整数可以利用\cmd{mknumalph} 转换为一个字母或者以其它方式格式化。当文献表中某作者的文献只有一篇或者所有该作者的文献的出版年不同时，该域不定义。完整的作者年标签由\bibfield{labelyear} 加\bibfield{extradate} 域构成。注意使用\bibfield{labelyear} 和\bibfield{extradate} 域需要启用\opt{labeldateparts} 包选项，详见\secref{use:opt:pre:int}。另可参见\bibfield{labelyear}。\ref{use:opt:tab1} 总结了各种\opt{extra*} 计数器及其作用。


\fielditem{extradatescope}{literal}

%This field contains the name of the most specific field which determined the value of \bibfield{extradate}. It is not used by the standard styles but may be useful in controlling the placement of the \bibfield{extradate} field value.
该域包含确定\bibfield{extradate}值的专用域的域名，标准样式不使用，但可能用于控制\bibfield{extradate}域值的配置。


\end{fieldlist}

\paragraph{Date的成分域}%Date Component Fields
\label{aut:bbx:fld:dat}

注意，可以在数据模型中定义新的日期域，这些新定义的日期域的使用方式与本节将介绍的默认数据模型类似。
%Note that it is possible to define new date fields in the datamodel which behave exactly like the default data model date fields described in this section.

\file{bib} 文件中的日期域与样式接口提供的日期域如何关联详见表\ref{aut:bbx:fld:tab1}。对样式中像\bibfield{origdate} 这样的域做判断时，使用如下代码:
%See \tabref{aut:bbx:fld:tab1} for an overview of how the date fields in \file{bib} files are related to the date fields provided by the style interface. When testing for a field like \bibfield{origdate} in a style, use code like:

\begin{ltxcode}
<<\iffieldundef>>{orig<<year>>}{...}{...}
\end{ltxcode}
%
它将告诉你相应的日期是否已定义。下面的判断:
%This will tell you if the corresponding date is defined at all. This test:

\begin{ltxcode}
<<\iffieldundef>>{orig<<endyear>>}{...}{...}
\end{ltxcode}
%
将告诉你相应的日期和一个(完全确定的)范围是否已定义。下面的判断
%will tell you if the corresponding date is defined and a (fully specified) range. This test:

\begin{ltxcode}
<<\iffieldequalstr>>{orig<<endyear>>}{}{...}{...}
\end{ltxcode}
%
将告诉你相应的日期和一个无期限的(open-ended)范围已经定义。 无期限(Open-ended，无终止日期的)范围由一个空的\texttt{endyear} 成分表示(而不是一个未定义的\texttt{endyear} 成分)。更多示例详见\secref{bib:use:dat} 节和\pageref{bib:use:tab1} 页的表\ref{bib:use:tab1}。
%will tell you if the corresponding date is defined and an open"=ended range. Open"=ended ranges are indicated by an empty \texttt{endyear} component (as opposed to an undefined \texttt{endyear} component). See \secref{bib:use:dat} and \tabref{bib:use:tab1} on page~\pageref{bib:use:tab1} for further examples.

\begingroup
\tablesetup
\begin{longtable}[l]{%
	@{}V{0.15\textwidth}%
	@{}V{0.4\textwidth}%
	@{}V{0.3\textwidth}%
	@{}V{0.2\textwidth}@{}}
\toprule
\multicolumn{2}{@{}H}{\file{bib} File} &
\multicolumn{2}{H}{Data Interface} \\
\cmidrule(r){1-2}\cmidrule(l){3-4}
\multicolumn{1}{@{}H}{Field} &
\multicolumn{1}{H}{Value (Example)} &
\multicolumn{1}{H}{Field} &
\multicolumn{1}{H}{Value (Example)} \\
\cmidrule{1-1}\cmidrule(lr){2-2}\cmidrule(l){3-3}\cmidrule(l){4-4}
date		& 1988			& day		& undefined \\
		&			& month		& undefined \\
		&			& year		& 1988 \\
		&			& season  & undefined \\
		&			& endday	& undefined \\
		&			& endmonth	& undefined \\
		&			& endyear	& undefined \\
		&			& endseason  & undefined \\
		&			& hour	& undefined \\
		&			& minute	& undefined \\
		&			& second	& undefined \\
		&			& timezone & undefined \\
		&			& endhour	& undefined \\
		&			& endminute	& undefined \\
		&			& endsecond	& undefined \\
		&			& endtimezone & undefined \\
date		& 1997/			& day		& undefined \\
		&			& month		& undefined \\
		&			& year		& 1997 \\
		&			& season  & undefined \\
		&			& endday	& undefined \\
		&			& endmonth	& undefined \\
		&			& endyear	& empty \\
		&			& endseason  & undefined \\
		&			& hour	& undefined \\
		&			& minute	& undefined \\
		&			& second	& undefined \\
		&			& timezone & undefined \\
		&			& endhour	& undefined \\
		&			& endminute	& undefined \\
		&			& endsecond	& undefined \\
		&			& endtimezone & undefined \\
urldate		& 2009-01-31		& urlday	& 31 \\
		&			& urlmonth	& 01 \\
		&			& urlyear	& 2009 \\
		&			& urlseason  & undefined \\
		&			& urlendday	& undefined \\
		&			& urlendmonth	& undefined \\
		&			& urlendyear	& undefined \\
		&			& urlendseason  & undefined \\
		&			& urlhour	& undefined \\
		&			& urlminute	& undefined \\
		&			& urlsecond	& undefined \\
		&			& urltimezone & undefined \\
		&			& urlendhour	& undefined \\
		&			& urlendminute	& undefined \\
		&			& urlendsecond	& undefined \\
		&			& urlendtimezone & undefined \\
urldate		& 2009-01-31T15:34:04Z		& urlday	& 31 \\
		&			& urlmonth	& 01 \\
		&			& urlyear	& 2009 \\
		&			& urlseason  & undefined \\
		&			& urlendday	& undefined \\
		&			& urlendmonth	& undefined \\
		&			& urlendyear	& undefined \\
		&			& urlendseason  & undefined \\
		&			& urlhour	& 15 \\
		&			& urlminute	& 34 \\
		&			& urlsecond	& 04 \\
		&			& urltimezone & Z \\
		&			& urlendhour	& undefined \\
		&			& urlendminute	& undefined \\
		&			& urlendsecond	& undefined \\
		&			& urlendtimezone & undefined \\
urldate		& 2009-01-31T15:34:04+05:00		& urlday	& 31 \\
		&			& urlmonth	& 01 \\
		&			& urlyear	& 2009 \\
		&			& urlseason  & undefined \\
		&			& urlendday	& undefined \\
		&			& urlendmonth	& undefined \\
		&			& urlendyear	& undefined \\
		&			& urlendseason  & undefined \\
		&			& urlhour	& 15 \\
		&			& urlminute	& 34 \\
		&			& urlsecond	& 04 \\
		&			& urltimezone & +0500 \\
		&			& urlendhour	& undefined \\
		&			& urlendminute	& undefined \\
		&			& urlendsecond	& undefined \\
		&			& urlendtimezone & undefined \\
urldate		& \parbox[t]{0.4\textwidth}{2009-01-31T15:34:04/\\2009-01-31T16:04:34}& urlday	& 31 \\
		&			& urlmonth	& 1 \\
		&			& urlyear	& 2009 \\
		&			& urlseason  & undefined \\
		&			& urlendday	& 31 \\
		&			& urlendmonth	& 1 \\
		&			& urlendyear	& 2009 \\
		&			& urlendseason  & undefined \\
		&			& urlhour	& 15 \\
		&			& urlminute	& 34 \\
		&			& urlsecond	& 4 \\
		&			& urltimezone & floating \\
		&			& urlendhour	& 16 \\
		&			& urlendminute	& 4 \\
		&			& urlendsecond	& 34 \\
		&			& urlendtimezone & floating \\
origdate	& 2002-21/2002-23	& origday	& undefined \\
		&			& origmonth	& 01 \\
		&			& origyear	& 2002 \\
		&			& origseason  & spring \\
		&			& origendday	& undefined \\
		&			& origendmonth	& 02 \\
		&			& origendyear	& 2002 \\
		&			& origendseason  & autumn \\
		&			& orighour	& undefined \\
		&			& origminute	& undefined \\
		&			& origsecond	& undefined \\
		&			& origtimezone & undefined \\
		&			& origendhour	& undefined \\
		&			& origendminute	& undefined \\
		&			& origendsecond	& undefined \\
		&			& origendtimezone & undefined \\
eventdate	& 1995-01-31/1995-02-05	& eventday	& 31 \\
		&			& eventmonth	& 01 \\
		&			& eventyear	& 1995 \\
		&			& eventseason  & undefined \\
		&			& eventendday	& 05 \\
		&			& eventendmonth	& 02 \\
		&			& eventendyear	& 1995 \\
		&			& eventendseason  & undefined \\
		&			& eventhour	& undefined \\
		&			& eventminute	& undefined \\
		&			& eventsecond	& undefined \\
		&			& eventtimezone & undefined \\
		&			& eventendhour	& undefined \\
		&			& eventendminute	& undefined \\
		&			& eventendsecond	& undefined \\
		&			& eventendtimezone & undefined \\
\bottomrule
%\end{tabularx}
\caption{日期接口(译者注:biblatex3.7版提供的四个可解析日期接口，分别是date，origdate，eventdate，urldate，在多数场合已经够用)}%Date Interface
\label{aut:bbx:fld:tab1}
\end{longtable}
\endgroup

\begin{fieldlist}

\fielditem{hour}{datepart}

该域保存\bibfield{date} 域的小时(hour)成分，当日期是一个范围时，它保存开始日期的小时成分。
%This field holds the hour component of the \bibfield{date} field. If the date is a range, it holds the hour component of the start date.

\fielditem{minute}{datepart}

该域保存\bibfield{date} 域的分钟成分，当日期是一个范围时，它保存开始日期的分钟成分。
%This field holds the minute component of the \bibfield{date} field. If the date is a range, it holds the minute component of the start date.

\fielditem{second}{datepart}

该域保存\bibfield{date} 域的秒钟成分，当日期是一个范围时，它保存开始日期的秒钟成分。
%This field holds the second component of the \bibfield{date} field. If the date is a range, it holds the second component of the start date.

\fielditem{timezone}{datepart}

该域保存\bibfield{date} 域的时区成分，当日期是一个范围时，它保存开始日期的时区成分。
%This field holds the timezone component of the \bibfield{date} field. If the date is a range, it holds the timezone component of the start date.

\fielditem{day}{datepart}

该域保存\bibfield{date} 域的日成分，当日期是一个范围时，它保存开始日期的日成分。
%This field holds the day component of the \bibfield{date} field. If the date is a range, it holds the day component of the start date.

\fielditem{month}{datepart}

该域保存数据源文件中的\bibfield{month} 域或者\bibfield{date} 域的月成分，当日期是一个范围时，它保存开始日期的月成分。
%This field is the \bibfield{month} as given in the database file or it holds the month component of the \bibfield{date} field. If the date is a range, it holds the month component of the start date.

\fielditem{year}{datepart}

该域保存数据源文件中的\bibfield{year} 域或者\bibfield{date} 域的年成分，当日期是一个范围时，它保存开始日期的年成分。
%This field is the \bibfield{year} as given in the database file or it holds the year component of the \bibfield{date} field. If the date is a range, it holds the year component of the start date.

\fielditem{season}{datepart}

该域保存由\acr{ISO8601-2} 4.7(见\secref{bib:use:dat})规定的\bibfield{date} 域的季节成分，它包含一个季节本地化字符串。当日期是一个范围时，它保存开始日期的季节成分。
%This field holds the season component of the \bibfield{date} field as specified by \acr{ISO8601-2} 4.7 (\secref{bib:use:dat}). It contains a season localisation string (\secref{aut:lng:key:dt}). If the date is a range, it holds the season component of the start date.

\fielditem{endhour}{datepart}

如果\bibfield{date} 域中给出的日期是一个范围，该域保存结束日期的小时成分。
%If the date specification in the \bibfield{date} field is a range, this field holds the hour component of the end date.

\fielditem{endminute}{datepart}

如果\bibfield{date} 域中给出的日期是一个范围，该域保存结束日期的分钟成分。
%If the date specification in the \bibfield{date} field is a range, this field holds the minute component of the end date.

\fielditem{endsecond}{datepart}

如果\bibfield{date} 域中给出的日期是一个范围，该域保存结束日期的秒钟成分。
%If the date specification in the \bibfield{date} field is a range, this field holds the second component of the end date.

\fielditem{endtimezone}{datepart}

如果\bibfield{date} 域中给出的日期是一个范围，该域保存结束日期的时区成分。
%If the date specification in the \bibfield{date} field is a range, this field holds the timezone component of the end date.

\fielditem{endday}{datepart}

如果\bibfield{date} 域中给出的日期是一个范围，该域保存结束日期的日成分。
%If the date specification in the \bibfield{date} field is a range, this field holds the day component of the end date.

\fielditem{endmonth}{datepart}

如果\bibfield{date} 域中给出的日期是一个范围，该域保存结束日期的月成分。
%If the date specification in the \bibfield{date} field is a range, this field holds the month component of the end date.

\fielditem{endyear}{datepart}

如果\bibfield{date} 域中给出的日期是一个范围，该域保存结束日期的年成分。空的(但已定义)的\bibfield{endyear} 成分表示无期限的日期范围。
%If the date specification in the \bibfield{date} field is a range, this field holds the year component of the end date. A blank (but defined) \bibfield{endyear} component indicates an open ended \bibfield{date} range.

\fielditem{endseason}{datepart}

如果\bibfield{date} 域中给出的日期是一个范围，该域保存\acr{EDTF} 5.2.5 (\secref{bib:use:dat})规定的结束日期的季节成分。它包含一个季节本地化字符串(见\secref{aut:lng:key:dt})，空的(但已定义)的\bibfield{endseason} 成分表示无期限的日期范围。
If the date specification in the \bibfield{date} field is a range, this field holds the season component of the end date as specified by \acr{ISO8601-2} 4.7 (\secref{bib:use:dat}). It contains a season localisation string (\secref{aut:lng:key:dt}). A blank (but defined) \bibfield{endseason} component indicates an open ended \bibfield{date} range.


\fielditem{orighour}{datepart}

该域保存\bibfield{origdate} 域的小时(hour)成分，当日期是一个范围时，它保存开始日期的小时成分。
%This field holds the hour component of the \bibfield{origdate} field. If the date is a range, it holds the hour component of the start date.

\fielditem{origminute}{datepart}

该域保存\bibfield{origdate} 域的分钟成分，当日期是一个范围时，它保存开始日期的分钟成分。
%This field holds the minute component of the \bibfield{origdate} field. If the date is a range, it holds the minute component of the start date.

\fielditem{origsecond}{datepart}

该域保存\bibfield{origdate} 域的秒钟成分，当日期是一个范围时，它保存开始日期的秒钟成分。
%This field holds the second component of the \bibfield{origdate} field. If the date is a range, it holds the second component of the start date.

\fielditem{origtimezone}{datepart}

该域保存\bibfield{origdate} 域的时区成分，当日期是一个范围时，它保存开始日期的时区成分。
%This field holds the timezone component of the \bibfield{origdate} field. If the date is a range, it holds the timezone component of the start date.

\fielditem{origday}{datepart}

该域保存\bibfield{origdate} 域的日成分，当日期是一个范围时，它保存开始日期的日成分。
%This field holds the day component of the \bibfield{origdate} field. If the date is a range, it holds the day component of the start date.

\fielditem{origmonth}{datepart}

该域保存\bibfield{origdate} 域的月成分，当日期是一个范围时，它保存开始日期的月成分。
%This field holds the month component of the \bibfield{origdate} field. If the date is a range, it holds the month component of the start date.

\fielditem{origyear}{datepart}

该域保存\bibfield{origdate} 域的年成分，当日期是一个范围时，它保存开始日期的年成分。
%This field holds the year component of the \bibfield{origdate} field. If the date is a range, it holds the year component of the start date.

\fielditem{origseason}{datepart}

该域保存由\acr{ISO8601-2} 4.7(见\secref{bib:use:dat})规定的\bibfield{origdate} 域的季节成分，它包含一个季节本地化字符串。当日期是一个范围时，它保存开始日期的季节成分。
%This field holds the season component of the \bibfield{origdate} field as specified by \acr{ISO8601-2} 4.7 (\secref{bib:use:dat}). It contains a season localisation string (\secref{aut:lng:key:dt}). If the date is a range, it holds the season component of the start date.

\fielditem{origendhour}{datepart}

如果\bibfield{origdate} 域中给出的日期是一个范围，该域保存结束日期的小时成分。
%If the date specification in the \bibfield{origdate} field is a range, this field holds the hour component of the end date.

\fielditem{origendminute}{datepart}

如果\bibfield{origdate} 域中给出的日期是一个范围，该域保存结束日期的分钟成分。
%If the date specification in the \bibfield{origdate} field is a range, this field holds the minute component of the end date.

\fielditem{origendsecond}{datepart}

如果\bibfield{origdate} 域中给出的日期是一个范围，该域保存结束日期的秒钟成分。
%If the date specification in the \bibfield{origdate} field is a range, this field holds the second component of the end date.

\fielditem{origendtimezone}{datepart}

如果\bibfield{origdate} 域中给出的日期是一个范围，该域保存结束日期的时区成分。
%If the date specification in the \bibfield{origdate} field is a range, this field holds the timezone component of the end date.

\fielditem{origendday}{datepart}

如果\bibfield{origdate} 域中给出的日期是一个范围，该域保存结束日期的日成分。
%If the date specification in the \bibfield{origdate} field is a range, this field holds the day component of the end date.

\fielditem{origendmonth}{datepart}

如果\bibfield{origdate} 域中给出的日期是一个范围，该域保存结束日期的月成分。
%If the date specification in the \bibfield{origdate} field is a range, this field holds the month component of the end date.

\fielditem{origendyear}{datepart}

如果\bibfield{origdate} 域中给出的日期是一个范围，该域保存结束日期的年成分。空的(但已定义)的\bibfield{origendyear} 成分表示无期限的日期范围。
%If the date specification in the \bibfield{origdate} field is a range, this field holds the year component of the end date. A blank (but defined) \bibfield{origendyear} component indicates an open ended \bibfield{origdate} range.

\fielditem{origendseason}{datepart}

如果\bibfield{origdate} 域中给出的日期是一个范围，该域保存\acr{EDTF} 5.2.5 (\secref{bib:use:dat})规定的结束日期的季节成分。它包含一个季节本地化字符串(见\secref{aut:lng:key:dt})，空的(但已定义)的\bibfield{origendseason} 成分表示无期限的\bibfield{origdate} 范围。
If the date specification in the \bibfield{origdate} field is a range, this field holds the season component of the end date as specified by \acr{ISO8601-2} 4.7 (\secref{bib:use:dat}). It contains a season localisation string (\secref{aut:lng:key:dt}). A blank (but defined) \bibfield{origendseason} component indicates an open ended \bibfield{origdate} range.

\fielditem{eventhour}{datepart}

该域保存\bibfield{eventdate} 域的小时(hour)成分，当日期是一个范围时，它保存开始日期的小时成分。
%This field holds the hour component of the \bibfield{eventdate} field. If the date is a range, it holds the hour component of the start date.

\fielditem{eventminute}{datepart}

该域保存\bibfield{eventdate} 域的分钟成分，当日期是一个范围时，它保存开始日期的分钟成分。
%This field holds the minute component of the \bibfield{eventdate} field. If the date is a range, it holds the minute component of the start date.

\fielditem{eventsecond}{datepart}

该域保存\bibfield{eventdate} 域的秒钟成分，当日期是一个范围时，它保存开始日期的秒钟成分。
%This field holds the second component of the \bibfield{eventdate} field. If the date is a range, it holds the second component of the start date.

\fielditem{eventtimezone}{datepart}

该域保存\bibfield{eventdate} 域的时区成分，当日期是一个范围时，它保存开始日期的时区成分。
%This field holds the timezone component of the \bibfield{eventdate} field. If the date is a range, it holds the timezone component of the start date.

\fielditem{eventday}{datepart}

该域保存\bibfield{eventdate} 域的日成分，当日期是一个范围时，它保存开始日期的日成分。
%This field holds the day component of the \bibfield{eventdate} field. If the date is a range, it holds the day component of the start date.

\fielditem{eventmonth}{datepart}

该域保存\bibfield{eventdate} 域的月成分，当日期是一个范围时，它保存开始日期的月成分。
%This field holds the month component of the \bibfield{eventdate} field. If the date is a range, it holds the month component of the start date.

\fielditem{eventyear}{datepart}

该域保存\bibfield{eventdate} 域的年成分，当日期是一个范围时，它保存开始日期的年成分
%This field holds the year component of the \bibfield{eventdate} field. If the date is a range, it holds the year component of the start date.

\fielditem{eventseason}{datepart}

该域保存由\acr{ISO8601-2} 4.7(见\secref{bib:use:dat})规定的\bibfield{eventdate} 域的季节成分，它包含一个季节本地化字符串。当日期是一个范围时，它保存开始日期的季节成分。
%This field holds the season component of the \bibfield{eventdate} field as specified by \acr{ISO8601-2} 4.7 (\secref{bib:use:dat}). It contains a season localisation string (\secref{aut:lng:key:dt}). If the date is a range, it holds the season component of the start date.

\fielditem{eventendhour}{datepart}

如果\bibfield{eventdate} 域中给出的日期是一个范围，该域保存结束日期的小时成分。
%If the date specification in the \bibfield{eventdate} field is a range, this field holds the hour component of the end date.

\fielditem{eventendminute}{datepart}

如果\bibfield{eventdate} 域中给出的日期是一个范围，该域保存结束日期的分钟成分。
%If the date specification in the \bibfield{eventdate} field is a range, this field holds the minute component of the end date.

\fielditem{eventendsecond}{datepart}

如果\bibfield{eventdate} 域中给出的日期是一个范围，该域保存结束日期的秒钟成分。
%If the date specification in the \bibfield{eventdate} field is a range, this field holds the second component of the end date.

\fielditem{eventendtimezone}{datepart}

如果\bibfield{eventdate} 域中给出的日期是一个范围，该域保存结束日期的时区成分。
%If the date specification in the \bibfield{eventdate} field is a range, this field holds the timezone component of the end date.

\fielditem{eventendday}{datepart}

如果\bibfield{eventdate} 域中给出的日期是一个范围，该域保存结束日期的日成分。
%If the date specification in the \bibfield{eventdate} field is a range, this field holds the day component of the end date.

\fielditem{eventendmonth}{datepart}

如果\bibfield{eventdate} 域中给出的日期是一个范围，该域保存结束日期的月成分。
%If the date specification in the \bibfield{eventdate} field is a range, this field holds the month component of the end date.

\fielditem{eventendyear}{datepart}

如果\bibfield{eventdate} 域中给出的日期是一个范围，该域保存结束日期的年成分。空的(但已定义)的\bibfield{eventendyear} 成分表示无期限的日期范围。
%If the date specification in the \bibfield{eventdate} field is a range, this field holds the year component of the end date. A blank (but defined) \bibfield{eventendyear} component indicates an open ended \bibfield{eventdate} range.

\fielditem{eventendseason}{datepart}

如果\bibfield{eventdate} 域中给出的日期是一个范围，该域保存\acr{EDTF} 5.2.5 (\secref{bib:use:dat})规定的结束日期的季节成分。它包含一个季节本地化字符串(见\secref{aut:lng:key:dt})，空的(但已定义)的\bibfield{eventendseason} 成分表示无期限的\bibfield{eventdate} 范围。
If the date specification in the \bibfield{eventdate} field is a range, this field holds the season component of the end date as specified by \acr{ISO8601-2} 4.7 (\secref{bib:use:dat}). It contains a season localisation string (\secref{aut:lng:key:dt}). A blank (but defined) \bibfield{eventendseason} component indicates an open ended \bibfield{eventdate} range.


\fielditem{urlhour}{datepart}

该域保存\bibfield{urldate} 域的小时(hour)成分，当日期是一个范围时，它保存开始日期的小时成分。
%This field holds the hour component of the \bibfield{urldate} field. If the date is a range, it holds the hour component of the start date.

\fielditem{urlminute}{datepart}

该域保存\bibfield{urldate} 域的分钟成分，当日期是一个范围时，它保存开始日期的分钟成分。
%This field holds the minute component of the \bibfield{urldate} field. If the date is a range, it holds the minute component of the start date.

\fielditem{urlsecond}{datepart}

该域保存\bibfield{urldate} 域的秒钟成分，当日期是一个范围时，它保存开始日期的秒钟成分。
%This field holds the second component of the \bibfield{urldate} field. If the date is a range, it holds the second component of the start date.

\fielditem{timezone}{urldatepart}

该域保存\bibfield{urldate} 域的时区成分，当日期是一个范围时，它保存开始日期的时区成分。
%This field holds the timezone component of the \bibfield{urldate} field. If the date is a range, it holds the timezone component of the start date.

\fielditem{urlday}{datepart}

该域保存\bibfield{urldate} 域的日成分。
%This field holds the day component of the \bibfield{urldate} field.

\fielditem{urlmonth}{datepart}

该域保存\bibfield{urldate} 域的月成分。
%This field holds the month component of the \bibfield{urldate} field.

\fielditem{urlyear}{datepart}

该域保存\bibfield{urldate} 域的年成分。
%This field holds the year component of the \bibfield{urldate} field.

\fielditem{urlseason}{datepart}

该域保存由\acr{ISO8601-2} 4.7(见\secref{bib:use:dat})规定的 \bibfield{urldate} 域的季节成分，它包含一个季节本地化字符串。当日期是一个范围时，它保存开始日期的季节成分。
%This field holds the season component of the \bibfield{urldate} field as specified by \acr{ISO8601-2} 4.7 (\secref{bib:use:dat}). It contains a season localisation string (\secref{aut:lng:key:dt}). If the date is a range, it holds the season component of the start date.

\fielditem{urlendhour}{datepart}

如果\bibfield{urldate} 域中给出的日期是一个范围，该域保存结束日期的小时成分
%If the date specification in the \bibfield{urldate} field is a range, this field holds the hour component of the end date.

\fielditem{urlendminute}{datepart}

如果\bibfield{urldate} 域中给出的日期是一个范围，该域保存结束日期的分钟成分
%If the date specification in the \bibfield{urldate} field is a range, this field holds the minute component of the end date.

\fielditem{urlendsecond}{datepart}

如果\bibfield{urldate} 域中给出的日期是一个范围，该域保存结束日期的秒钟成分
%If the date specification in the \bibfield{urldate} field is a range, this field holds the second component of the end date.

\fielditem{urlendtimezone}{datepart}

如果\bibfield{urldate} 域中给出的日期是一个范围，该域保存结束日期的时区成分
%If the date specification in the \bibfield{urldate} field is a range, this field holds the timezone component of the end date.

\fielditem{urlendday}{datepart}

如果\bibfield{urldate} 域中给出的日期是一个范围，该域保存结束日期的日成分
%If the date specification in the \bibfield{urldate} field is a range, this field holds the day component of the end date.

\fielditem{urlendmonth}{datepart}

如果\bibfield{urldate} 域中给出的日期是一个范围，该域保存结束日期的月成分
%If the date specification in the \bibfield{urldate} field is a range, this field holds the month component of the end date.

\fielditem{urlendyear}{datepart}

如果\bibfield{urldate} 域中给出的日期是一个范围，该域保存结束日期的年成分。空的(但已定义)的\bibfield{urlendyear} 成分表示无期限的日期范围。
%If the date specification in the \bibfield{urldate} field is a range, this field holds the year component of the end date. A blank (but defined) \bibfield{urlendyear} component indicates an open ended \bibfield{urldate} range.

\fielditem{urlendseason}{datepart}

如果\bibfield{urldate} 域中给出的日期是一个范围，该域保存\acr{EDTF} 5.2.5 (\secref{bib:use:dat})规定的结束日期的季节成分。它包含一个季节本地化字符串(见\secref{aut:lng:key:dt})，空的(但已定义)的\bibfield{urlendseason} 成分表示无期限的\bibfield{eventdate} 范围。
If the date specification in the \bibfield{urldate} field is a range, this field holds the season component of the end date as specified by \acr{ISO8601-2} 4.7 (\secref{bib:use:dat}). It contains a season localisation string (\secref{aut:lng:key:dt}). A blank (but defined) \bibfield{urlendseason} component indicates an open ended \bibfield{urldate} range.


\end{fieldlist}

\subsection{标注样式}%Citation Styles
\label{aut:cbx}
\gls{参考文献标注样式} 是诸如\cmd{cite} 等用于打印不同类型标注的命令集。这些样式定义在后缀为\file{cbx} 的文件中。\biblatex 在包末尾加载它们。注意:一些标准标注样式的常用共享宏集放在\path{biblatex.def} 文件中。这一文件也在包末尾加载，先于选择的标注样式。它也包含有来自\secref{use:cit:txt} 节的命令的定义。
%A citation style is a set of commands such as \cmd{cite} which print different types of citations. Such styles are defined in files with the suffix \file{cbx}. The \biblatex package loads the selected citation style file at the end of the package. Note that a small repertory of frequently used macros shared by several of the standard citation styles is also included in \path{biblatex.def}. This file is loaded at the end of the package as well, prior to the selected citation style. It also contains the definitions of the commands from \secref{use:cit:txt}.

\subsubsection{标注样式文件}% Citation Style Files
\label{aut:cbx:cbx}
在讨论标注样式文件提供的各个命令前，观察如下一个典型\file{cbx} 文件的总体结构:
%Before we go over the individual commands available in citation style files, consider this example of the overall structure of a typical \file{cbx} file:

\begin{ltxexample}
\ProvidesFile{example.cbx}[2006/03/15 v1.0 biblatex citation style]

\DeclareCiteCommand{\cite}{...}{...}{...}{...}
\DeclareCiteCommand{\parencite}[\mkbibparens]{...}{...}{...}{...}
\DeclareCiteCommand{\footcite}[\mkbibfootnote]{...}{...}{...}{...}
\DeclareCiteCommand{\textcite}{...}{...}{...}{...}
\endinput
\end{ltxexample}

\begin{ltxsyntax}

\cmditem{RequireCitationStyle}{style}

这个命令是可选的，用于加载在一些更一般样式基础上构建特殊的标注样式。它加载标注样式\path{style.cbx}。
%This command is optional and intended for specialized citation styles built on top of a more generic style. It loads the citation style \path{style.cbx}.

\cmditem{InitializeCitationStyle}{code}

指定初始化或重设标注样式需要的任意\prm{code}。这个钩子将在包加载的时候执行一次，在使用\secref{use:cit:msc} 节的\cmd{citereset} 命令时则每次都执行。\cmd{citereset} 命令也将重设本宏包的内部标注追踪器。它会影响\secref{aut:aux:tst} 节中列出的\cmd{ifciteseen}, \cmd{ifentryseen}, \cmd{ifciteibid} 和\cmd{ifciteidem} 等判断。当使用\env{refsection} 环境时，标注追踪器重设的是当前的\env{refsection} 局部环境。
%Specifies arbitrary \prm{code} required to initialize or reset the citation style. This hook will be executed once at package load-time and every time the \cmd{citereset} command from \secref{use:cit:msc} is used. The \cmd{citereset} command also resets the internal citation trackers of this package. The reset will affect the \cmd{ifciteseen}, \cmd{ifentryseen}, \cmd{ifciteibid}, and \cmd{ifciteidem} tests discussed in \secref{aut:aux:tst}. When used in a \env{refsection} environment, the reset of the citation tracker is local to the current \env{refsection} environment.

\cmditem{OnManualCitation}{code}
指定重设部分标注样式需要的任意\prm{code}。这一钩子将在使用\secref{use:cit:msc} 中的\cmd{mancite} 命令时调用。它有时特别有用，可以代替像 <ibidem>或<op. cit.>等缩写表示的重复标注，因为当自动生成和人工产生的标注混合使用的时候这些缩写可能会有歧义。\cmd{mancite} 命令也会重设宏包的内部<ibidem>和<idem>追踪器，进而影响\secref{aut:aux:tst} 节讨论的\cmd{ifciteibid} 和\cmd{ifciteidem} 判断。
%Specifies arbitrary \prm{code} required for a partial reset of the citation style. This hook will be executed every time the \cmd{mancite} command from \secref{use:cit:msc} is used. It is particularly useful in citation styles which replace repeated citations by abbreviations like <ibidem> or <op. cit.> which may get ambiguous if automatically generated and manual citations are mixed. The \cmd{mancite} command also resets the internal <ibidem> and <idem> trackers of this package. The reset will affect the \cmd{ifciteibid} and \cmd{ifciteidem} tests discussed in \secref{aut:aux:tst}.

\cmditem{DeclareCiteCommand}{command}[wrapper]{precode}{loopcode}{sepcode}{postcode} \cmditem*{DeclareCiteCommand*}{command}[wrapper]{precode}{loopcode}{sepcode}{postcode}

%This is the core command used to define all citation commands. It takes one optional and five mandatory arguments. The \prm{command} is the command to be defined, for example \cmd{cite}. If the optional \prm{wrapper} argument is given, the entire citation will be passed to the \prm{wrapper} as an argument, \ie the wrapper command must take one mandatory argument.\footnote{Typical examples of wrapper commands are \cmd{mkbibparens} and \cmd{mkbibfootnote}.} The \prm{precode} is arbitrary code to be executed at the beginning of the citation. It will typically handle the \prm{prenote} argument which is available in the \bibfield{prenote} field. It may also be used to initialize macros required by the \prm{loopcode}. The \prm{loopcode} is arbitrary code to be executed for each entry key passed to the \prm{command}. This is the core code which prints the citation labels or any other data. The \prm{sepcode} is arbitrary code to be executed after each iteration of the \prm{loopcode}. It will only be executed if a list of entry keys is passed to the \prm{command}. The \prm{sepcode} will usually insert some kind of separator, such as a comma or a semicolon. The \prm{postcode} is arbitrary code to be executed at the end of the citation. The \prm{postcode} will typically handle the \prm{postnote} argument which is available in the \bibfield{postnote} field.\footnote{The bibliographic data available to the \prm{loopcode} is the data of the entry currently being processed. In addition to that, the data of the first entry is available to the \prm{precode} and the data of the last one is available to the \prm{postcode}. <First> and <last> refer to the order in which the citations are printed. If the \opt{sortcites} package option is active, this is the order of the list after sorting. Note that no bibliographic data is available to the \prm{sepcode}.} The starred variant of \cmd{DeclareCiteCommand} defines a starred \prm{command}. For example, |\DeclareCiteCommand*{cite}| would define |\cite*|.\footnote{Note that the regular variant of \cmd{DeclareCiteCommand} defines a starred version of the \prm{command} implicitly, unless the starred version has been defined before. This is intended as a fallback. The implicit definition is an alias for the regular variant.}

这是用于定义所有标注(引用)命令的核心命令。它有1个可选参数和5个必选参数。\prm{command} 是要定义的命令，比如\cmd{cite}。如果给出可选的\prm{wrapper} 参数，整个标注将会作为一个参数传递给\prm{wrapper}，即包围(wrapper)命令必须要取得一个必选参数。\footnote{典型的包围命令是\cmd{mkbibparens} 和\cmd{mkbibfootnote}。}
\prm{precode} 是在标注开始时执行的任意代码。典型地，它将处理由\bibfield{prenote} 域提供的\prm{prenote} 参数。它可以可用来对\prm{loopcode} 所需的宏进行初始化。\prm{loopcode} 是每个条目关键词传递给\prm{command} 命令时执行的任意代码。它是打印标注标签或其它任意数据的核心代码。\prm{sepcode} 是每次执行\prm{loopcode} 完成后执行的代码。它仅在条目关键词列表传递给\prm{command} 时起作用。\prm{sepcode} 常用于插入一些分隔符，比如逗号或分号等。
\prm{postcode} 是在标注结束时执行的代码。典型地，它将处理由\bibfield{postnote} 域提供的\prm{postnote} 参数。\footnote{能给\prm{loopcode} 提供的参考文献数据是正在处理的条目数据。此外，第一个(<First>)条目的数据可以用于\prm{precode}，最后一个(<last>)条目的数据可以用于\prm{postcode}。<First> and <last> 指的是标注的打印顺序。如果\opt{sortcites} 包选项启用，这是经过排序处理后的顺序。注意: 任何参考文献数据无法用于\prm{sepcode}。}
带星号的\cmd{DeclareCiteCommand} 命令定义了一个带星号的\prm{command}。例如|\DeclareCiteCommand*{cite}|命令将定义|\cite*|。
\footnote{注意:无星号的\cmd{DeclareCiteCommand} 命令也将定义隐式的定义一个带星号的标注命令，除非该标注命令前面已经定义。这只是用于提供备选。这种隐式方式定义的命令将等同于不带星号的命令。}



\cmditem{DeclareMultiCiteCommand}{command}[wrapper]{cite}{delimiter}

该命令定义<multicite>类命令(见\secref{use:cit:mlt})。\prm{command} 是要定义的multicite命令，比如\cmd{cites}。它自动在由\cmd{DeclareCiteCommand} 定义的后端命令基础上构建鲁棒的命令，其中\prm{cite} 参数用于指定使用的后端命令名。注意后端命令的包围命令(封套)(即传递给\cmd{DeclareCiteCommand} 命令的\prm{wrapper} 参数)自动忽略。使用可选的\prm{wrapper} 参数作为替换。\prm{delimiter} 是列表中单个标注之间的分隔字符串。下面给出的示例是典型的\cmd{multicitedelim} 命令，取自\path{biblatex.def} 中的真实定义:
%This command defines <multicite> commands (\secref{use:cit:mlt}). The \prm{command} is the multicite command to be defined, for example \cmd{cites}. It is automatically made robust. Multicite commands are built on top of backend commands defined with \cmd{DeclareCiteCommand} and the \prm{cite} argument specifies the name of the backend command to be used. Note that the wrapper of the backend command (\ie the \prm{wrapper} argument passed to \cmd{DeclareCiteCommand}) is ignored. Use the optional \prm{wrapper} argument to specify an alternative wrapper. The \prm{delimiter} is the string to be printed as a separator between the individual citations in the list. This will typically be \cmd{multicitedelim}. The following examples are real definitions taken from \path{biblatex.def}:

\begin{ltxexample}
\DeclareMultiCiteCommand{\cites}%
	{\cite}{\multicitedelim}
\DeclareMultiCiteCommand{\parencites}[\mkbibparens]%
	{\parencite}{\multicitedelim}
\DeclareMultiCiteCommand{\footcites}[\mkbibfootnote]%
	{\footcite}{\multicitedelim}
\end{ltxexample}

\cmditem{DeclareAutoCiteCommand}{name}[position]{cite}{multicite}

%This command provides definitions for the \cmd{autocite} and \cmd{autocites} commands from \secref{use:cit:aut}. The definitions are enabled with the \opt{autocite} package option from \secref{use:opt:pre:gen}. The \prm{name} is an identifier which serves as the value passed to the package option. The autocite commands are built on top of backend commands like \cmd{parencite} and \cmd{parencites}. The arguments \prm{cite} and \prm{multicite} specify the backend commands to use. The \prm{cite} argument refers to \cmd{autocite} and \prm{multicite} refers to \cmd{autocites}. The \prm{position} argument controls the handling of any punctuation marks after the citation. Possible values are \texttt{l}, \texttt{r}, \texttt{f}. \texttt{r} means that the punctuation is placed to the right of the citation, \ie it will not be moved around. \texttt{l} means that any punctuation after the citation is moved to the left of the citation. \texttt{f} is like \texttt{r} in a footnote and like \texttt{l} otherwise. This argument is optional and defaults to \texttt{r}. See also \cmd{DeclareAutoPunctuation} in \secref{aut:pct:cfg} and the \opt{autopunct} package option in \secref{use:opt:pre:gen}. The following examples are real definitions taken from \path{biblatex.def}:
该命令为\cmd{autocite} 和\cmd{autocites} 类命令提供定义(见\secref{use:cit:aut})。要使定义生效需要启用 \secref{use:opt:pre:gen} 节的\opt{autocite} 包选项。\prm{name} 是一个标识向包选项传递一个值。autocite类命令是在\cmd{parencite} 和\cmd{parencites} 等后端命令基础上构建的。\prm{cite} 和\prm{multicite} 参数指定了使用的后端命令。\prm{cite} 参数用于\cmd{autocite}，而\prm{multicite} 用于\cmd{autocites}。
\prm{position} 参数控制标注后的任何标点符号的处理。可能的值是\texttt{l}, \texttt{r}, \texttt{f}。\texttt{r} 表示标点置于标注的右侧，即它不会移动。 \texttt{l} 表示将标点移动到标注的左侧。\texttt{f} 在脚注中的作用类似于\texttt{r}，在其它情况下则类似于\texttt{l}。该参数是可选的，默认是\texttt{r}。另可参见\secref{aut:pct:cfg} 节的\cmd{DeclareAutoPunctuation} 命令和\secref{use:opt:pre:gen} 节的\opt{autopunct} 包选项。下面的示例取自\path{biblatex.def} 中的真实定义:



\begin{ltxexample}
\DeclareAutoCiteCommand{plain}{\cite}{\cites}
\DeclareAutoCiteCommand{inline}{\parencite}{\parencites}
\DeclareAutoCiteCommand{footnote}[l]{\footcite}{\footcites}
\DeclareAutoCiteCommand{footnote}[f]{\smartcite}{\smartcites}
\end{ltxexample}
%
文档导言区提供的定义可以利用如下方式随后采用(见\secref{use:cfg:opt}):
%A definition provided in the document preamble can be subsequently adopted with the following: (see \secref{use:cfg:opt}).

\begin{ltxexample}
\ExecuteBibliographyOptions{autocite=<<name>>}
\end{ltxexample}

\cmditem{DeclareCitePunctuationPosition}{command}{position}

%Set up the cite command \prm{command} to move punctuation marks after the citation like \cmd{autocite}. The \prm{position} argument can take the values \opt{r}, \opt{l}, \opt{f}, \opt{c}, \opt{o} and \opt{d}.
%If an unknown \prm{position} identifier is used, it defaults to \opt{o}.

设置命令\prm{command}实现类似\cmd{autocite}的标点移动。
位置(\prm{position})参数的值包括 \opt{r}, \opt{l}, \opt{f}, \opt{c}, \opt{o} and \opt{d}。
当给出的位置标识不在这些值中，则默认设置为\opt{o}。

\begin{valuelist}
\item[r] %The punctuation mark is not moved and remains to the right of the citation.
移动标点符号，保留在标注的右侧。

\item[l] %The punctuation mark is moved to the left of the citation and thus appears before it.
移动标点符号到标注的左侧，即在标注之前显示。

\item[f] %Like \opt{r} in footnotes and like \opt{l} otherwise.
在脚注中同\opt{r}，否则同\opt{l}。

\item[c] %Pass the punctuation on to the internal implementation of the citation commands. It will then be executed within the \prm{wrapper} command if given.
传递标点进入标注命令内部，将在标注命令内部的\prm{wrapper}命令中执行。


\item[o] %Retain the default set-up of \opt{c} for citation defined commands without \prm{wrapper} command and \opt{l} for citation commands defined with a \prm{wrapper} command.
当标注命令中不存在\prm{wrapper}时，与\opt{c}默认设置相同。
当标注命令中存在\prm{wrapper}命令，则与\opt{l}默认设置相同。


\item[d] %Drop the explicit punctuation mark. It will only be available as the field \bibfield{postpunct}.
丢弃显式的标点符号，标点符号仅由域\bibfield{postpunct}提供。

\end{valuelist}
%
This command can not be used for \cmd{autocite}, to configure \cmd{autocite} use the optional \prm{position} argument for \cmd{DeclareAutoCiteCommand}.
\end{ltxsyntax}

\subsubsection{特殊域}%Special Fields
\label{aut:cbx:fld}

下面的域用于向标注命令传递数据。它们不\file{bib} 文件中使用而由宏包自动定义。从标注样式的角度看，它们与\file{bib} 中的域并无区别。另可参见\secref{aut:bbx:fld}。
%The following fields are used by \biblatex to pass data to citation commands. They are not used in \file{bib} files but defined automatically by the package. From the perspective of a citation style, they are not different from the fields in a \file{bib} file. See also \secref{aut:bbx:fld}.

\begin{fieldlist}

\fielditem{prenote}{literal}

作为\prm{prenote} 参数向标注命令传递。该域仅用于标注而不能用在参考文献表中。如果\prm{prenote} 参数缺省或为空，该域不定义。
%The \prm{prenote} argument passed to a citation command. This field is specific to citations and not available in the bibliography. If the \prm{prenote} argument is missing or empty, this field is undefined.

\fielditem{postnote}{literal}

作为\prm{postnote} 参数向标注命令传递。该域仅用于标注而不能用在参考文献表中。如果\prm{postnote} 参数缺省或为空，该域不定义。
%The \prm{postnote} argument passed to a citation command. This field is specific to citations and not available in the bibliography. If the \prm{postnote} argument is missing or empty, this field is undefined.

\fielditem{multiprenote}{literal}

作为\prm{multiprenote} 参数向multicite类标注命令传递。该域仅用于标注而不能用在参考文献表中。如果\prm{multiprenote} 参数缺省或为空，该域不定义。
%The \prm{multiprenote} argument passed to a multicite command. This field is specific to citations and not available in the bibliography. If the \prm{multiprenote} argument is missing or empty, this field is undefined.

\fielditem{multipostnote}{literal}

作为\prm{multipostnote} 参数向ulticite类标注命令传递。该域仅用于标注而不能用在参考文献表中。如果\prm{multipostnote} 参数缺省或为空，该域不定义。
%The \prm{multipostnote} argument passed to a multicite command. This field is specific to citations and not available in the bibliography. If the \prm{multipostnote} argument is missing or empty, this field is undefined.

\fielditem{volcitevolume}{literal}

The \prm{volume} argument passed to \cmd{volcite} or a related citation command (\secref{use:cit:spc}). This field is specific to \cmd{volcite} citations and not available in the bibliography or other citations.

\fielditem{volcitepages}{literal}

The \prm{pages} argument passed to \cmd{volcite} or a related citation command (\secref{use:cit:spc}). This field is specific to \cmd{volcite} citations and not available in the bibliography or other citations. If the \prm{pages} argument is missing or empty, this field is undefined.
\fielditem{postpunct}{punctuation command}

作为拖尾的标点参数隐式地向标注命令传递。该域仅用于标注而不能用在参考文献表中。如果一个标注命令后面跟着的字符不在\cmd{DeclareAutoPunctuation} (\secref{aut:pct:cfg})命令的定义中，该域不定义。
%The trailing punctuation argument implicitly passed to a citation command. This field is specific to citations and not available in the bibliography. If the character following a given citation command is not specified in \cmd{DeclareAutoPunctuation} (\secref{aut:pct:cfg}), this field is undefined.

\end{fieldlist}

\subsection{数据接口}%Data Interface
\label{aut:bib}

数据接口是用于格式化和打印全部参考文献数据的工具。这些工具在著录和标注样式中均可使用。
%The data interface are the facilities used to format and print all bibliographic data. These facilities are available in both bibliography and citation styles.

\subsubsection{数据命令}%Data Commands
\label{aut:bib:dat}
本节介绍\biblatex 包的主要数据接口。这些命令处理了绝大部分工作，即实际上由它们来对列表和域提供的数据进行打印。
%This section introduces the main data interface of the \biblatex package. These are the commands doing most of the work, \ie they actually print the data provided in lists and fields.

\begin{ltxsyntax}

\cmditem{DeprecateField}{field}{message}
\cmditem{DeprecateList}{list}{message}
\cmditem{DeprecateName}{name}{message}

用于在打印\prm{field}, \prm{list}, \prm{name} 时给出表示不允许的警告信息\prm{message}。它能为那些需要在样式中修改域名的样式作者提供帮助。注意: 不允许的项只能是未在当前工作的数据模型中定义的项，\prm{field}, \prm{list} 或\prm{name} 不能出现在\cmd{DeclareDatamodelFields} 命令的参数中。
%When an attempt is made to print \prm{field}, \prm{list}, \prm{name}, a
%deprecation warning is issued with the additional \prm{message}.  This aids
%style authors who are changing field names in their style. Note that the
%deprecated item must no longer be defined in the datamodel for this work;
%\prm{field}, \prm{list} or \prm{name} cannot be listed anywhere as an
%argument to \cmd{DeclareDatamodelFields}.

\cmditem{DeprecateFieldWithReplacement}{field}{replacement}
\cmditem{DeprecateListWithReplacement}{list}{replacement}
\cmditem{DeprecateNameWithReplacement}{name}{replacement}

类似于\cmd{DeprecateField}, \cmd{DeprecateList} and \cmd{DeprecateName}.
这些命令不经能给出一个不允许的警告，还尝试定义用于代替不允许域输出的替代域。
\cmd{replacement}必须与不允许的\prm{field}, \prm{list} or \prm{name}域保持类型一致。
当打印不允许的域时需要应用\prm{replacement}的格式，那么需要由\cmd{DeclareFieldAlias}
给出请求(见\secref{aut:bib:fmt})。
注意:不允许的域必须是未在数据模型中定义的，即\prm{field}, \prm{list} or \prm{name}不能
出现在\cmd{DeclareDatamodelFields}的任意参数中。
%Similar to \cmd{DeprecateField}, \cmd{DeprecateList} and \cmd{DeprecateName}.
%The commands do not only issue a deprecation warning,
%they try to define a replacement for the deprecated field
%that is printed in its stead.
%The \cmd{replacement} must be of the same type as the deprecated
%\prm{field}, \prm{list} or \prm{name}.
%If the formatting of \prm{replacement} should be applied when printing
%the deprecated field, that needs to be requested with \cmd{DeclareFieldAlias}
%(see \secref{aut:bib:fmt}).
%Note that the deprecated item must no longer be defined in the datamodel
%for this work; \prm{field}, \prm{list} or \prm{name} cannot be listed
%anywhere as an argument to \cmd{DeclareDatamodelFields}.
\cmditem{printfield}[format]{field}

%This command prints a \prm{field} using the formatting directive \prm{format}, as defined with \cmd{DeclareFieldFormat}. If a type"=specific \prm{format} has been declared, the type"=specific formatting directive takes precedence over the generic one. If the \prm{field} is undefined, nothing is printed. If the \prm{format} is omitted, \cmd{printfield} tries using the name of the field as a format name. For example, if the \bibfield{title} field is to be printed and the \prm{format} is not specified, it will try to use the field format \texttt{title}.\footnote{In other words, \texttt{\textbackslash printfield\{title\}} is equivalent to \texttt{\textbackslash printfield[title]\{title\}}.} In this case, any type"=specific formatting directive will also take precedence over the generic one. If all of these formats are undefined, it falls back to \texttt{default} as a last resort. Note that \cmd{printfield} provides the name of the field currently being processed in \cmd{currentfield} for use in field formatting directives.
该命令使用由\cmd{DeclareFieldFormat} 定义的格式化指令\prm{format} 打印\prm{field}。如果声明了具体条目类型(type-specific)的格式指令，那么它将优先于设置的通用格式化指令。如果\prm{field} 未定义则不作打印。如果\prm{format} 缺省，\cmd{printfield} 将尝试使用以域名为指令名的格式化指令。例如:要打印\bibfield{title} 域，且\prm{format} 未指定，它将尝试使用域格式化指令\texttt{title}。\footnote{换句话说，\texttt{\textbackslash printfield\{title\}} 等价于\texttt{\textbackslash printfield[title]\{title\}}。}
这种情况下，任何具体类型的格式化指令将优先于通用指令。如果所有的这些格式都未定义，它将回退到\texttt{default} 作为最后的选择。注意: \cmd{printfield} 为格式化指令提供当前正在\cmd{currentfield} 中处理的域名。



\cmditem{printlist}[format][start\ensuremath\rangle--\ensuremath\langle stop]{literal list}

该命令对所有在\prm{literal list} 中的项进行循环处理，从项数\prm{start} 开始，到项数\prm{stop} 结束，包括\prm{start} 和\prm{stop}(所有的列表中项以1开始计数)。每一项都用由\cmd{DeclareListFormat} 定义的格式化指令\prm{format} 打印。如果声明了具体条目类型的格式指令，其将优先于设置的通用格式指令。如果\prm{literal list} 未定义则不作打印。如果\prm{format} 缺省，\cmd{printlist} 将尝试使用以列表名作为化指令名的格式化指令。这种情况下，任何具体类型的格式化指令将优先于通用指令采用。如果所有的这些格式都未定义，它将回退到\texttt{default} 作为最后的选择。\prm{start} 参数默认是1，\prm{stop} 默认是列表中项的总数。如果项的总数大于\prm{maxitems}，\prm{stop} 默认为\prm{minitems}(见\secref{use:opt:pre:gen})。更多细节参见\cmd{printnames}。注意: \cmd{printlist} 为格式化指令提供当前正在\cmd{currentlist} 中处理的域名。
%This command loops over all items in a \prm{literal list}, starting at item number \prm{start} and stopping at item number \prm{stop}, including \prm{start} and \prm{stop} (all lists are numbered starting at~1). Each item is printed using the formatting directive \prm{format}, as defined with \cmd{DeclareListFormat}. If a type"=specific \prm{format} has been declared, the type"=specific formatting directive takes precedence over the generic one. If the \prm{literal list} is undefined, nothing is printed. If the \prm{format} is omitted, \cmd{printlist} tries using the name of the list as a format name. In this case, any type"=specific formatting directive will also take precedence over the generic one. If all of these formats are undefined, it falls back to \texttt{default} as a last resort. The \prm{start} argument defaults to 1; \prm{stop} defaults to the total number of items in the list. If the total number is greater than \prm{maxitems}, \prm{stop} defaults to \prm{minitems} (see \secref{use:opt:pre:gen}). See \cmd{printnames} for further details. Note that \cmd{printlist} provides the name of the literal list currently being processed in \cmd{currentlist} for use in list formatting directives.

\cmditem{printnames}[format][start\ensuremath\rangle--\ensuremath\langle stop]{name list}
该命令对所有在\prm{name list} 中的项进行循环处理，从项数\prm{start} 开始，到项数\prm{stop} 结束，包括\prm{start} 和\prm{stop}(所有的列表中项以1开始计数)。每一项都用由\cmd{DeclareNameFormat} 定义的格式化指令\prm{format} 打印。如果声明了具体条目类型的格式指令，其将优先于设置的通用格式指令。如果\prm{name list} 未定义则不作打印。如果\prm{format} 缺省， \cmd{printnames} 将尝试使用以列表名为指令名的格式化指令。这种情况下，任何具体类型的格式化指令将优先于通用指令采用。如果所有的这些格式都未定义，它将回退到\texttt{default} 作为最后的选择。\prm{start} 参数默认是1，\prm{stop} 默认是列表中项的总数。如果项的总数大于\prm{maxnames}，\prm{stop} 默认为\prm{minnames}(见\secref{use:opt:pre:gen})。如果你要自己制定一个范围而又要使用默认的列表格式，第一个可选参数必须给出但要留空:
%This command loops over all items in a \prm{name list}, starting at item number \prm{start} and stopping at item number \prm{stop}, including \prm{start} and \prm{stop} (all lists are numbered starting at~1). Each item is printed using the formatting directive \prm{format}, as defined with \cmd{DeclareNameFormat}. If a type"=specific \prm{format} has been declared, the type"=specific formatting directive takes precedence over the generic one. If the \prm{name list} is undefined, nothing is printed. If the \prm{format} is omitted, \cmd{printnames} tries using the name of the list as a format name. In this case, any type"=specific formatting directive will also take precedence over the generic one. If all of these formats are undefined, it falls back to \texttt{default} as a last resort. The \prm{start} argument defaults to 1; \prm{stop} defaults to the total number of items in the list. If the total number is greater than \prm{maxnames}, \prm{stop} defaults to \prm{minnames} (see \secref{use:opt:pre:gen}). If you want to select a range but use the default list format, the first optional argument must still be given, but is left empty:

\begin{ltxexample}
\printnames[][1-3]{...}
\end{ltxexample}

\prm{start} 和\prm{stop} 之一可以缺省，因此下面的参数都是有效的:
%One of \prm{start} and \prm{stop} may be omitted, hence the following arguments are all valid:

\begin{ltxexample}
\printnames[...][-1]{...}
\printnames[...][2-]{...}
\printnames[...][1-3]{...}
\end{ltxexample}

如果你要重设\prm{maxnames} 和\prm{minnames} 并打印整个列表，你可以在第二个可选参数中以如下方式设置\cnt{listtotal} 计数器。
%If you want to override \prm{maxnames} and \prm{minnames} and force printing of the entire list, you may refer to the \cnt{listtotal} counter in the second optional argument:

\begin{ltxexample}
\printnames[...][-\value{listtotal}]{...}
\end{ltxexample}

%Whenever \cmd{printnames} and \cmd{printlist} process a list, information concerning the current state is accessible by way of four counters: the \cnt{listtotal} counter holds the total number of items in the current list, \cnt{listcount} holds the number of the item currently being processed, \cnt{liststart} is the \prm{start} argument passed to \cmd{printnames} or \cmd{printlist}, \cnt{liststop} is the \prm{stop} argument. These counters are intended for use in list formatting directives. \cnt{listtotal} may also be used in the second optional argument to \cmd{printnames} and \cmd{printlist}. Note that these counters are local to list formatting directives and do not hold meaningful values when used anywhere else. For every list, there is also a counter by the same name which holds the total number of items in the corresponding list. For example, the \cnt{author} counter holds the total number of items in the \bibfield{author} list. These counters are similar to \cnt{listtotal} except that they may also be used independently of list formatting directives. There are also \cnt{maxnames} and \cnt{minnames} as well as \cnt{maxitems} and \cnt{minitems} counters which hold the values of the corresponding package options. See \secref{aut:fmt:ilc} for a complete list of such internal counters. Note that \cmd{printnames} provides the name of the name list currently being processed in \cmd{currentname} for use in name formatting directives.

当\cmd{printnames} 和\cmd{printlist} 处理一个列表时，当前状态的信息可以通过4个计数器获知: \cnt{listtotal} 计数器保存当前列表中项的总数，\cnt{listcount} 保存当前正在处理的项的序号，\cnt{liststart} 是传递给\cmd{printnames} 或\cmd{printlist} 命令的 \prm{start} 参数，\cnt{liststop} 则是 \prm{stop} 参数。这些计数器用于列表的格式化指令。\cnt{listtotal} 也可以在\cmd{printnames} 和\cmd{printlist} 命令第二个可选参数中使用。
注意，这些计数器仅在列表格式化指令中有意义在其它任何地方都无效。对于每类列表，都有一个具有相同名字的计数器保存该类列表的项的总数。例如，\cnt{author} 计数器保存\bibfield{author} 列表中的项的总数。这些计数器类似于\cnt{listtotal}，但可用于列表格式化指令之外。还有\cnt{maxnames} ，\cnt{minnames}， \cnt{maxitems} 和\cnt{minitems} 计数器，用于保存相应的包选项的值。这些内部计数器的完整列表详见\secref{aut:fmt:ilc}。注意: \cmd{printnames} 为格式化指令提供当前正在\cmd{currentname} 中处理的域名。



\cmditem{printtext}[format]{text}

该命令用于打印\prm{text}，可以是可打印的文本或者产生可打印文本的任意代码。它清除插入\prm{text} 之前的标点缓存并且通知\biblatex 打印文本已经插入。这保证了所有之前和之后的\cmd{newblock} 和\cmd{newunit} 命令能产生预期的作用。\cmd{printfield}、\cmd{printnames} 、\cmd{bibstring} 及其相关命令都这般自动处理(见\secref{aut:str})。如果一个参考文献样式需要插入抄录文本（包括来自\secref{aut:pct:pct, aut:pct:spc} 的命令），需要使用该命令来确保block 和unit标点在\secref{aut:pct:new} 节中所述功能正常运转。可选参数\prm{format} 指定一个域格式指令用于格式化\prm{text}。当需要把若干个域打印为某一格式的集合块，这就会很有用，比如把集合块用括号或引号包围起来。如果声明了具体条目类型的格式化指令，其将优先于设置的通用格式化指令。如果\prm{format} 缺省，那么\prm{text} 如实输出(原样打印)。更多实用细节见第\secref{aut:cav:pct} 节。
%This command prints \prm{text}, which may be printable text or arbitrary code generating printable text. It clears the punctuation buffer before inserting \prm{text} and informs \biblatex that printable text has been inserted. This ensures that all preceding and following \cmd{newblock} and \cmd{newunit} commands have the desired effect. \cmd{printfield} and \cmd{printnames} as well as \cmd{bibstring} and its companion commands (see \secref{aut:str}) do that automatically. Using this command is required if a bibliography styles inserts literal text (including the commands from \secref{aut:pct:pct, aut:pct:spc}) to ensure that block and unit punctuation works as advertised in \secref{aut:pct:new}. The optional \prm{format} argument specifies a field formatting directive to be used to format \prm{text}. This may also be useful when several fields are to be printed as one chunk, for example, by enclosing the entire chunk in parentheses or quotation marks. If a type"=specific \prm{format} has been declared, the type"=specific formatting directive takes precedence over the generic one. If the \prm{format} is omitted, the \prm{text} is printed as is. See also \secref{aut:cav:pct} for some practical hints.

\cmditem{printfile}[format]{file}

该命令类似于\cmd{printtext}，差别在于第二个参数是一个文件名而不是抄录文本。\prm{file} 参数必须是一个能在\tex 搜索路径找到的有效的\latex 文件。\cmd{printfile} 将使用\cmd{input} 来加载该\prm{file}。如果指定文件不存在，\cmd{printfile} 不做任何操作。可选的\prm{format} 参数指定了一个域格式化指令应用于该\prm{file}。如果声明了type"=specific的格式指令，其将优先于设置的通用格式指令。如果\prm{format} 缺省，那么\prm{file} 如实输出(原样打印)。注意该功能需要显式的启用\secref{use:opt:pre:gen} 节的包选项\opt{loadfiles}。默认情况下，\cmd{printfile} 不加载任何文件。
%This command is similar to \cmd{printtext} except that the second argument is a file name rather than literal text. The \prm{file} argument must be the name of a valid \latex file found in \tex's search path. \cmd{printfile} will use \cmd{input} to load this \prm{file}. If there is no such file, \cmd{printfile} does nothing. The optional \prm{format} argument specifies a field formatting directive to be applied to the \prm{file}. If a type"=specific \prm{format} has been declared, the type"=specific formatting directive takes precedence over the generic one. If the \prm{format} is omitted, the \prm{file} is printed as is. Note that this feature needs to be enabled explicitly by setting the package option \opt{loadfiles} from \secref{use:opt:pre:gen}. By default, \cmd{printfile} will not input any files.

\csitem{printdate}

该命令打印条目定义在\bibfield{date} 或\bibfield{month}\slash\bibfield{year} 域中的日期。日期格式由\secref{use:opt:pre:gen} 节中的\opt{date} 包选项控制。另外也可以通过调整域格式\texttt{date} (见\secref{aut:fmt:ich})来进一步格式化(比如设置字体等)。注意: 该命令与标点追踪器自动交互，不必使用\cmd{printtext} 命令将其包围起来。
%This command prints the date of the entry, as specified in the fields \bibfield{date} or \bibfield{month}\slash \bibfield{year}. The date format is controlled by the package option \opt{date} from \secref{use:opt:pre:gen}. Additional formatting (fonts etc.) may be applied by adjusting the field format \texttt{date} (\secref{aut:fmt:ich}). Note that this command interfaces with the punctuation tracker. There is no need to wrap it in a \cmd{printtext} command.

\csitem{printdateextra}

类似于\cmd{printdate}，但指定的日期域是\bibfield{extradate} 域。用于设计作者年制的参考文献样式。
%Similar to \cmd{printdate} but incorporates the \bibfield{extradate} field in the date specification. This is useful for bibliography styles designed for author-year citations.

\csitem{printlabeldate}

类似于\cmd{printdate}，但打印的是日期域由\cmd{DeclareLabeldate} 决定。日期格式由\secref{use:opt:pre:gen} 节中的\opt{labeldate} 包选项控制。另外也可以通过调整域格式\texttt{labeldate} (见\secref{aut:fmt:ich})来进一步格式化。
%Similar to \cmd{printdate} but prints the date field determined by \cmd{DeclareLabeldate}. The date format is controlled by the package option \opt{labeldate} from \secref{use:opt:pre:gen}. Additional formatting may be applied by adjusting the field format \texttt{labeldate} (\secref{aut:fmt:ich}).

\csitem{printlabeldateextra}

类似于\cmd{printlabeldate}，但指定的日期域是\bibfield{extradate} 域，用于设计作者年制的参考文献样式。
%Similar to \cmd{printlabeldate} but incorporates the \bibfield{extradate} field in the date specification. This is useful for bibliography styles designed for author-year citations.

\csitem{print$<$datetype$>$date}

类似于\cmd{printdate}，但打印的是日期域是条目的\bibfield{$<$datetype$>$date} 域。日期格式由\secref{use:opt:pre:gen} 节中的\opt{$<$datetype$>$date} 包选项控制。另外也可以通过调整域格式\texttt{$<$datetype$>$date} (见\secref{aut:fmt:ich})来进一步格式化。$<$datetype$>$在默认数据模型中有:<> (用于\bibfield{date} 域), <orig>, <event> 和<url>。
%As \cmd{printdate} but prints the \bibfield{$<$datetype$>$date} of the entry. The date format is controlled by the package option \opt{$<$datetype$>$date} from \secref{use:opt:pre:gen}. Additional formatting may be applied by adjusting the field format \texttt{$<$datetype$>$date} (\secref{aut:fmt:ich}). The $<$datetype$>$s in the default data model are <> (for the main \bibfield{date} field), <orig>, <event> and <url>.

\csitem{printtime}

该命令打印条目定义在\bibfield{date} 域(见\secref{bib:use:dat})中的时间范围，时间格式由\secref{use:opt:pre:gen} 节中的\opt{time} 包选项控制。另外也可以通过调整域格式\texttt{time} (见\secref{aut:fmt:ich})来进一步格式化(比如设置字体等)。时间格式化相关内容还包括\opt{timezeros} 选项，\cmd{bibtimesep} 和\cmd{bibtimezonesep} 宏(\secref{use:fmt:lng})。注意: 该命令与标点追踪器自动交互，不必使用\cmd{printtext} 命令将其包围起来。注意该命令打印的是独立于日期成分(元素)的时间范围。当\opt{$<$datepart$>$dateusetime} 选项启用时，也可以与日期范围一起打印，而不各自分开打印。
%This command prints the time range of the entry, as specified in the \bibfield{date} field (see \secref{bib:use:dat}). The time format is controlled by the package option \opt{time} from \secref{use:opt:pre:gen}. Additional formatting (fonts etc.) may be applied by adjusting the field format \texttt{time} (\secref{aut:fmt:ich}). Relevant to time formatting are the \opt{timezeros} option and the \cmd{bibtimesep} and \cmd{bibtimezonesep} macros (\secref{use:fmt:lng}). Note that this command interfaces with the punctuation tracker. There is no need to wrap it in a \cmd{printtext} command. Note that this command prints a stand-alone time range apart from the date elements. With the \opt{$<$datepart$>$dateusetime} option, you can have the printed along with a date when printing a date range instead of printing the time range completely separately, which is what this command allows for.

\csitem{print$<$datetype$>$time}

类似于\cmd{printtime}，但打印的是条目的\bibfield{$<$datetype$>$time} 域。时间格式由\secref{use:opt:pre:gen} 节中的\opt{$<$datetype$>$time} 包选项控制。另外也可以通过调整域格式\texttt{$<$datetype$>$time}(见\secref{aut:fmt:ich})来进一步格式化。$<$datetype$>$在默认数据模型中有:<> (用于\bibfield{date} 域), <orig>, <event> 和<url>。
%As \cmd{printtime} but prints the \bibfield{$<$datetype$>$time} of the entry. The time format is controlled by the package option \opt{$<$datetype$>$time} from \secref{use:opt:pre:gen}. Additional formatting may be applied by adjusting the field format \texttt{$<$datetype$>$time} (\secref{aut:fmt:ich}). The $<$datetype$>$s in the default data model are <> (for the main \bibfield{date} field), <orig>, <event> and <url>.

\cmditem{indexfield}[format]{field}

该命令类似于\cmd{printfield}，差别在于不是打印\prm{field} 而是将其添加到索引中，其格式化指令\prm{format} 由\cmd{DeclareIndexFieldFormat} 命令定义。如果声明了具体条目类型的格式指令，其将优先于设置的通用格式指令。如果\prm{field} 域未定义，该命令不做任何操作。如果\prm{format} 缺省，那么\cmd{indexfield} 将采用与域名相同的格式名。这种情况下任何具体条目类型的格式指令都将优先于通用的格式指令。若所有的这些格式都未定义，那么将采用\texttt{default} 格式作为最后的选择。
%This command is similar to \cmd{printfield} except that the \prm{field} is not printed but added to the index using the formatting directive \prm{format}, as defined with \cmd{DeclareIndexFieldFormat}. If a type"=specific \prm{format} has been declared, it takes precedence over the generic one. If the \prm{field} is undefined, this command does nothing. If the \prm{format} is omitted, \cmd{indexfield} tries using the name of the field as a format name. In this case, any type"=specific formatting directive will also take precedence over the generic one. If all of these formats are undefined, it falls back to \texttt{default} as a last resort.

\cmditem{indexlist}[format][start\ensuremath\rangle--\ensuremath\langle stop]{literal list}

该命令类似于\cmd{printlist}，差别在于不是打印列表的项而是将其添加到索引中，其格式化指令\prm{format} 由\cmd{DeclareIndexListFormat} 命令定义。如果声明了具体条目类型的格式指令，其将优先于设置的通用格式指令。如果\prm{literal list} 未定义，该命令不做任何操作。如果\prm{format} 缺省，那么\cmd{indexlist} 将采用与列表名相同的格式名。这种情况下任何具体条目类型的格式指令都将优先于通用的格式指令。若所有的这些格式都未定义，那么将采用\texttt{default} 格式作为最后的选择。
%This command is similar to \cmd{printlist} except that the items in the list are not printed but added to the index using the formatting directive \prm{format}, as defined with \cmd{DeclareIndexListFormat}. If a type"=specific \prm{format} has been declared, the type"=specific formatting directive takes precedence over the generic one. If the \prm{literal list} is undefined, this command does nothing. If the \prm{format} is omitted, \cmd{indexlist} tries using the name of the list as a format name. In this case, any type"=specific formatting directive will also take precedence over the generic one. If all of these formats are undefined, it falls back to \texttt{default} as a last resort.

\cmditem{indexnames}[format][start\ensuremath\rangle--\ensuremath\langle stop]{name list}

该命令类似于\cmd{printnames}，差别在于不是打印姓名列表的项而是将其添加到索引中，其格式化指令\prm{format} 由\cmd{DeclareIndexNameFormat} 命令定义。如果声明了具体条目类型的格式指令，其将优先于设置的通用格式指令。如果\prm{name list} 未定义，该命令不做任何操作。如果\prm{format} 缺省，那么\cmd{indexnames} 将采用与列表名相同的格式名。这种情况下任何具体条目类型的格式指令都将优先于通用的格式指令。若所有的这些格式都未定义，那么将采用\texttt{default} 格式作为最后的选择。
%This command is similar to \cmd{printnames} except that the items in the list are not printed but added to the index using the formatting directive \prm{format}, as defined with \cmd{DeclareIndexNameFormat}. If a type"=specific \prm{format} has been declared, the type"=specific formatting directive takes precedence over the generic one. If the \prm{name list} is undefined, this command does nothing. If the \prm{format} is omitted, \cmd{indexnames} tries using the name of the list as a format name. In this case, any type"=specific formatting directive will also take precedence over the generic one. If all of these formats are undefined, it falls back to \texttt{default} as a last resort.

\cmditem{entrydata}{key}{code}
\cmditem*{entrydata*}{key}{code}

类似\cmd{printfield} 的数据命令，正常情况下应用当前正在处理的条目数据。可以使用\cmd{entrydata} 在局部环境中转换应用数据。\prm{key} 是要局部使用的条目的关键词。\prm{code} 是在当前局部环境执行的任意代码。这一代码将在一个编组中执行。示例见\secref{aut:cav:mif} 节。注意: 该命令自动转换语言，如果\opt{autolang} 包选项启用的话。带星号的命令\cmd{entrydata*} 将复制封装条目(the enclosing entry)的所有域，并使用域、计数器和其它以字符串<\texttt{saved}>为前缀命名的资源。这在比较两个数据集时很有用。例如，在\prm{code} 的参数中，\bibfield{author} 域保存了条目\prm{key} 的作者，而封装条目的作者保存在\bibfield{savedauthor} 域中。\cnt{author} 计数器保存了\prm{key} 条目的\bibfield{author} 域的姓名数量，而封装条目的作者数量由\bibfield{savedauthor} 计数器保存。
%Data commands like \cmd{printfield} normally use the data of the entry currently being processed. You may use \cmd{entrydata} to switch contexts locally. The \prm{key} is the entry key of the entry to use locally. The \prm{code} is arbitrary code to be executed in this context. This code will be executed in a group. See \secref{aut:cav:mif} for an example. Note that this command will automatically switch languages if the \opt{autolang} package option is enabled. The starred version \cmd{entrydata*} will clone all fields of the enclosing entry, using field, counter, and other resource names prefixed with the string <\texttt{saved}>. This is useful when comparing two data sets. For example, inside the \prm{code} argument, the \bibfield{author} field holds the author of entry \prm{key} and the author of the enclosing entry is available as \bibfield{savedauthor}. The \cnt{author} counter holds the number of names in the \bibfield{author} field of \prm{key}; the \bibfield{savedauthor} counter refers to the author count of the enclosing entry.

\cmditem{entryset}{precode}{postcode}

该命令用在处理\bibtype{set} 条目集的参考文献驱动中。它将对由\bibfield{entryset} 域指出的集的所有成员进行循环处理，对集的各个成员执行相应的驱动。这相当于对每个集成员执行\secref{aut:aux:msc} 节的\cmd{usedriver} 命令。\prm{precode} 是在集的每项处理之前执行的任意代码。\prm{postcode} 是在集的每项处理之后执行的任意代码。两个参数语法上必须的，但可以留空。用法示例见\secref{aut:cav:set} 节。
%This command is intended for use in bibliography drivers handling \bibtype{set} entries. It will loop over all members of the set, as indicated by the \bibfield{entryset} field, and execute the appropriate driver for the respective set member. This is similar to executing the \cmd{usedriver} command from \secref{aut:aux:msc} for each set member. The \prm{precode} is arbitrary code to be executed prior to processing each item in the set. The \prm{postcode} is arbitrary code to be executed immediately after processing each item. Both arguments are mandatory in terms of the syntax but may be left empty. See \secref{aut:cav:set} for usage examples.

\cmditem{DeclareFieldInputHandler}{field}{code}

该命令用于定义从\file{.bbl} 读取数据所采用的域的数据输入处理器。在\prm{code} 内，宏\cmd{NewValue} 包含了域的值。比如，要忽略出现的\bibfield{volumes} 域，可以作:
This command can be used to define a data input handler for \prm{field} when it is read from the \file{.bbl}. The \prm{code} is passed one argument (\lstinline{#1}), which contains the input field value, it should then redefine the command \cmd{NewValue}, which holds the desired output field value. For example, to ignore the \bibfield{volumes} field when it appears, you could do


\begin{ltxexample}
\DeclareFieldInputHandler{volumes}{\def\NewValue{}}
\end{ltxexample}
%
一般情况下，要删除和修改域需要使用\cmd{DeclareSourcemap}(见\secref{aut:ctm:map} 节)，而这一替代方法在一些情形下会很有用，例如当强调的是数据的外观而不是数据本身时，因为\prm{code} 可以是任意的\tex 代码。
%Generally, you would want to use \cmd{DeclareSourcemap} (see \secref{aut:ctm:map}) to remove and modify fields but this alternative method may be useful in some circumstances when the emphasis is on appearance rather than data since the \prm{code} can be arbitraty \tex.
In general, \cmd{DeclareFieldInputHandler} should not be used to apply formatting to a field, since that should happen with \cmd{DeclareFieldFormat}, so the following is just a toy example that shows how \cmd{DeclareFieldInputHandler} works.

\begin{ltxexample}
\DeclareFieldInputHandler{volumes}{\def\NewValue{\textbf{#1}}}
\end{ltxexample}

\cmditem{DeclareListInputHandler}{list}{code}

类似于\cmd{DeclareFieldInputHandler}，但用于列表。在\prm{code} 内，宏\cmd{NewValue} 包含了列表的值，而\cmd{NewCount} 保存列表中项的序号。
%As \cmd{DeclareFieldInputHandler} but for lists. Within the \prm{code}, the macro \cmd{NewValue}
%contains the value of the list and \cmd{NewCount} contains the number of items in the list.

Note that \cmd{NewValue} as well as the single argument to \prm{code} contain the internal representation of the list.

\cmditem{DeclareNameInputHandler}{name}{code}

类似于\cmd{DeclareFieldInputHandler}，但用于姓名列表。在\prm{code} 内，宏\cmd{NewValue} 包含了姓名列表的值，而\cmd{NewCount} 保存列表中姓名的序号，\cmd{NewOption} 保存了\file{.bbl} 文件传递的各个姓名相关的任意选项。
%As \cmd{DeclareFieldInputHandler} but for names. Within the \prm{code}, the macro \cmd{NewValue}
%contains the value of the name, \cmd{NewCount} contains the number of individual names in the name and \cmd{NewOption} contains any per-name options passed in the \file{.bbl}.
Note that \cmd{NewValue} as well as the single argument to \prm{code} contain the internal representation of the name list.

\end{ltxsyntax}

\subsubsection{格式化指令}%Formatting Directives
\label{aut:bib:fmt}

本节介绍\secref{aut:bib:dat} 节的数据命令所需的格式化指令的定义命令。注意: 所有标注的格式定义在\path{biblatex_.def} 文件中。
%This section introduces the commands used to define the formatting directives required by the data commands from \secref{aut:bib:dat}. Note that all standard formats are defined in \path{biblatex_.def}.

\begin{ltxsyntax}

\cmditem{DeclareFieldFormat}[entrytype, \dots]{format}{code}
\cmditem*{DeclareFieldFormat}*{format}{code}

定义域格式\prm{format}。该格式化指令是由\cmd{printfield} 命令执行的任意\prm{code}。域的值作为仅有的第一个参数传递给\prm{code}。正在处理的域名在\prm{code} 中以\cmd{currentfield} 表示。如果指定一种条目类型(\prm{entrytype})，那么格式是该类型专属的。\prm{entrytype} 可以是一个逗号分隔(comma"=separated)的值列表。带星的命令类似于不带星的命令，区别在于它还将清除所有对具体条目类型做的格式定义。
%Defines the field format \prm{format}. This formatting directive is arbitrary \prm{code} to be executed by \cmd{printfield}. The value of the field will be passed to the \prm{code} as its first and only argument. The name of the field currently being processed is available to the \prm{code} as \cmd{currentfield}. If an \prm{entrytype} is specified, the format is specific to that type. The \prm{entrytype} argument may be a comma"=separated list of values. The starred variant of this command is similar to the regular version, except that all type-specific formats are cleared.

\cmditem{DeclareListFormat}[entrytype, \dots]{format}{code}
\cmditem*{DeclareListFormat}*{format}{code}

定义抄录文本列表\footnote{译者: literal 译为抄录文本} 的格式\prm{format}。格式化指令是\cmd{printlist} 命令处理列表中每一项时执行的任意\prm{code}。当前正在处理的项作为唯一的第一参数传递给\prm{code}。正在处理的文本列表名在\prm{code} 中以\cmd{currentlist} 表示。如果指定了\prm{entrytype}，那么格式是该类型专属的。\prm{entrytype} 参数可以是一个逗号分隔(comma"=separated)的值列表。注意格式化指令也会处理在列表各项间插入的标点。需要对当前项处于列表中间或者末尾进行检测，即检查\cnt{listcount} 是否小于或等于\cnt{liststop}。带星的命令类似于不带星的命令，区别在于它还将清除所有对具体条目类型做的格式定义。
%Defines the literal list format \prm{format}. This formatting directive is arbitrary \prm{code} to be executed for every item in a list processed by \cmd{printlist}. The current item will be passed to the \prm{code} as its first and only argument. The name of the literal list currently being processed is available to the \prm{code} as \cmd{currentlist}. If an \prm{entrytype} is specified, the format is specific to that type. The \prm{entrytype} argument may be a comma"=separated list of values. Note that the formatting directive also handles the punctuation to be inserted between the individual items in the list. You need to check whether you are in the middle of or at the end of the list, \ie whether \cnt{listcount} is smaller than or equal to \cnt{liststop}. The starred variant of this command is similar to the regular version, except that all type-specific formats are cleared.

\cmditem{DeclareNameFormat}[entrytype, \dots]{format}{code}
\cmditem*{DeclareNameFormat}*{format}{code}

定义姓名列表的格式\prm{format}。格式化指令是\cmd{printnames} 命令处理列表中每一项时执行的任意\prm{code}。如果指定了\prm{entrytype}，那么格式是该类型专属的。\prm{entrytype} 参数可以是一个逗号分隔(comma"=separated)的值列表。单个姓名的各个成分(组成部分)由自动创建的宏表示(见下)。默认数据模型定义了四个成分对应于标准的\bibtex 姓名成分参数。
%Defines the name list format \prm{format}. This formatting directive is arbitrary \prm{code} to be executed for every name in a list processed by \cmd{printnames}. If an \prm{entrytype} is specified, the format is specific to that type. The \prm{entrytype} argument may be a comma"=separated list of values. The individual parts of a name will be available in automatically created macros (see below). The default data mode defines four name part which correspond to the standard \bibtex name parts arguments:

\begin{argumentlist}{00}
\item[family] 姓，\bibtex 中为<last> name成分。当一个姓名只有一个成分时(比如 <Aristotle>)，这一成分将被处理为姓。
%The family name(s), know as <last> in \bibtex.  If a name consists of a single part only (for example, <Aristotle>), this part will be treated as the family name.
\item[given] 名。注意名在\bibtex 中为<first> name成分。
%The given name(s). Note that given names are referred to as the <first> names in the \bibtex file format documentation.
\item[prefix] 尊称(前缀)，比如von, van, of, da, de, del, della等。注意尊称在\bibtex 格式文件中为<von>成分。
%Any name prefices, for example von, van, of, da, de, del, della, etc. Note that name prefices are referred to as the <von> part of the name in the \bibtex file format documentation.
\item[suffix] 后缀，比如Jr, Sr等。注意后缀在\bibtex 格式文件中为<Jr>成分。
%Any name suffices, for example Jr, Sr. Note that name suffices are referred to as the <Jr> part of the name in the \bibtex file format documentation.
\end{argumentlist}
%
数据模型<nameparts>常量的值(见\secref{aut:bbx:drv})在姓名的数据模型中为每个姓名成分创建了两个宏。比如，在默认数据模型中，姓名格式由如下宏定义:
%The value of the datamodel <nameparts> constant (see \secref{aut:bbx:drv}) creates two macros for each name part in the datamodel for the name. So, for example, in the default data model, name formats will have defined the following macros:

\begin{ltxexample}
\namepartprefix %表示尊称(前缀)部分
\namepartprefixi %表示尊称首字母
\namepartfamily %表示姓
\namepartfamilyi %表示姓首字母
\namepartsuffix %表示后缀
\namepartsuffixi %表示后缀首字母
\namepartgiven %表示名
\namepartgiveni %表示名首字母
\end{ltxexample}
%
如果一个姓名的某些成分没有给出，相应的宏将为空，因此可以使用，比如\sty{etoolbox} 中\cmd{ifdefvoid} 这类的判断来检查姓名的各个成分。正在处理的姓名列表名在\prm{code} 中以\cmd{currentname} 表示。注意格式化指令也会处理在列表各项间插入的标点。需要对当前项是在列表中间或者末尾进行检测，即检查\cnt{listcount} 是否小于或等于\cnt{liststop}(见\secref{use:cav:nam} 节)。带星的命令类似于不带星的命令，区别在于它还将清除所有对具体条目类型做的格式定义。
%If a certain part of a name is not available, the corresponding macro will be empty, hence you may use, for example, the \sty{etoolbox} tests like \cmd{ifdefvoid} to check for the individual parts of a name. The name of the name list currently being processed is available to the \prm{code} as \cmd{currentname}. Note that the formatting directive also handles the punctuation to be inserted between separate names and between the individual parts of a name. You need to check whether you are in the middle of or at the end of the list, \ie whether \cnt{listcount} is smaller than or equal to \cnt{liststop}. See also \secref{use:cav:nam}. The starred variant of this command is similar to the regular version, except that all type-specific formats are cleared.

\cmditem{DeclareListWrapperFormat}[entrytype, \dots]{format}{code}
\cmditem*{DeclareListWrapperFormat}*{format}{code}

%Defines the list wrapper format \prm{format}. This formatting directive is arbitrary \prm{code} to be executed once for the entire list processed by \cmd{printlist}. The name of the literal list currently being processed is available to the \prm{code} as \cmd{currentlist}. If an \prm{entrytype} is specified, the format is specific to that type. The \prm{entrytype} argument may be a comma"=separated list of values. The starred variant of this command is similar to the regular version, except that all type-specific formats are cleared.
定义列表的封套(wrapper)格式。该格式化指令可以是任意代码，在\cmd{printlist}处理整个列表时仅执行一次。
文本列表名在处理过程中可以通过\cmd{currentlist}在\prm{code}中使用。如果制定了条目类型，该格式仅对该类型有效。
\prm{entrytype}参数可以是逗号分隔的列表。该命令带星号版本的差别在于它会清除所有制定条目类型的格式设置。


\cmditem{DeclareNameWrapperFormat}[entrytype, \dots]{format}{code}
\cmditem*{DeclareNameWrapperFormat}*{format}{code}

%Defines the list wrapper format \prm{format}. This formatting directive is arbitrary \prm{code} to be executed once for the entire name list processed by \cmd{printnames}. The name of the literal list currently being processed is available to the \prm{code} as \cmd{currentname}. If an \prm{entrytype} is specified, the format is specific to that type. The \prm{entrytype} argument may be a comma"=separated list of values. The starred variant of this command is similar to the regular version, except that all type-specific formats are cleared.
定义姓名列表的封套(wrapper)格式。该格式化指令可以是任意代码，在\cmd{printlist}处理整个列表时仅执行一次。
文本列表名在处理过程中可以通过\cmd{currentnames}在\prm{code}中使用。如果制定了条目类型，该格式仅对该类型有效。
\prm{entrytype}参数可以是逗号分隔的列表。该命令带星号版本的差别在于它会清除所有制定条目类型的格式设置。


\cmditem{DeclareIndexFieldFormat}[entrytype, \dots]{format}{code}
\cmditem*{DeclareIndexFieldFormat}*{format}{code}

定义域格式\prm{format}。该格式化指令是由\cmd{indexfield} 命令执行的任意\prm{code}。域的值作为仅有的第一个参数传递给\prm{code}。正在处理的域名在\prm{code} 中以\cmd{currentfield} 表示。如果指定一种条目类型(\prm{entrytype})，那么格式是该类型专属的。\prm{entrytype} 可以是一个逗号分隔(comma"=separated)的值列表。该命令类似于\cmd{DeclareFieldFormat}，差别在于\prm{code} 处理的数据不是用于打印而是用于索引。注意\cmd{indexfield} 将执行\prm{code} 本身，即\prm{code} 必须包含\cmd{index} 或类似命令。带星的命令类似于不带星的命令，区别在于它还将清除所有对具体条目类型做的格式定义。
%Defines the field format \prm{format}. This formatting directive is arbitrary \prm{code} to be executed by \cmd{indexfield}. The value of the field will be passed to the \prm{code} as its first and only argument. The name of the field currently being processed is available to the \prm{code} as \cmd{currentfield}. If an \prm{entrytype} is specified, the format is specific to that type. The \prm{entrytype} argument may be a comma"=separated list of values. This command is similar to \cmd{DeclareFieldFormat} except that the data handled by the \prm{code} is not intended to be printed but written to the index. Note that \cmd{indexfield} will execute the \prm{code} as is, \ie the \prm{code} must include \cmd{index} or a similar command. The starred variant of this command is similar to the regular version, except that all type-specific formats are cleared.

\cmditem{DeclareIndexListFormat}[entrytype, \dots]{format}{code}
\cmditem*{DeclareIndexListFormat}*{format}{code}

定义抄录文本列表格式\prm{format}。该格式化指令是由\cmd{indexlist} 命令执行的任意\prm{code}。列表中当前值作为唯一参数传递给\prm{code}。正在处理的列表名在\prm{code} 中以\cmd{currentlist} 表示。如果指定一种条目类型(\prm{entrytype})，那么格式是该类型专属的。\prm{entrytype} 可以是一个逗号分隔(comma"=separated)的值列表。该命令类似于\cmd{DeclareListFormat}，差别在于\prm{code} 处理的数据不是用于打印而是用于索引。注意\cmd{indexlist} 将执行\prm{code} 本身，即\prm{code} 必须包含\cmd{index} 或类似命令。带星的命令类似于不带星的命令，区别在于它还将清除所有对具体条目类型做的格式定义。
%Defines the literal list format \prm{format}. This formatting directive is arbitrary \prm{code} to be executed for every item in a list processed by \cmd{indexlist}. The current item will be passed to the \prm{code} as its only argument. The name of the literal list currently being processed is available to the \prm{code} as \cmd{currentlist}. If an \prm{entrytype} is specified, the format is specific to that type. The \prm{entrytype} argument may be a comma"=separated list of values. This command is similar to \cmd{DeclareListFormat} except that the data handled by the \prm{code} is not intended to be printed but written to the index. Note that \cmd{indexlist} will execute the \prm{code} as is, \ie the \prm{code} must include \cmd{index} or a similar command. The starred variant of this command is similar to the regular version, except that all type-specific formats are cleared.

\cmditem{DeclareIndexNameFormat}[entrytype, \dots]{format}{code}
\cmditem*{DeclareIndexNameFormat}*{format}{code}

定义姓名列表格式\prm{format}。该格式化指令是由\cmd{indexnames} 命令执行的任意\prm{code}。列表中当前值作为唯一参数传递给\prm{code}。正在处理的列表名在\prm{code} 中以\cmd{currentname} 表示。如果指定一种条目类型(\prm{entrytype})，那么格式是该类型专属的。\prm{entrytype} 可以是一个逗号分隔(comma"=separated)的值列表。该命令类似于\cmd{DeclareNameFormat}，差别在于\prm{code} 处理的数据不是用于打印而是用于索引。注意\cmd{indexnames} 将执行\prm{code} 本身，即\prm{code} 必须包含\cmd{index} 或类似命令。带星的命令类似于不带星的命令，区别在于它还将清除所有对具体条目类型做的格式定义。
%Defines the name list format \prm{format}. This formatting directive is arbitrary \prm{code} to be executed for every name in a list processed by \cmd{indexnames}. The name of the name list currently being processed is available to the \prm{code} as \cmd{currentname}. If an \prm{entrytype} is specified, the format is specific to that type. The \prm{entrytype} argument may be a comma"=separated list of values. The parts of the name will be passed to the \prm{code} as separate arguments. This command is very similar to \cmd{DeclareNameFormat} except that the data handled by the \prm{code} is not intended to be printed but written to the index. Note that \cmd{indexnames} will execute the \prm{code} as is, \ie the \prm{code} must include \cmd{index} or a similar command. The starred variant of this command is similar to the regular version, except that all type-specific formats are cleared.

\cmditem{DeclareIndexListWrapperFormat}[entrytype, \dots]{format}{code}
\cmditem*{DeclareIndexListWrapperFormat}*{format}{code}

%Similar to \cmd{DeclareIndexListFormat} but for the list format used for indices.
类似于\cmd{DeclareIndexListFormat}，但仅用于索引中。


\cmditem{DeclareIndexNameWrapperFormat}[entrytype, \dots]{format}{code}
\cmditem*{DeclareIndexNameWrapperFormat}*{format}{code}

%Similar to \cmd{DeclareIndexNameFormat} but for the name list format used for indices.
类似于\cmd{DeclareIndexNameFormat}，但仅用于索引中。

\cmditem{DeclareFieldAlias}[entry type]{alias}[format entry type]{format}

声明\prm{alias} 作为域格式\prm{format} 的别名。如果指定一种条目类型(\prm{entrytype})，别名是该类型专属的。\prm{format entry type} 是后端格式的条目类型。这仅在声明某一具体条目类型的格式化指令的别名时需要。
%Declares \prm{alias} to be an alias for the field format \prm{format}. If an \prm{entrytype} is specified, the alias is specific to that type. The \prm{format entry type} is the entry type of the backend format. This is only required when declaring an alias for a type"=specific formatting directive.

\cmditem{DeclareListAlias}[entry type]{alias}[format entry type]{format}

声明\prm{alias} 作为抄录文本列表格式\prm{format} 的别名。如果指定一种条目类型(\prm{entrytype})，别名是该类型专属的。\prm{format entry type} 是后端格式的条目类型。这仅在声明某一具体条目类型的格式化指令的别名时需要。
%Declares \prm{alias} to be an alias for the literal list format \prm{format}. If an \prm{entrytype} is specified, the alias is specific to that type. The \prm{format entry type} is the entry type of the backend format. This is only required when declaring an alias for a type"=specific formatting directive.

\cmditem{DeclareNameAlias}[entry type]{alias}[format entry type]{format}

声明\prm{alias} 作为姓名列表格式\prm{format} 的别名。如果指定一种条目类型(\prm{entrytype})，别名是该类型专属的。\prm{format entry type} 是后端格式的条目类型。这仅在声明某一具体条目类型的格式化指令的别名时需要。
%Declares \prm{alias} to be an alias for the name list format \prm{format}. If an \prm{entrytype} is specified, the alias is specific to that type. The \prm{format entry type} is the entry type of the backend format. This is only required when declaring an alias for a type"=specific formatting directive.

\cmditem{DeclareListWrapperAlias}[entry type]{alias}[format entry type]{format}

%Declares \prm{alias} to be an alias for the outer list format \prm{format}. If an \prm{entrytype} is specified, the alias is specific to that type. The \prm{format entry type} is the entry type of the backend format. This is only required when declaring an alias for a type"=specific formatting directive.
声明一个列表封套格式\prm{format}的别名。如果指定了\prm{entrytype}，该别名仅对该类型有效。
\prm{format entry type}是基础格式的类型，这类别名通常仅在声明指定类型的格式化指令的别名时需要。


\cmditem{DeclareNameWrapperAlias}[entry type]{alias}[format entry type]{format}

%Declares \prm{alias} to be an alias for the outer name list format \prm{format}. If an \prm{entrytype} is specified, the alias is specific to that type. The \prm{format entry type} is the entry type of the backend format. This is only required when declaring an alias for a type"=specific formatting directive.
声明一个列表封套格式\prm{format}的别名。如果指定了\prm{entrytype}，该别名仅对该类型有效。
\prm{format entry type}是基础格式的类型，这类别名通常仅在声明指定类型的格式化指令的别名时需要。


\cmditem{DeclareIndexFieldAlias}[entry type]{alias}[format entry type]{format}

声明\prm{alias} 作为域格式\prm{format} 的别名。如果指定一种条目类型(\prm{entrytype})，别名是该类型专属的。\prm{format entry type} 是后端格式的条目类型。这仅在声明某一具体条目类型的格式化指令的别名时需要。
%Declares \prm{alias} to be an alias for the field format \prm{format}. If an \prm{entrytype} is specified, the alias is specific to that type. The \prm{format entry type} is the entry type of the backend format. This is only required when declaring an alias for a type"=specific formatting directive.

\cmditem{DeclareIndexListAlias}[entry type]{alias}[format entry type]{format}

声明\prm{alias} 作为抄录文本列表格式\prm{format} 的别名。如果指定一种条目类型(\prm{entrytype})，别名是该类型专属的。\prm{format entry type} 是后端格式的条目类型。这仅在声明某一具体条目类型的格式化指令的别名时需要。
%Declares \prm{alias} to be an alias for the literal list format \prm{format}. If an \prm{entrytype} is specified, the alias is specific to that type. The \prm{format entry type} is the entry type of the backend format. This is only required when declaring an alias for a type"=specific formatting directive.

\cmditem{DeclareIndexNameAlias}[entry type]{alias}[format entry type]{format}

声明\prm{alias} 作为姓名列表格式\prm{format} 的别名。如果指定一种条目类型(\prm{entrytype})，别名是该类型专属的。\prm{format entry type} 是后端格式的条目类型。这仅在声明某一具体条目类型的格式化指令的别名时需要。
%Declares \prm{alias} to be an alias for the name list format \prm{format}. If an \prm{entrytype} is specified, the alias is specific to that type. The \prm{format entry type} is the entry type of the backend format. This is only required when declaring an alias for a type"=specific formatting directive.


\cmditem{DeclareIndexListWrapperAlias}[entrytype, \dots]{format}{code}

%Similar to \cmd{DeclareIndexListFormat} but for the list format used for indices.
类似于\cmd{DeclareIndexListFormat}，但仅用于索引中。

\cmditem{DeclareIndexNameWrapperAlias}[entrytype, \dots]{format}{code}

%Similar to \cmd{DeclareIndexNameFormat} but for the name list format used for indices.
类似于\cmd{DeclareIndexNameFormat}，但仅用于索引中。

\cmditem{DeprecateFieldFormatWithReplacement}[entry type]{alias}[format entry type]{format}

%Declares \prm{alias} to be an alias for the name list format \prm{format} and issue a deprecation warning. If an \prm{entrytype} is specified, the alias is specific to that type. The \prm{format entry type} is the entry type of the backend format. This is only required when declaring an alias for a type"=specific formatting directive.
声明姓名列表格式\prm{format}的别名，并给出一个表示不推荐的警告。
如果指定了\prm{entrytype}，该别名仅对该类型有效。
\prm{format entry type}是基础格式的类型，这类别名通常仅在声明指定类型的格式化指令的别名时需要。



\cmditem{DeprecateListFormatWithReplacement}[entry type]{alias}[format entry type]{format}

%Similar to \cmd{DeprecateFieldFormatWithReplacement} but for list formats.
类似于\cmd{DeprecateFieldFormatWithReplacement}，但用于列表。

\cmditem{DeprecateNameFormatWithReplacement}[entry type]{alias}[format entry type]{format}

%Similar to \cmd{DeprecateFieldFormatWithReplacement} but for name formats.
类似于\cmd{DeprecateFieldFormatWithReplacement}，但用于姓名列表。

\cmditem{DeprecateListWrapperFormatWithReplacement}[entry type]{alias}[format entry type]{format}

%Similar to \cmd{DeprecateFieldFormatWithReplacement} but for outer list formats.
类似于\cmd{DeprecateFieldFormatWithReplacement}，但用于列表封套。

\cmditem{DeprecateNameWrapperFormatWithReplacement}[entry type]{alias}[format entry type]{format}

%Similar to \cmd{DeprecateFieldFormatWithReplacement} but for outer name formats.
类似于\cmd{DeprecateFieldFormatWithReplacement}，但用于姓名封套。

\cmditem{DeprecateIndexFieldFormatWithReplacement}[entry type]{alias}[format entry type]{format}

%Similar to \cmd{DeprecateFieldFormatWithReplacement} but for index field formats.
类似于\cmd{DeprecateFieldFormatWithReplacement}，但用于索引中的域。

\cmditem{DeprecateIndexListFormatWithReplacement}[entry type]{alias}[format entry type]{format}

%Similar to \cmd{DeprecateFieldFormatWithReplacement} but for index list formats.
类似于\cmd{DeprecateFieldFormatWithReplacement}，但用于索引中的列表。

\cmditem{DeprecateIndexNameFormatWithReplacement}[entry type]{alias}[format entry type]{format}

%Similar to \cmd{DeprecateFieldFormatWithReplacement} but for index name formats.
类似于\cmd{DeprecateFieldFormatWithReplacement}，但用于索引中的姓名列表。

\cmditem{DeprecateIndexListWrapperFormatWithReplacement}[entry type]{alias}[format entry type]{format}

%Similar to \cmd{DeprecateFieldFormatWithReplacement} but for index list formats.
类似于\cmd{DeprecateFieldFormatWithReplacement}，但用于索引中的列表封套。

\cmditem{DeprecateIndexNameWrapperFormatWithReplacement}[entry type]{alias}[format entry type]{format}

%Similar to \cmd{DeprecateFieldFormatWithReplacement} but for index name formats.
类似于\cmd{DeprecateFieldFormatWithReplacement}，但用于索引中的姓名列表封套。

\end{ltxsyntax}


\subsection{定制}%Customization
\label{aut:ctm}

\subsubsection{关联条目}%Related Entries
\label{aut:ctm:rel}
%The related entries feature comprises the following components:
关联条目相关功能由如下部分构成:
\begin{itemize}
\item 条目中的特殊域用于建立和描述关系
%\item Special fields in an entry to set up and describe relationships
\item 本地化字符串作为关联数据的前缀(可选)
%\item Optionally, localisation strings to prefix the related data
\item 抽取和打印关联数据的宏
%\item Macros to extract and print the related data
\item 用于本地化字符串和关联数据格式化的格式
%\item Formats to format the localisation string and related data
\end{itemize}
%
特殊域是\bibfield{related}, \bibfield{relatedtype}, \bibfield{relatedstring} 和 \bibfield{relatedoptions}:
%The special fields are \bibfield{related}, \bibfield{relatedtype}, \bibfield{relatedstring} and \bibfield{relatedoptions}:
\begin{keymarglist}
\item[related] 与当前条目存在某种程度关联性的条目关键词列表\footnote{译者: 这里separated list 译为分离列表，列表}。注意: 条目关键词\footnote{译者: 这里的key关键词就是是条目关键词，引用关键词，即bibtex 键} 的顺序很重要。来自多个关联条目的数据是按该域中关键词的顺序打印的。
%\item[related] A separated list of keys of entries which are related to this entry in some way. Note the the order of the keys is important. The data from multiple related entries is printed in the order of the keys listed in this field.

\item[relatedtype] 关联类型。主要用于三个目的: 第一，如果该域的值解析为一个本地化字符串的标识，那么得到的本地化字符串将在来自关联条目的数据之前打印。第二，如果存在名为\texttt{related:\prm{relatedtype}} 的宏，它将用于格式化来自关联条目的数据，如果宏不存在，则使用\texttt{related:default} 宏。最后，如果存在名为\texttt{related:\prm{relatedtype}} 的格式，它将用来格式化本地化字符串和关联条目数据。如果没有具体类型的格式，那么使用\texttt{related} 格式。
%The type of relationship. This serves three purposes. If the value of this field resolves to a localisation string identifier, then the resulting localised string is printed before the data from the related entries. Secondly, if there is a macro called \texttt{related:\prm{relatedtype}}, this is used to format the data from the related entries. If no such macro exists, then the macro \texttt{related:default} is used. Lastly, if there is a format named \texttt{related:\prm{relatedtype}}, then it is used to format both the localised string and related entry data. If there is no related type specific format, the \texttt{related} format is used.
\item[relatedstring] 如果一个条目包含该域，如果该域的值解析为一个本地化字符串的标识，那么本地化字符串的键值将在来自关联条目的数据之前打印。如果该域没有指定一个本地化键，则原样打印该域的值。如果\bibfield{relatedtype} 和 \bibfield{relatedstring} 都出现在条目中，\bibfield{relatedstring} 用于数据之前的字符串(但\bibfield{relatedtype} 仍然用于确定打印数据时的格式和宏)。
%If an entry contains this field, then if value of the field resolves to a localisation string identifier, the localisation key value specified is printed before data from the related entries. If the field does not specify a localisation key, its value is printed literally. If both \bibfield{relatedtype} and \bibfield{relatedstring} are present in an entry, \bibfield{relatedstring} is used for the pre-data string (but \bibfield{relatedtype} is still used to determine the macro and format to use when printing the data).
\item[relatedoptions] 设置在关联条目上的各条目的选项列表(实际上，是对关联条目的副本的设置，关联条目的副本作为数据源，而关联条目本身不做任何的改变，因为它自身有可能被引用)。
%A list of per"=entry options to set on the related entry (actually on the clone of the related entry which is used as a data source---the actual related entry is not modified because it might be cited directly itself).
\end{keymarglist}

关联条目功能由\secref{use:opt:pre:gen} 节的\opt{related} 包选项默认启用。来自关联条目的相关信息数据通过一个调用\cmd{usebibmacro\{related\}} 包含进来。标准样式调用该宏直到每个驱动结束。样式作者应该确保(留意)作为\bibfield{relatedtype} 域值的本地化字符串的存在，比如\texttt{translationof} 或者可能的\texttt{translatedas}。本地化键(关键词)的\prm{relatedtype}\texttt{s} 复数形式可以识别。在\bibfield{related} 中给出的超过1个的键的对应字符串都会打印。用于打印由\prm{relatedtype} 关联的条目的参考文献宏和格式化指令应以\texttt{related:\prm{relatedtype}} 为名进行定义。\path{biblatex.def} 包含了通用的关联类型的宏和格式，可以作为模板。特别的，\cmd{entrydata*} 命令在这些宏中是必须的，因为要获取关联条目的数据。应用了该功能的条目数据可以在\biblatex 发布的示例文件\path{biblatex-examples.bib} 中找到。针对该功能的一些用于控制关联条目间的分隔符的具体格式化宏见\secref{aut:fmt:fmt}。
%The related entry feature is enabled by default by the package option \opt{related} from \secref{use:opt:pre:gen}. The related information entry data from the related entries is included via a \cmd{usebibmacro\{related\}} call. Standard styles call this macro towards the end of each driver. Style authors should ensure the existence of (or take note of existing) localisation strings which are useful as values for the \bibfield{relatedtype} field, such as \texttt{translationof} or perhaps \texttt{translatedas}. A plural variant can be identified with the localisation key \prm{relatedtype}\texttt{s}. This key's corresponding string is printed whenever more than one entry is specified in \bibfield{related}. Bibliography macros and formatting directives for printing entries related by \prm{relatedtype} should be defined using the name \texttt{related:\prm{relatedtype}}. The file \path{biblatex.def} contains macros and formats for some common relation types which can be used as templates. In particular, the \cmd{entrydata*} command is essential in such macros in order to make the data of the related entries available. Examples of entries using this feature can be found in the \biblatex distribution examples file \path{biblatex-examples.bib}. There are some specific formatting macros for this feature which control delimiters and separators in related entry information, see \secref{aut:fmt:fmt}.

\subsubsection{数据源的域集合}%Datasource Sets
\label{aut:ctm:dsets}

能给数据源中域的集合命名，在循环等操作中是很有用的。\biber 可以利用这些集合名来对某些特定数据源的域集合应用某些选项或者执行某些操作。下面的宏允许用来定义任意的数据源的域集合，这些集合中的域在\biblatex 中以\sty{etoolbox} 列表表示，并通过\file{.bcf} 文件传递给\biber 。
%It is useful to be able to define named sets of datasource field names for use in loops etc. In addition, \biber can use such sets in order to apply options and perform operations on particular sets of datasource fields. The following macros allow the user to define arbitrary sets of datasource fields, exposed to \biblatex as \sty{etoolbox} lists and to \biber in the \file{.bcf}.


\begin{ltxsyntax}

\cmditem{DeclareDatafieldSet}{name}{specification}

声明一个数据源的域集合，集合名为\prm{name}。
%Declare a set of datasource fields with name \prm{name}.

\begin{optionlist*}
\valitem{name}{set name}

集的名。
%The name of the set.
\end{optionlist*}

\prm{specification} 是一个或更多的\cmd{member}(成员)项:
%The \prm{specification} is one or more \cmd{member} items:

\cmditem{member}

\begin{optionlist*}
\valitem{fieldtype}{fieldtype}
\valitem{datatype}{datatype}
\valitem{field}{fieldname}
\end{optionlist*}

一个\cmd{member} 说明将域添加到集合中。域可以由数据模型\prm{fieldtype} 和/或 \prm{datatype} 指定 (见 \secref{aut:ctm:dm})。 或者，域也可以通过使用\prm{field} 选项显式地以域名添加。一旦完成定义，集就以\sty{etoolbox} 列表的形式存在，命名为\cmd{datafieldset<setname>} 并通过\file{.bcf} 文件传递给\biber。
%A \cmd{member} specification appends fields to the set. Fields can be specified by datamodel \prm{fieldtype} and/or \prm{datatype} (see \secref{aut:ctm:dm}). Alternatively, fields can be explicitly added by name using the \prm{field} option. Once defined, the set is available as an \sty{etoolbox} list called \cmd{datafieldset<setname>} and is also passed via the \file{.bcf} to \biber.

如下示例就是\biblatex 为姓名域和标题域定义的默认集:
%For example, here are the default sets defined by \biblatex for name fields and title fields:

\end{ltxsyntax}

\begin{ltxexample}[style=latex]{}
\DeclareDatafieldSet{setnames}{
  \member[datatype=name, fieldtype=list]
}

\DeclareDatafieldSet{settitles}{
  \member[field=title]
  \member[field=booktitle]
  \member[field=eventtitle]
  \member[field=issuetitle]
  \member[field=journaltitle]
  \member[field=maintitle]
  \member[field=origtitle]
}
\end{ltxexample}
%
这将以\sty{etoolbox} 列表形式定义\cmd{datafieldsetsetnames} 和\cmd{datafieldsetsettitles} 宏，用来包含指定数据源的域成员的名称。
%\footnote{译者: 应用时要注意集的定义名称和使用的名称是不同的。}
%This defines the macros \cmd{datafieldsetsetnames} and \cmd{datafieldsetsettitles} as \sty{etoolbox} lists containing the names of the member datasource fields specified.

\subsubsection{数据动态修改}%Dynamic Modification of Data
\label{aut:ctm:map}

对自动生成或者无法控制的参考文献数据源进行修改在某种程度上会是一个问题。因此，\biber 提供了对它所读取的数据进行修改的能力，这样你可以对源数据流进行修改而不必实际改变它。这种改变可以在\biber 的配置文件(见\biber 文档)中定义，或者通过\biblatex 宏进行定义，通过宏定义的方法你可以在样式中或者以全局定义的方式，将修改应用在具体的文档中。
%Bibliographic data sources which are automatically generated or which you have no control over can be a problem if you need to edit them in some way. For this reason, \biber has the ability to modify data as it is read so that you can apply modifications to the source data stream without actually changing it. The modification can be defined in \biber's config file (see \biber docs), or via \biblatex macros in which case you can apply the modification only for specific documents, styles or globally.

源映射发生在数据解析过程中，因此也在诸如继承和排序等任何其它操作之前。
%Source mapping happens during data parsing and therefore before any other operation such as inheritance and sorting.

源映射可以在不同的层( «levels» )进行定义，各层以某一定义的顺序进行处理。见\biblatex\ 手册，考虑如下这些宏:\\[2ex]
%Source mappings can be defined at different «levels» which are applied
%in a defined order. See the \biblatex\ manual regarding these macros:\\[2ex]

\noindent \cmd{DeclareSourcemap} 命令定义的用户层(\texttt{user}-level)映射$\rightarrow$\\
\hspace*{1em} 在\biber 配置文件定义的用户层(\texttt{user}-level)映射(见 \biber 文档)$\rightarrow$\\
\hspace*{2em}\cmd{DeclareStyleSourcemap} 定义的样式层(\texttt{style}-level)映射$\rightarrow$\\
\hspace*{3em}\cmd{DeclareDriverSourcemap} 定义的驱动层(\texttt{driver}-level)映射\\[2ex]
%\noindent \texttt{user}-level maps defined with \cmd{DeclareSourcemap}$\rightarrow$\\
%\hspace*{1em}\texttt{user}-level maps defined in the \biber config file (see \biber docs)$\rightarrow$\\
%\hspace*{2em}\texttt{style}-level maps defined with \cmd{DeclareStyleSourcemap}$\rightarrow$\\
%\hspace*{3em}\texttt{driver}-level maps defined with \cmd{DeclareDriverSourcemap}\\[2ex]
\begin{ltxsyntax}

\cmditem{DeclareSourcemap}{specification}

定义源数据修改(映射)规则，可以用于执行如下任务或其任意组合:
%Defines source data modification (mapping) rules which can be used to perform any combination of the following tasks:

\begin{itemize}
\item 将数据源条目类型映射为其它类型
%Map data source entrytypes to different entrytypes
\item 将数据源域映射为其它域
%Map datasource fields to different fields
\item 给条目添加新域
%Add new fields to an entry
\item 从条目移除域
%Remove fields from an entry
\item 用标准的Perl 正则表达式匹配和替换，修改域的内容。
%Modify the contents of a field using standard Perl regular expression match and replace
\item 将上述操作限制在来自特定数据源的条目，这些特定数据源在\cmd{addresource} 宏中定义。

\item Modify the contents of a field using standard Perl regular expression
  match and replace\footnote{See for example \url{https://perldoc.perl.org/perlretut.html}, \url{https://perldoc.perl.org/perlrequick.html} and \url{https://perldoc.perl.org/perlre.html}. There are many more resources available about regular expessions in Perl.}
%Restrict any of the above operations to entries coming from
%particular datasources which you defined in \cmd{addresource} macros

\item 将上述操作限制在某些条目类型。
%Restrict any of the above operations to entries only of a certain
%entrytype

\item 将上述操作限制在某一特定的参考文献节。
%Restrict any of the above operations to entries in a particular
%reference section
\end{itemize}

\prm{specification} 是一个不限数量的\cmd{maps} 指令的列表，这些指令说明了应用于某一特定数据源类型的映射规则的容器(\secref{use:bib:res})。为实现良好的代码显示效果，可以自由使用空格、制表符、行末符号来整理\prm{specification} 中的代码。但空行是不允许的。这一命令仅能用于导言区并且只能使用一次---后面的命令将覆盖前面的定义。
The \prm{specification} is an undelimited list of \cmd{maps} directives which specify containers for mappings rules applying to a particular data source type (\secref{use:bib:res}). Spaces, tabs, and line endings may be used freely to visually arrange the \prm{specification}. Blank lines are not permissible. This command may only be used in the preamble and can be used multiple times, the maps being run in order of definition.


\cmditem{maps}[options]{elements}

包含\cmd{map} 元素的有序集，每个\cmd{map} 都是应用于数据源的映射步的逻辑相关集。\prm{options} 包括:
%Contains an ordered set of \cmd{map} elements each of which is a logically related set of mapping steps to apply to the data source. The \prm{options} are:
\begin{optionlist*}

\choitem[bibtex]{datatype}{bibtex, biblatexml}

包含的\cmd{map} 应用的数据源的类型(见\secref{use:bib:res})
%Data source type to which the contained \cmd{map} directives apply (\secref{use:bib:res}).

\boolitem[false]{overwrite}

具体说明一个映射规则是否允许覆盖条目中已经存在数据。如果该选项未指定，默认是\texttt{false}。简易形式\opt{overwrite} 等价于\kvopt{overwrite}{true}。
%Specify whether a mapping rule is allowed to overwrite already existing data in an entry. If this option is not specified, the default is \texttt{false}. The short form \opt{overwrite} is equivalent to \kvopt{overwrite}{true}.

\end{optionlist*}

\cmditem{map}[options]{restrictions,steps}

一个包含有序的映射操作\cmd{step}s的容器，可以限制在特定的条目类型或者数据源上。这是一个编组元素允许一组映射操作应用到具体的条目类型或数据源上。映射操作必须包含在\cmd{map} 元素内。\prm{options} 包括:
%A container for an ordered set of map \cmd{step}s, optionally restricted to particular entrytypes or data sources. This is a grouping element to allow a set of mapping steps to apply only to specific entrytypes or data sources. Mapping steps must always be contained within a \cmd{map} element. The \prm{options} are:

\begin{optionlist*}

\boolitem{overwrite}

与父元素\cmd{maps} 的相同的选项。该选项允许map层级的覆盖操作。如果该选项未指定，默认是父元素\cmd{maps} 的选项值。简易形式\opt{overwrite} 等价于\kvopt{overwrite}{true}。
%As the same option on the parent \cmd{maps} element. This option allows an override on a per-map group basis. If this option is not specified, the default is the parent \cmd{maps} element option value. The short form \opt{overwrite} is equivalent to \kvopt{overwrite}{true}.

\valitem{foreach}{loopval}

遍历\cmd{map} 内的\cmd{step}s，将包含在\prm{loopval} 中的逗号分隔的各个值设置到特殊变量|$MAPLOOP|中。%$
\prm{loopval} 可以是一个显式的逗号分隔的值列表，也可以是由\cmd{DeclareDatafieldSet} (见\secref{aut:ctm:dsets})定义的任意数据域集合的集名，biber 从中获取数据域并解析为一个逗号分隔的值列表。\prm{loopval} 以列表中的顺序处理。这使得一组\cmd{step}s操作可以遍历\prm{loopval} 的每个值。使用regexp 映射，可以创建一个CSV 域来配合该功能使用。特殊变量|$MAPUNIQ| %$
也可以在\cmd{step}s中用来随机生成一个唯一的字符串。这可以用于创建新条目的关键词。例如:

%Loop over all \cmd{step}s in this \cmd{map}, setting the special variable |$MAPLOOP| %$
%to each of the comma-separated values contained in \prm{loopval}. \prm{loopval} can either be the name of a datafield set defined with \cmd{DeclareDatafieldSet} (see \secref{aut:ctm:dsets}), a datasource field which is fetched and parsed as a comma"=separated values list or an explicit comma"=separated values list. \prm{loopval} is determined in this order. This allows the user to repeat a group of \cmd{step}s for each value \prm{loopval}. Using regexp maps, it is possible to create a CSV field for use with this functionality. The special variable |$MAPUNIQ| %$
%may also be used in the \cmd{step}s to generate a random unique string. This can be useful when creating keys for new entries. An example:

\begin{ltxexample}[style=latex]{}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map[overwrite, foreach={author,editor, translator}]{
      \step[fieldsource=\regexp{$MAPLOOP}, match={Smith}, replace={Jones}]
    }%数据源域将遍历foreach定义的这些域，而这些域由宏\regexp{$MAPLOOP} 表示
  }
}
\end{ltxexample}
%$<- to stop emacs highlighting breaking

\intitem{refsection}

将包含的\cmd{step} 命令应用于序号等于\prm{refsection} 的参考文献节的条目上。
%Only apply the contained \cmd{step} commands to entries in the reference section with number \prm{refsection}.

\end{optionlist*}

\cmditem{perdatasource}{datasource}

将\cmd{map} 元素内所有的\cmd{step}s限制在来自名为\prm{datasource} 的条目上。\prm{datasource} 名应是在\cmd{addresource} 宏给出的文档的参考文献数据源文件名。一个\cmd{map} 元素内允许出现多个\cmd{perdatasource} 约束。
%Restricts all \cmd{step}s in this \cmd{map} element to entries from the named \prm{datasource}. The \prm{datasource} name should be exactly as given in a \cmd{addresource} macro defining a data source for the document. Multiple \cmd{perdatasource} restrictions are allowed within a \cmd{map} element.

\cmditem{pertype}{entrytype}

将\cmd{map} 元素内所有的\cmd{step}s限制在来自类型为\prm{entrytype} 的条目上。一个\cmd{map} 元素内允许出现多个\cmd{pertype} 约束。
%Restricts all \cmd{step}s in this \cmd{map} element to entries of the named \prm{entrytype}. Multiple \cmd{pertype} restrictions are allowed within a \cmd{map} element.

\cmditem{pernottype}{entrytype}

将\cmd{map} 元素内所有的\cmd{step}s限制在来自类型不是\prm{entrytype} 的条目上。一个\cmd{map} 元素内允许出现多个\cmd{pernottype} 约束。
%Restricts all \cmd{step}s in this \cmd{map} element to entries not of the named \prm{entrytype}. Multiple \cmd{pernottype} restrictions are allowed within a \cmd{map} element.

\cmditem{step}[options]

一个映射步。每一步都顺序地应用于每个相关条目上，其中“相关”意为这些条目满足前述指定的数据源类型，条目类型，数据源文件限制。对条目应用每一映射步都在前面映射步完成之后。映射步执行的映射操作由如下选项(\prm{option}s)确定:
%A mapping step. Each step is applied sequentially to every relevant entry where <relevant> means those entries which correspond to the data source type, entrytype and data source name restrictions mentioned above. Each step is applied to the entry as it appears after the application of all previous steps. The mapping performed by the step is determined by the following \prm{option}s:

\begin{optionlist*}

\valitem{typesource}{entrytype} %源的条目类型
\valitem{typetarget}{entrytype}
\valitem{fieldsource}{entryfield}
\valitem{notfield}{entryfield}
\valitem{fieldtarget}{entryfield}
\valitem{match}{regexp}
\valitem{matchi}{regexp}
\valitem{notmatch}{regexp}
\valitem{notmatchi}{regexp}
\valitem{replace}{regexp}
\valitem{fieldset}{entryfield}
\valitem{fieldvalue}{string}
\valitem{entryclone}{clonekey}
\valitem{entrynew}{entrynewkey}
\valitem{entrynewtype}{string}
\valitem{entrytarget}{string}
\boolitem[false]{cited}
\boolitem[false]{nocited}
\boolitem[false]{citedornocited}
\boolitem[false]{allnocited}
\boolitem[false]{starnocited}
\boolitem[false]{entrynocite}
\boolitem[false]{entrynull}
\boolitem[false]{append}
\boolitem[false]{appendstrict}
\boolitem[false]{final}
\boolitem[false]{null}
\boolitem[false]{origfield}
\boolitem[false]{origfieldval}
\boolitem[false]{origentrytype}
%
对于所有的布尔映射选项，简易形式\opt{option} 等价于\kvopt{option}{true}。一个映射步的应用规则如下:
%For all boolean \cmd{step} options, the short form \opt{option} is equivalent to \kvopt{option}{true}. The following rules for a mapping step apply:

\renewcommand{\labelitemii}{$\circ$}

Note that the options \opt{cited}, \opt{nocited}, \opt{citedornocited},
\opt{allnocited} and \opt{starnocited} are unique in that they can make the
results of a sourcemap differ depending on the refsection. This is because
a datasource to which source mapping applies may be used in several
refsections and source mappings are applied when fetching the data from the
datasources for a refsection. Citation commands are local to a refsection
and therefore may differ for the same entry from refsection to refsection.
For example, the same entry may be \cmd{cite}d in one refsection but
\cmd{nocite}d in another, resulting in different source map results and
therefore data between the refsections. This can be avoided if desired, by
limiting source maps to specific refsections only (see \opt{refsection}
option to the \cmd{map} command above).

\begin{itemize}
\item 如果设置\texttt{entrynew}，将创建一个条目关键词为\texttt{entrynewkey} 的新条目，条目的类型在选项\texttt{entrynewtype} 中给出。这一条目仅在当前条目的处理过程中有效，能以\texttt{entrytarget} 进行引用。在\texttt{entrynewkey} 中，可以使用标准的Perl正则表达式来引用从之前的\texttt{match} 步获取的匹配字符串。
%If \texttt{entrynew} is set, a new entry is created with the entry key \texttt{entrynewkey} and the entry type given in the option \texttt{entrynewtype}. This
%entry is only in-scope during the processing of the current entry and can be referenced by
%\texttt{entrytarget}.  In \texttt{entrynewkey}, you may use standard Perl regular expression
%backreferences to captures from a  previous \texttt{match} step.

\item 当一个\texttt{fieldset} 步设置的\texttt{entrytarget} 为一个由\texttt{entrynew} 创建的条目的关键词，域设置的目标将是\texttt{entrytarget} 条目而不是当前正在处理的条目。这使得用户可以创建新的条目并且设置它的域。
%When a \texttt{fieldset} step has \texttt{entrytarget} set to the entrykey of an entry
%created by \texttt{entrynew}, the target for the field set will be the \texttt{entrytarget} entry
%rather than the entry being currently processed. This allows users to create new entries and set
%fields in them.

\item %If \texttt{entrynocite} is used in a \texttt{entrynew} or
  %\texttt{entryclone} step, the new/clone entry will be included in the
  %\file{.bbl} as if the entry/clone had been \cmd{nocite}ed in the document.
如果\texttt{entrynocite}在一个\texttt{entrynew}或\texttt{entryclone}步中使用，
该新/克隆条目将会出现在\file{.bbl}中就好像在正文中对该条目使用了\cmd{nocite}。


\item 如果设置\texttt{entrynull}，\cmd{map} 过程立即终止，当前条目不创建。如同该条目不存在于数据源。显然，需要利用前面的映射步来选择需要应用该操作的条目。
%If \texttt{entrynull} is set, processing of the \cmd{map}
%  immediately terminates and the current entry is not created. It is
%  as if it did not exist in the datasource. Obviously, you should
%  select the entries which you want to apply this to using prior
%  mapping steps.

\item 如果设置\texttt{entryclone}，将创建一个名为\texttt{clonekey} 的副本条目。显然这会影响作者年等样式中的标签生成，使用需谨慎。副本仅在当前条目的处理过程中有效，将其关键词作为\texttt{entrytarget} 的值可对其进行修改。在\texttt{clonekey} 中，可以使用标准的Perl正则表达式来引用从之前的\texttt{match} 步获取的匹配字符串。
%If \texttt{entryclone} is set, a clone of the entry is created with an entry key
%  \texttt{clonekey}. Obviously this may cause labelling problems in author/year styles etc.
%  and should be used with care. The cloned entry is in-scope during the processing of the
%  current entry and can be modified by passing its key as the value to \texttt{entrytarget}.
%  In \texttt{clonekey}, you may use standard Perl regular expression backreferences to
%  captures from a previous \texttt{match} step.

\item If \texttt{cited} is used then only apply the step if the entry key
  of an entry was specifically cited via \cmd{cite}.
\item If \texttt{nocited} is used then only apply the step if the entry key
  of an entry was specifically nocited via \cmd{nocite} or was included via \cmd{nocite\{*\}}.
\item If \texttt{citedornocited} is used then only apply the step if the entry key
  of an entry was specifically cited via \cmd{cite} or specifically nocited via \cmd{nocite}.
\item If \texttt{allnocited} is used then only apply the step if the entry key
  of an entry was included via \cmd{nocite\{*\}}.
\item If \texttt{starnocited} is used then only apply the step if the entry key
  of an entry was included solely because of \cmd{nocite\{*\}}. This
  implies that the entry was neither explicitly \cmd{cite}ed nor explicitly \cmd{nocite}ed.

\item 将\texttt{typesource} \prm{entrytype} 修改到\texttt{typetarget} \prm{entrytype}，如果定义存在的话。如果\texttt{final} 为\texttt{true}，且条目的\prm{entrytype} 不是\texttt{typesource}，父元素\cmd{map} 将立即终止。
%Change the \texttt{typesource} \prm{entrytype} to the
%  \texttt{typetarget} \prm{entrytype}, if defined. If
%  \texttt{final} is \texttt{true} then if the \prm{entrytype} of the entry is not \texttt{typesource}, processing of the parent \cmd{map} immediately terminates.

\item 将\texttt{fieldsource} \prm{entryfield} 修改到\texttt{fieldtarget}，如果定义存在的话。如果\texttt{final} 为\texttt{true}，且条目中不存在\texttt{fieldsource} \prm{entryfield}，父元素\cmd{map} 将立即终止。
%Change the \texttt{fieldsource} \prm{entryfield} to
%  \texttt{fieldtarget}, if defined. If
%  \texttt{final} is \texttt{true} then if there is no \texttt{fieldsource} \prm{entryfield} in the entry, processing of the parent \cmd{map} immediately terminates.

\item 如\prm{entryfield}存在，那么\texttt{notfield}就为true，常与\texttt{final}联用，当条目不包含\prm{entryfield}则映射终止。
%If \texttt{notfield} is true only if the \prm{entryfield} does not
%  exist. Usually used with \texttt{final} so that if an entry does contain
%  \prm{entryfield}, the map terminates.

\item 如果定义了\texttt{match} 但没有定义\texttt{replace}，仅当\texttt{fieldsource} \prm{entryfield} 匹配\texttt{match} 正则表达式时
(如果使用\texttt{notmatch} 则逻辑相反，当使用以<i>结尾的版本时是大小写敏感的)
应用该映射步\footnote{正则表达式是Perl 5.16 全集正则表达式。这意味着需要处理特殊字符，见后面的示例}。可以使用圆括号获取匹配内容，并在后面\texttt{fieldvalue} 设置中引用(\$1\ldots\$9)。这使得可以将一些域的部分内容提取出来放入其它一些域中。
%If \texttt{match} is defined but
%  \texttt{replace} is not, only apply the step if the \texttt{fieldsource} \prm{entryfield} matches the
%  \texttt{match} regular expression (logic is reversed if you use \texttt{notmatch} and case-insensitive if you use the versions ending in <i>)\footnote{Regular expressions are full Perl 5.16 regular expressions. This means you may need to deal with special characters, see examples.}. You may use capture parenthesis as usual and refer to these (\$1\ldots\$9) in later \texttt{fieldvalue} specifications. This allows you to pull out parts of some fields and put these parts in other fields.

\item 如果定义了\texttt{match} 和\texttt{replace}，对\texttt{fieldsource} \prm{entryfield} 的值执行正则表达式匹配和替换操作。
%Perform a regular expression match and replace on the value of the \texttt{fieldsource} \prm{entryfield} if \texttt{match} and \texttt{replace} are defined.

\item 如果定义了\texttt{fieldset}，它的值\prm{entryfield} 将由进一步给出的选项来指定。如果\texttt{overwrite} 是false且该域值已经存在，则该映射步将忽略。如果该映射步的\texttt{final} 也是true，则父元素map在此处终止。如果\texttt{append} 是true，则设置的值将添加到当前\prm{entryfield} 的值中。值仅由如下之一的必选参数设置:
%If \texttt{fieldset} is defined, then its value is \prm{entryfield}
%  which will be set to a value specified by further options. If
%  \texttt{overwrite} is false for this step and the field to set already
%  exists then the map step is ignored. If \texttt{final} is also true for
%  this step, then processing of the parent map stops at this point. If
%  \texttt{append} is true, then the value to set is appended to the current
%  value of \prm{entryfield}. The value to set is specified by a mandatory
%  one and only one of the following options:

  \begin{itemize}
    \item\ \texttt{fieldvalue} --- \texttt{fieldset} \prm{entryfield} 设置为\texttt{fieldvalue} \prm{string}。
    %\texttt{fieldvalue} --- The \texttt{fieldset} \prm{entryfield} is set to the \texttt{fieldvalue} \prm{string}

    \item\ \texttt{null} --- The \texttt{fieldset} \prm{entryfield} 忽略，如果它不存在于数据源中。
    %\texttt{null} --- The \texttt{fieldset} \prm{entryfield} is ignored, as if it did not exist in the datasource

    \item\ \texttt{origentrytype} --- The \texttt{fieldset} \prm{entryfield} 设置为前面最近的\texttt{typesource} \prm{entrytype} 名称。
    %\texttt{origentrytype} --- The \texttt{fieldset} \prm{entryfield} is set to the most recently mentioned \texttt{typesource} \prm{entrytype} name

    \item\ \texttt{origfield} --- The \texttt{fieldset} \prm{entryfield} 设置为前面最近的\texttt{fieldsource} \prm{entryfield} 域名。
    %\texttt{origfield} --- The \texttt{fieldset} \prm{entryfield} is set to the most recently mentioned \texttt{fieldsource} \prm{entryfield} name

    \item\ \texttt{origfieldval} --- The \texttt{fieldset} \prm{entryfield} 设置为前面最近的\texttt{fieldsource} \prm{entryfield} 域值。
    %\texttt{origfieldval} --- The \texttt{fieldset} \prm{entryfield} is set to the most recently mentioned \texttt{fieldsource} value

  \end{itemize}
\end{itemize}
\end{optionlist*}
\end{ltxsyntax}

使用\bibtex\ 数据源，可能设置虚拟域\bibfield{entrykey} 作为\texttt{fieldsource}，它就是条目的引用关键词(即bibtex键)。使用\biblatexml\ 数据源的话，\bibfield{entrykey} 是正常属性可以像任何其它属性一样引用。自然，该域<field>是不能(用修改操作\texttt{fieldset}, \texttt{fieldtarget}，\texttt{replace})改变的。
%\noindent With \bibtex\ datasources, you may specify the
%pseudo-field \bibfield{entrykey} for \texttt{fieldsource}
%which is the citation key of the entry. With \biblatexml\ the \bibfield{entrykey} is a normal attribute and can be reference like any other attribute. Naturally, this <field> cannot
%be changed (used as \texttt{fieldset}, \texttt{fieldtarget} or changed using \texttt{replace}).

%Macros used in \cmd{step} are expanded. Unexpandable contents should be protected with \cmd{detokenize}, regular expressions can be escaped using the dedicated \cmd{regexp} command (see the examples below).

在\cmd{step}中使用的宏是会展开的，要求不展开的内容应该利用\cmd{detokenize}命令进行表或，
而正则表达式则可以利用下面的\cmd{regexp}命令来避开该问题。

\begin{ltxsyntax}

\cmditem{DeclareStyleSourcemap}{specification}

该命令设置由样式使用的数据源映射。这种映射概念上是与由\cmd{DeclareSourcemap} 定义的用户层映射分离的，并且在用户层映射之后应用。其语法与\cmd{DeclareSourcemap} 完全相同。该命令使得样式作者可以定义样式专属的映射而不会与用户层和驱动层的映射相冲突。这一命令可以在样式文件中多次使用，并根据定义的顺序进行映射操作。
%This command sets the source mappings used by a style. Such mappings are conceptually separate from user mappings defined with \cmd{DeclareSourcemap} and are applied directly after user maps. The syntax is identical to \cmd{DeclareSourcemap}. This command is provided for style authors so that any maps defined for the style do not interfere with user maps or the default driver maps defined with \cmd{DeclareDriverSourcemap}. This command is for use in style files and can be used multiple times, the maps being run in order of definition.

\end{ltxsyntax}

\begin{ltxsyntax}

\cmditem{DeclareDriverSourcemap}[datatype=driver]{specification}

该命令为具体的\prm{driver} 设置驱动默认的数据源映射。这种映射概念上是与由\cmd{DeclareSourcemap} 定义的用户层映射和\cmd{DeclareStyleSourcemap} 定义的样式层映射分离的。它们由一些映射组成，也作为驱动组成部分。用户一般不需要修改它。驱动默认映射在用户层和样式层映射之后应用。默认的设置在附录\secref{apx:maps} 介绍。\prm{specification} 与\cmd{DeclareSourcemap} 的相同，但没有\cmd{maps} 元素: \prm{specification} 是一些\cmd{map} 元素的列表，因为每个\cmd{DeclareDriverSourcemap} 仅应用于某一具体的条目类型的驱动中。默认的定义见附录\secref{apx:maps} 中的示例。
%This command sets the driver default source mappings for the specified \prm{driver}. Such mappings are conceptually separate from user mappings defined with \cmd{DeclareSourcemap} and style mapping defined with \cmd{DeclareStyleSourcemap}. They consist of mappings which are part of the driver setup. Users should not normally need to change these. Driver default mapping are applied after user mappings (\cmd{DeclareSourcemap}) and style mappings (\cmd{DeclareStyleSourcemap}). These defaults are described in Appendix \secref{apx:maps}. The \prm{specification} is identical to that for \cmd{DeclareSourcemap} but without the \cmd{maps} elements: the \prm{specification} is just a list of \cmd{map} elements since each \cmd{DeclareDriverSourcemap} only applies to one datatype driver. See the default definitions in Appendix \secref{apx:maps} for examples.

\end{ltxsyntax}

下面给出一些数据源映射的示例:
%Here are some data source mapping examples:

\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map{
      \perdatasource{<<example1.bib>>}
      \perdatasource{<<example2.bib>>}
      \step[fieldset=<<keywords>>, fieldvalue={<<keyw1, keyw2>>}]
      \step[fieldsource=<<entrykey>>]
      \step[fieldset=<<note>>, origfieldval]
    }
  }
}
\end{ltxexample}
%
这一示例是对能在\texttt{examples1.bib} 和\texttt{examples2.bib} 文件中找到的条目进行处理，增加一个\bibfield{keywords} 域，域值为<keyw1, keyw2>，并且设置\bibfield{note} 域值为条目关键词。
%This would add a \bibfield{keywords} field with value <keyw1, keyw2> and set the \bibfield{note} field to the entry key to all entries which are found in either the
%\texttt{examples1.bib} or \texttt{examples2.bib} files.
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map{
      \step[fieldsource=<<title>>]
      \step[fieldset=<<note>>, origfieldval]
    }
  }
}
\end{ltxexample}
%
这一示例将\bibfield{title} 域复制给\bibfield{note} 域，除非\bibfield{note} 域已经存在。
%Copy the \bibfield{title} field to the \bibfield{note} field unless the
%\bibfield{note} field already exists.
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map{
      \step[typesource=<<chat>>, typetarget=<<customa>>, final]
      \step[fieldset=<<type>>, origentrytype]
    }
  }
}
\end{ltxexample}
%
任何\bibfield{chat} 类型的条目将变成为\bibfield{customa} 条目类型，并且自动设置\bibfield{type} 域为<chat>，除非条目中\bibfield{type} 域已经存在(\texttt{overwrite} 默认是false)。这一映射仅对\bibtype{chat} 类型的条目进行操作，因为第一步中设置了\texttt{final}，所以当\texttt{typesource} 不匹配时，\cmd{map} 过程立即终止。
%Any \bibfield{chat} entrytypes would become \bibfield{customa} entrytypes and
%would automatically have a \bibfield{type} field set to
%<chat> unless the \bibfield{type} field already exists in the entry (because
%\texttt{overwrite} is false by default). This mapping applies only to entries of type
%\bibtype{chat} since the first step has \texttt{final} set and so if the
%\texttt{typesource} does not match the entry entrytype, processing of this
%\cmd{map} immediately terminates.
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map{
      \perdatasource{<<examples.bib>>}
      \pertype{<<article>>}
      \pertype{<<book>>}
       \step[fieldset=<<abstract>>, null]
       \step[fieldset=<<note>>, fieldvalue={<<Auto-created this field>>}]
    }
  }
}
\end{ltxexample}
%
任何来自\texttt{examples.bib} 数据源，类型为\bibtype{article} 或\bibtype{book} 的条目的\bibfield{abstract} 域将删除，增加一个\bibfield{note} 域，域值为<Auto-created this field>。
%Any entries of entrytype \bibtype{article} or \bibtype{book} from the
%\texttt{examples.bib} datasource would have their \bibfield{abstract}
%fields removed and a \bibfield{note} field added with value <Auto-created this field>.
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map{
       \step[fieldset=<<abstract>>, null]
       \step[fieldsource=<<conductor>>, fieldtarget=<<namea>>]
       \step[fieldsource=<<gps>>, fieldtarget=<<usera>>]
    }
  }
}
\end{ltxexample}
%
这将删除所有条目的\bibfield{abstract} 域，将\bibfield{conductor} 域修改到\bibfield{namea} 域，将\bibfield{gps} 修改到\bibfield{usera} 域中。
%This removes \bibfield{abstract} fields from any entry, changes
%\bibfield{conductor} fields to \bibfield{namea} fields and changes \bibfield{gps}
%fields to \bibfield{usera} fields.
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map{
       \step[fieldsource=<<pubmedid>>, fieldtarget=<<eprint>>, final]
       \step[fieldset=<<eprinttype>>, origfield]
       \step[fieldset=<<userd>>, fieldvalue={<<Some string of things>>}]
    }
  }
}
\end{ltxexample}
%
仅对有\bibfield{pubmedid} 域的条目做映射，将\bibfield{pubmedid} 域映射到\bibfield{eprint} 域中，设置\bibfield{eprinttype} 值为\bibfield{pubmedid} 域的值，并且设置\bibfield{userd} 的值为字符串<Some string of things>。
%Applies only to entries with \bibfield{pubmed} fields and maps
%\bibfield{pubmedid} fields to \bibfield{eprint} fields, sets the \bibfield{eprinttype}
%field to <pubmedid> and also sets the \bibfield{userd} field to the string
%<Some string of things>.
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map{
       \step[fieldsource=<<series>>,
             match=\regexp{<<\A\d*(.+)>>},
             replace=\regexp{<<\L$1>>}]
    }
  }
}
\end{ltxexample}
%$<- to stop emacs highlighting breaking
这里的正则表示式对\bibfield{series} 域值进行处理，match中 <|\A|> 确定匹配的起始位置为字符串开始处，\cmd{d} 匹配一个数字，*表示做\cmd{d} 匹配0次或多次，即把所有从字符串起始位置的数字匹配出来，(标记一个子表达式开始，)标记一个表达式开始结束，.匹配除换行符外的任意字符，+表示做.匹配1次或任意多次，即将域值数字结束后的所有字符标记为一个子表达式。replace中\cmd{L} 表示将后面所有的字符都转换为大写或小写，\file{\$1}%$
表示引用第一组括号内表达式匹配的字符即match中()内匹配的字符，即将原来\bibfield{series} 域值中起始数字之外的字符全部转换为小写或大写\footnote{译者: 正则表达式参考:正则表达式系统教程和精通正则表达式， \cmd{A} ， \cmd{L} ，\file{\$1}%$
见精通正则表达式287,290,298页}。因为正则表达式常包含各种特殊字符，最好将其用宏\cmd{regexp} 包含起来，这样就能将其正确的传递给\biber 。
%Here, the contents of the \bibfield{series} field have leading numbers stripped and the remainder of the contents lowercased. Since regular expressions usually contain all sort of special characters, it is best to enclose them in the provided \cmd{regexp} macro as shown---this will pass the expression through to \biber\ correctly.
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map{
       \step[fieldsource=<<maintitle>>,
             match=\regexp{<<Collected\s+Works.+Freud>>},
             final]
       \step[fieldset=<<keywords>>, fieldvalue=<<freud>>]
    }
  }
}
\end{ltxexample}
%$<- to stop emacs highlighting breaking
如果一个条目中\bibfield{maintitle} 域能匹配一个特殊的正则表达式，则将设置一个特殊的keyword，利用这一keyword可以将一些特定项构成一个参考文献节。(其中<|\s|>匹配任何空白字符，包括空格、制表符、换页符。)
%Here, if for an entry, the \bibfield{maintitle} field matches a particular regular expression, we set a special keyword so we can, for example, make a references section just for certain items.
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map{
       \step[fieldsource=<<lista>>, match=\regexp{<<regexp>>}, final]
       \step[fieldset=<<lista>>, null]
    }
  }
}
\end{ltxexample}
%
如果一个条目的\bibfield{lista} 匹配正则表达式<regexp>，则删除该条目。
%If an entry has a \bibfield{lista} field which matches regular expression <regexp>, then it is removed.
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map[overwrite=false]{
       \step[fieldsource=<<author>>]
       \step[fieldset=<<editor>>, origfieldval, final]
       \step[fieldsource=<<editor>>, match=\regexp{<<\A(.+?)\s+and.*>>}, replace={<<$1>>}]
    }
  }
}
\end{ltxexample}
%$<- to stop emacs highlighting breaking
对于任何有\bibfield{author} 域的条目，将\bibfield{editor} 设置为与\bibfield{author} 相同，但如果\bibfield{editor} 已经存在则不设置并终止映射。如果完成设置，对\bibfield{editor} 进一步匹配和替换。(正则表达式的作用是截取姓名列表中第一个姓名。其match规则为从字符串开始就标记子表达式开始，在遇到空白字符和and之前标记子表达式结束，子表达式匹配任意字符，利用问号结束贪婪过程，即在第一个空白字符和and之前结束匹配。replace则表示提取第一个子表达式的匹配结果。)
%For any entry with an \bibfield{author} field, try to set
%\bibfield{editor} to the same as \bibfield{author}. If this fails because
%\bibfield{editor} already exists, stop, otherwise truncate
%\bibfield{editor} to just the first name in the name list.
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map{
       \step[fieldsource=<<author>>,
             match={<<Smith, Bill>>},
             replace={<<Smith, William>>}]
       \step[fieldsource=<<author>>,
             match={<<Jones, Baz>>},
             replace={<<Jones, Barry>>}]
    }
  }
}
\end{ltxexample}
%
这里，对同一个域使用多个匹配/替换来调整一些姓名。记住，一个\opt{map} 元素中\cmd{step} 步是按顺序处理的，后面的\cmd{step} 步是在前面各步处理结果基础上再处理。注意，当匹配字符中没有一些特殊的字符，则没有必要用\cmd{regexp} 来保护正则表达式。需要注意，因为在\LaTeX 中保护正则表达式的难度，不要在\cmd{regexp} 中出现空格，而要使用空格对应的代码。比如:
%Here, we use multiple match/replace for the same field to regularise some inconstant name variants. Bear in mind that \cmd{step} processing within a \opt{map} element is sequential and so the changes from a previous \cmd{step}s are already committed. Note that we don't need the \cmd{regexp} macro to protect the regular expressions in this example as they contain no characters which need special escaping. Please note that due to the difficulty of protecting regular expressions in \LaTeX, there should be no literal spaces in the argument to \cmd{regexp}. Please use escape code equivalents if spaces are needed. For example, this example, if using \cmd{regexp}, should be:
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map{
       \step[fieldsource=<<author>>,
             match=\regexp{<<Smith,\s+Bill>>},
             replace=\regexp{<<Smith,\x20William>>}]
       \step[fieldsource=<<author>>,
             match=\regexp{<<Jones,\s+Baz>>},
             replace=\regexp{<<Jones,\x20Barry>>}]
    }
  }
}
\end{ltxexample}
%
其中，使用了十六进制符号命令 <|\x20|> 来充当替换字符串中的空格。
%Here, we have used the hexadecimal escape sequence <|\x20|> in place of literal spaces in the replacement strings.
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map[overwrite]{
       \step[fieldsource=<<author>>, match={<<Doe,>>}, final]
       \step[fieldset=<<shortauthor>>, origfieldval]
       \step[fieldset=<<sortname>>, origfieldval]
       \step[fieldsource=<<shortauthor>>,
             match=\regexp{<<Doe,\s*(?:\.|ohn)(?:[-]*)(?:P\.|Paul)*>>},
             replace={<<Doe, John Paul>>}]
       \step[fieldsource=<<sortname>>,
             match=\regexp{<<Doe,\s*(?:\.|ohn)(?:[-]*)(?:P\.|Paul)*>>},
             replace={<<Doe, John Paul>>}]
    }
  }
}
\end{ltxexample}
%
仅对\bibfield{author} 匹配有<Doe,>的条目做处理。首先将\bibfield{author} 域复制给\bibfield{shortauthor} 和\bibfield{sortname} 域，当这两个域已存在仍然进行覆盖。然后对这两个新域做匹配和替换操作，用以规范化一个特定的姓名，因为该名字在数据源中可能有一些不同的形式。
其中<|(?:pattern)|>表示匹配pattern但不获取，第一个括号中只要是.或ohn结尾即可匹配，第二个括号中只要有-字符即可匹配，第三个括号中以P.或Paul结尾即可匹配。
%Only applies to entries with an \bibfield{author} field matching <Doe,>. First the \bibfield{author} field is copied to both the \bibfield{shortauthor} and \bibfield{sortname} fields, overwriting them if they already exist. Then, these two new fields are modified to canonicalise a particular name, which presumably has some variants in the data source.
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map[overwrite]{
      \step[fieldsource=<<verba>>, final]
      \step[fieldset=<<verbb>>, fieldvalue=<</>>, append]
      \step[fieldset=<<verbb>>, origfieldval, append]
      \step[fieldsource=<<verbb>>, final]
      \step[fieldset=<<verbc>>, fieldvalue=<</>>, append]
      \step[fieldset=<<verbc>>, origfieldval, append]
    }
  }
}
\end{ltxexample}
%
该例验证了step步的顺序特性和\opt{append} 选项。如果一个条目有\bibfield{verba} 域，首先在\bibfield{verbb} 域中增加一个斜杠，然后\bibfield{verba} 域值添加到\bibfield{verbb} 中。然后在\bibfield{verbc} 中添加一个斜杠和\bibfield{verbb} 域的值。
%This example demonstrates the sequential nature of the step processing and the \opt{append} option. If an entry has a \bibfield{verba} field then first, a forward slash is appended to the \bibfield{verbb} field. Then, the contents of \bibfield{verba} are appended to the \bibfield{verbb} field. A slash is then appended to the \bibfield{verbc} field and the contents of \bibfield{verbb} are appended to the \bibfield{verbc} field.
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map[overwrite]{
      \step[fieldset=<<autourl>>, fieldvalue={<<http://scholar.google.com/scholar?q=">>}]
      \step[fieldsource=<<title>>]
      \step[fieldset=<<autourl>>, origfieldval, append]
      \step[fieldset=<<autourl>>, fieldvalue={<<"+author:>>}, append]
      \step[fieldsource=<<author>>, match=\regexp{<<\A([^,]+)\s*,>>}]
      \step[fieldset=<<autourl>>, fieldvalue={<<$1>>}, append]
      \step[fieldset=<<autourl>>, fieldvalue={<<&as_ylo=>>}, append]
      \step[fieldsource=<<year>>]
      \step[fieldset=<<autourl>>, origfieldval, append]
      \step[fieldset=<<autourl>>, fieldvalue={<<&as_yhi=>>}, append]
      \step[fieldset=<<autourl>>, origfieldval, append]
    }
  }
}
\end{ltxexample}%$ <- keep AucTeX highlighting happy
该例假设使用\secref{aut:ctm:dm} 中的数据模型创建了一个名为\bibfield{autourl} 的域用来保存比如由条目内容自动创建的Google学术搜索地址。逐步从条目中抽取信息并构建URL。它验证了可以在后面所有的\texttt{fieldvalue} 设置中引用前面最近匹配得到的结果，如果\bibfield{author} 域格式是<family, given>，可以从中抽取姓(family name)。结果域可以用作文献表中文献的标题的一个超链接。(其中 <|[^,]+|> 匹配不包含,的任意字符并获取为\cmd{\$1}。)%$

%This example assumes you have created a field called \bibfield{autourl} using the datamodel macros from \secref{aut:ctm:dm} in order to hold, for example, a Google Scholar query URL auto-created from elements of the entry. The example progressively extracts information from the entry, constructing the URL as it goes. It demonstrates that it is possible to refer to parenthetical matches from the most recent \texttt{match} in any following \texttt{fieldvalue} which allows extracting the family name from the \bibfield{author}, assuming a <family, given> format. The resulting field could then be used as a hyperlink from, for example, the title of the work in the bibliography.
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map{
      \step[fieldsource=<<title>>, match={A Title}, final]
      \step[entrynull]
    }
  }
}
\end{ltxexample}
%
当条目的\bibfield{title} 匹配<A Title>时，忽略该条目(它将不出现在参考文献数据中)。
%Any entry with a \bibfield{title} field matching <A Title> will be completely ignored.
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map{
      \pernottype{book}
      \pernottype{article}
      \step[entrynull]
    }
  }
}
\end{ltxexample}
%
当条目不是\bibtype{book} 或\bibtype{article} 类型将被忽略。
%Any entry which is not a \bibtype{book} or \bibtype{article} will be ignored.
%
\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=bibtex]{
    \map{
      \perdatasource{<<biblatex-examples.bib>>}
      \step[entryclone={rel-}]
    }
  }
}
\end{ltxexample}
%
数据源中的条目将被复制。复制条目的关键词为原条目关键词加上\texttt{entryclone} 参数给出的前缀。复制的条目在文档中以其新的关键词进行引用。这种类型的映射需要谨慎使用，因为标签生成可能产生问题，比如在作者年制使用\opt{extrayear} 时。一种应用情况是在顺序编码制中多个文献表包含相同的条目时需要为这一相同同条目生成不同的序号标签。当需要对一个条目生成不同的标签时，这是很麻烦的，而创建具有不同关键词的副本条目能解决这一问题。
%Here, a clone of an entry from the specified data source will be created. The entry key of the clone will be the same as the original but prefixed by the value of the \texttt{entryclone} parameter. The cloned entry would still need to be cited in the document using its new entry key. This type of mapping step should be used with care as it may produce labelling problems in authoryear styles which use, for example, \opt{extrayear}. One use case is for numeric styles which contain multiple bibliographies containing the same entry. In this case, you may need different bibliography number labeld for the same entry and this is very tricky when there is only one entry which needs different labels. Creating clones with different entry keys solves this problem.

\biblatexml\ 数据源比\bibtex\ 更具结构性，因为它们是XML。源的映射也可以对其处理，但源和目标的设置需要支持XPath 1.0路径以便能够处理结构化数据。域的设置可以利用上述的示例，必要时可以转换为XPath 1.0的内部访问方式。比如:
%\biblatexml\ datasources are more structured than \bibtex\ since they are XML. Sourcemapping is possible with \biblatexml\ too but the specifications of source and target fields etc. also support XPath 1.0 paths in order to be able to work with the structured data. Fields can be specified as per the \bibtex\ examples above and these are converted into XPath 1.0 queries internally as necessary. For example:

\begin{ltxexample}
\DeclareSourcemap{
  \maps[datatype=biblatexml]{
    \map{
   \step[fieldsource=\regexp{./bltx:names[@type='author']/bltx:name[2]/bltx:namepart[@type='family']},
      match=\regexp{\ASmith},
      replace={Jones}]
    }
    \map{
      \step[fieldsource=editor, fieldtarget=translator]
    }
    \map{
      \step[fieldsource=\regexp{./bltx:names[@type='editor']},
            fieldtarget=\regexp{./bltx:names[@type='translator']}]
    }
    \map{
      \step[fieldset=\regexp{./bltx:names[@type='author']/bltx:name[2]/@useprefix},
            fieldvalue={false}]
    }
  }
}
\end{ltxexample}
%
%These maps, respectively,
这些映射，分别为:
\begin{itemize}
\item 将\bibfield{author} 域的第二个姓名的姓<Smith>替换为<Jones>。
%Replace the family name <Smith> of the second \bibfield{author} name with <Jones>
\item 将\bibfield{editor} 域值设置到\bibfield{translator}。
%Move the \bibfield{editor} to \bibfield{translator}
\item 将\bibfield{editor} 域值设置到\bibfield{translator}，但使用显式的XPaths。这和第二个映射操作结果是一样的。
%Move the \bibfield{editor} to \bibfield{translator} but with explicit XPaths
\item 将\bibfield{author} 域的姓名列表\opt{useprefix} 选项设置为<false>。
%Set the per-namelist \opt{useprefix} option on the \bibfield{author} name list to <false>
\end{itemize}

\subsubsection{数据模型规范}%Data Model Specification
\label{aut:ctm:dm}
\biblatex 使用的数据模型包括4个主要元素:
%The data model which \biblatex uses consists of four main elements:

\begin{itemize}
\item 字符串和字符串列表常量规范
%Specification of constant strings and lists of strings
\item 有效条目类型规范
%Specification of valid Entrytypes
\item 域及其类型、数据类型和其它特殊标识的规范
%Specification of valid Fields along with their type, datatype and any special flags
\item 在什么条目中什么域有效的规范
%Specification of which Fields are valid in which Entrytypes
\item 可用于根据数据模型验证数据的约束规范
%Specification of constraints which can be used to validate data against the data model
\end{itemize}

默认数据模型在核心\biblatex 文件\file{blx-dm.def} 中定义，使用本节给出的宏。默认数据模型详见\secref{bib} 节。数据模型由\biblatex 及后端在内部使用。在实际中，改变数据模型意味着为数据源定义条目类型和域，并可根据数据模型进行验证。自然，这通常只有在样式能支持新的条目类型时有用，并且也可能引起样式间的可移植性问题。(尽管这一问题可以使用\secref{aut:ctm:map} 节介绍的动态数据修改来解决。)
%The default data model is defined in the core \biblatex file \file{blx-dm.def} using the macros described in this section. The default data model is described in detail in \secref{bib}. The data model is used internally by \biblatex and also by the backend. In practice, changing the data model means that you can define the entrytypes and fields for your datasources and validate your data against the data model. Naturally, this is not much use unless your style supports any new entrytypes or fields and it raises issues of portability between styles (although this can be mitigated by using the dynamic data modification functionality described in \secref{aut:ctm:map}).

Note that while the \biber/\bibtex input site is not case sensitive when it comes to entry types and field names (Perl's Unicode case folding is used to normalise field names and entry types), the \latex side is case sensitive and uses the exact capitalisation from the data model.
根据数据模型验证意味着，将数据源映射到数据模型后，\biber (使用\path{--validate_datamodel} 选项)可以检查:
%Validation against the data model means that after mapping your data sources into the data model, \biber (using its \path{--validate_datamodel} option) can check:

\begin{itemize}
\item 所有条目类型是否都有效
%Whether all entrytypes are valid entrytypes
\item 所有的域对于其所属的条目类型是否有效
%Whether all fields are valid fields for their entrytype
\item 域是否都满足指定的不同格式约束
%Whether the fields obey various constraints on their format which you specify
\end{itemize}
%
重定义数据模型可以在多个地方进行。样式作者可以创建一个\file{.dbx} 文件包含需要的数据模型宏，该文件将在\biblatex 宏包根据\opt{style} 选项加载\file{.cbx} 和\file{.bbx} 样式文件后搜索\file{.dbx} 文件来加载\footnote{译者: 可用来定义标准和报纸文章两类条目，但实际上利用数据动态修改可能更为方便}。如果不使用\opt{style} 选项，而使用\opt{citestyle} 和\opt{bibstyle} 选项，宏包将会搜索文件\file{$<$citestyle$>$.dbx} 和\file{$<$bibstyle$>$.dbx} 并加载。另一种方式，数据模型文件名可以不同于样式选项名，但扩展名必须是\file{.dbx}，该文件由\opt{datamodel} 包选择加载。在加载完样式的数据模型文件之后，\biblatex 寻找并加载\sty{biblatex-dm.cfg} 配置文件，类似于加载\sty{biblatex.cfg} 的方式。总之，最终数据模型由从这些地方加入的数据模型确定，顺序是:
%Redefining the data model can be done in several places. Style authors can create a \file{.dbx} file which contains the data model macros required and this will be loaded automatically when using the \biblatex package \opt{style} option by looking for a file named after the style with a \file{.dbx} extension (just like the \file{.cbx} and \file{.bbx} files for a style). If the \opt{style} option is not used but rather the \opt{citestyle} and \opt{bibstyle} options, then the package will try to load \file{.dbx} files called \file{$<$citestyle$>$.dbx} and \file{$<$bibstyle$>$.dbx}.
%Alternatively, the name of the data model file can be different from any of the style option names by specifying the name (without \file{.dbx} extension) to the package \opt{datamodel} option. After loading the style data model file, \biblatex then loads, if present, a users \file{biblatex-dm.cfg} which should be put somewhere \biblatex can find it, just like the main configuration file \sty{biblatex.cfg}. To summarise, the data model is determined by adding to the data model from each of these locations, in order:\\

\noindent\file{blx-dm.def}$\rightarrow$\\
\hspace*{1em}\file{$<$datamodel option$>$.dbx} $\rightarrow$\\
\hspace*{2em}\file{$<$style option$>$.dbx} $\rightarrow$\\
\hspace*{3em}\file{$<$citestyle option$>$.dbx} and \file{$<$bibstyle option$>$.dbx} $\rightarrow$\\
\hspace*{4em}\file{biblatex-dm.cfg}\\

在导言区使用宏来加载数据模型是不行的，因为导言内容是在\biblatex 根据数据模型定义关键的内部宏之后读取。在正文中定义的任何数据模型宏都将被忽略并给出一个警告。数据模型由如下宏来定义:
%\noindent It is not possible to add to a loaded data model by using the macros below in your preamble as the preamble is read after \biblatex has defined critical internal macros based on the data model. If any data model macro is used in a document, it will be ignored and a warning will be generated. The data model is defined using the following macros:

\begin{ltxsyntax}

\cmditem{DeclareDatamodelConstant}[options]{name}{constantdef}

声明\prm{name} 作为一个数据模型常量，其定义为\prm{constantdef}。这种常量通常由\biber 在内部使用。
%Declares the \prm{name} as a datamodel constant with definition \prm{constantdef}. Such constants are typically used internally by \biber.

\begin{optionlist*}

\choitem[string]{type}{string, list}

一个常量可以是一个简单的字符串(默认情况下，如果\prm{type} 选项忽略的话)或者一个逗号分隔的字符串列表。
%A constant can be a simple string (default if the \prm{type} option is omitted) or a comma"=separated list of strings.

\end{optionlist*}

\cmditem{DeclareDatamodelEntrytypes}[options]{entrytypes}

声明\prm{entrytypes} 的一个逗号分隔列表，表示数据模型中的有效条目类型。依旧如同在\tex 的csv列表中，请确保每个元素都紧跟着一个逗号或者结束的括号，即不需要额外的空格。
%Declares the comma"=separated list of \prm{entrytypes} to be valid entrytypes in the data model. As usual in \tex csv lists, make sure each element is immediately followed by a comma or the closing brace---no extraneous whitespace.

\begin{optionlist*}

\boolitem[false]{skipout}

该条目类型不输出到\file{.bbl} 中。通常用于后端处理和使用的特殊条目类型比如\bibtype{xdata} 等。
%This entrytype is not output to the \file{.bbl}. Typically used for special entrytypes which are processed and consumed by the backend such as \bibtype{xdata}.

\end{optionlist*}

\cmditem{DeclareDatamodelFields}[options]{fields}

声明\prm{fields} 的一个逗号分隔列表，表示数据模型中与逗号分隔\prm{options} 列表相关的有效域。\prm{type} 和\prm{datatype} 选项是必须的，全部有效选项如下:
%Declares the comma"=separated list of \prm{fields} to be valid fields in the data model with associated comma"=separated \prm{options}. The \prm{type} and \prm{datatype} options are mandatory. All valid \prm{options} are:

\begin{optionlist*}

\valitem{type}{field type}

设置域的类型，典型如<field>或<list>，详见\secref{bib:fld:typ} 节。
%Set the type of the field as described in \secref{bib:fld:typ}, typically <field> or <list>.

\valitem{format}{field format}

该域的任意特殊格式。正常情况下不给出但获取<xsv>值，该值告诉\biber 该域具有多值格式。准确的分隔符由\biber 选项\opt{xsvsep} 控制，默认是由可选的空格包围的逗号。
%Any special format of the field. Normally unspecified but can take the value <xsv> which tells \biber that this field has a separated values format. The exact separator can be controlled with the \biber option \opt{xsvsep} and defaults to the expected comma surrounded by optional whitespace.

\valitem{datatype}{field datatype}

设置域的数据类型，典型如 <name>或<literal>，详见\secref{bib:fld:typ} 节。
%Set the datatype of the field as described in \secref{bib:fld:typ}. For example, <name> or <literal>.

\boolitem[false]{nullok}

该域可以定义为空。
%The field is allowed to be defined but empty.

\boolitem[false]{skipout}

该域不输出到\file{.bbl} 中因此不会出现在\biblatex 样式处理中。依旧如同在\tex 的csv列表中，请确保每个元素都紧跟着一个逗号或者结束的括号，即不需要额外的空格。
%The field is not output to the \file{.bbl} and is therefore not present during \biblatex style processing. As usual in \tex csv lists, make sure each element is immediately followed by a comma or the closing brace---no extraneous whitespace.

\boolitem[false]{label}

该域可以用作文献表的标签。设置该选项会使得\biblatex 为该域创建多个辅助宏，所以存在一些已经定义的内部长度和标题等。
%The field can be used as a label in a bibliography or bibliography list. Specifying this causes \biblatex to create several helper macros for the field so that there are some internal lengths and headings etc. defined.

\end{optionlist*}

\cmditem{DeclareDatamodelEntryfields}[entrytypes]{fields}

声明\prm{fields} 列表对于\prm{entrytypes} 列表是有效的。如果\prm{entrytypes} 不给出，则列表中的这些域对所有条目类型都有效。依旧如同在\tex 的csv列表中，请确保每个元素都紧跟着一个逗号或者结束的括号，即不需要额外的空格。
%Declares that the comma"=separated list of \prm{fields} is valid for the comma"=separated list of \prm{entrytypes}. If \prm{entrytypes} is not given, the fields are valid for all entrytypes. As usual in \tex csv lists, make sure each element is immediately followed by a comma or the closing brace---no extraneous whitespace.

\cmditem{DeclareDatamodelConstraints}[entrytypes]{specification}

如果给出\prm{entrytypes} 的逗号分隔列表，约束仅应用于这些条目。\prm{specification} 是\cmd{constraint} 指令的不分隔列表。为实现良好的代码显示效果，可以自由使用空格、制表符、行末符号来整理\prm{specification} 中的代码，但空行不能使用。
%If a comma"=separated list of \prm{entrytypes} is given, the constraints apply only to those entrytypes. The \prm{specification} is an undelimited list of \cmd{constraint} directives which specify a constraint. Spaces, tabs, and line endings may be used freely to visually arrange the \prm{specification}. Blank lines are not permissible.

\cmditem{constraint}[type=constrainttype]{elements}

指定\prm{constrainttype} 类型的约束，有效的约束类型有:
%Specifies a constraint of type \prm{constrainttype}. Valid constraint types are:

\begin{optionlist*}

\choitem{type}{data, mandatory, conditional}

<data>类型的约束，应用于域的值。<mandatory>类型的约束，指定一个条目类型应具有的域或域的组合。<conditional>类型的约束允许更复杂的条件和量化的域约束。
%Constraints of type <data> put restrictions on the value of a field. Constraints of type <mandatory> specify which fields or combinations of fields an entrytype should have. Constraints of type <conditional> allow more sophisticated conditional and quantified field constraints.

\choitem{datatype}{integer, isbn, issn, ismn, date, pattern}

用于\prm{data} 类型约束，限制域的值为给定的数据类型。
%For constraints of type \prm{data}, constrain field values to be the given datatype.

\valitem{rangemin}{num}

用于\prm{data} 类型和<integer>数据类型的约束，限制域的值最小为\prm{num}。
%For constraints of \prm{type} <data> and \prm{datatype} <integer>, constrain field values to be at least \prm{num}.

\valitem{rangemax}{num}

用于\prm{data} 类型和<integer>数据类型的约束，限制域的值最大为\prm{num}。
%For constraints of \prm{type} <data> and \prm{datatype} <integer>, constrain field values to be at most \prm{num}.

\valitem{pattern}{patt}

用于\prm{data} 类型和<pattern>数据类型的约束，限制域的值匹配正则表达式\prm{patt}。最好利用\cmd{regexp} 宏将正则表达式包围起来，见\secref{aut:ctm:map} 节。
%For constraints of \prm{type} <data> and \prm{datatype} <pattern>, constrain field values to match regular expression pattern \prm{patt}. It is best to wrap any regular expression in the macro \cmd{regexp}, see \secref{aut:ctm:map}.

\end{optionlist*}

一个\cmd{constraint} 宏可以包括如下任意内容:
%A \cmd{constraint} macro may contain any of the following:

\cmditem{constraintfieldsor}{fields}

用于<mandatory>类型的约束，指定一个条目必须包含\cmd{constraintfield}s的一个布尔或(OR)。
%For constraints of \prm{type} <mandatory>, specifies that an entry must contain a boolean OR of the \cmd{constraintfield}s.

\cmditem{constraintfieldsxor}{fields}

用于<mandatory>类型的约束，指定一个条目必须包含\cmd{constraintfield}s的一个布尔异或(XOR)。
%For constraints of \prm{type} <mandatory>, specifies that an entry must contain a boolean XOR of the \cmd{constraintfield}s.

\cmditem{antecedent}[quantifier=quantspec]{fields}

用于<conditional>类型的约束，指定一个在约束的\cmd{consequent} 检查之前必须满足\cmd{constraintfield}s的量化集。\prm{quantspec} 应包含如下值:
%For constraints of \prm{type} <conditional>, specifies a quantified set of \cmd{constraintfield}s which must be satisfied before the \cmd{consequent} of the constraint is checked. \prm{quantspec} should have one of the following values:

\begin{optionlist*}

\choitem{quantifier}{all, one, none}

指定要满足条件约束前提，必须给出的\cmd{antecedent} 内的\cmd{constrainfield} 数量。
%Specifies how many of the \cmd{constrainfield}'s inside the \cmd{antecedent} have to be present to satisfy the antecedent of the conditional constraint.

\end{optionlist*}

\cmditem{consequent}[quantifier=quantspec]{fields}

用于<conditional>类型的约束，指定如果满足前面约束的\cmd{antecedent} 时必须满足的\cmd{constraintfield}s量化集。\prm{quantspec} 应包含如下值:
%For constraints of \prm{type} <conditional>, specifies a quantified set of \cmd{constraintfield}s which must be satisfied if the preceding \cmd{antecedent} of the constraint was satisfied. \prm{quantspec} should have one of the following values:

\begin{optionlist*}

\choitem{quantifier}{all, one, none}

指定要满足的条件约束后件，必须给出的\cmd{consequent} 内的\cmd{constrainfield} 数量。
%Specifies how many of the \cmd{constraintfield}'s inside the \cmd{consequent} have to be present to satisfy the consequent of the conditional constraint.

\end{optionlist*}

\cmditem{constraintfield}{field}

对于<data>类型的约束，约束应用于该\prm{field}。对于<mandatory>类型的约束，条目必须包含\prm{field}。

%For constraints of \prm{type} <data>, the constraint applies to this \prm{field}. For constraints of \prm{type} <mandatory>, the entry must contain this \prm{field}.

数据模型声明宏可以应用多次，用于在前面定义基础上增加定义。如果要替换，修改或移除已有的定义(比如\biblatex 加载的默认模型)，需要利用下面的宏重设(清除)当前的定义然后再重设。通常，这些宏在任何\file{biblatex-dm.cfg} 文件中都是首先给出的:
%The data model declaration macros may be used multiple times as they append to the previous definitions. In order to replace, change or remove existing definitions (such as the default model which is loaded with \biblatex), you should reset (clear) the current definition and then set what you want using the following macros. Typically, these macros will be the first things in any \file{biblatex-dm.cfg} file:

\cmditem{ResetDatamodelEntrytypes}

清除所有的数据模型entrytype信息
%Clear all data model entrytype information.

\cmditem{ResetDatamodelFields}

清除所有的数据模型field信息
%Clear all data model field information.

\cmditem{ResetDatamodelEntryfields}

清除所有的数据模型entrytypes的fields信息
%Clear all data model fields for entrytypes information.

\cmditem{ResetDatamodelConstraints}

清除所有的数据模型fields约束信息
%Clear all data model fields Constraints information.

\end{ltxsyntax}

下面是一个简单的数据模型示例。默认数据模型设置参见\biblatex 核心文件\file{blx-dm.def}。
%Here is an example of a simple data model. Refer to the core \biblatex file \file{blx-dm.def} for the default data model specification.

\begin{ltxexample}
\ResetDatamodelEntrytypes
\ResetDatamodelFields
\ResetDatamodelEntryfields
\ResetDatamodelConstraints

\DeclareDatamodelEntrytypes{<<entrytype1, entrytype2>>}

\DeclareDatamodelFields[type=field, datatype=literal]{<<field1,field2,field3,field4>>}

\DeclareDatamodelEntryfields{<<field1>>}
\DeclareDatamodelEntryfields[entrytype1]{<<field2,field3>>}
\DeclareDatamodelEntryfields[entrytype2]{<<field2,field3,field4>>}

\DeclareDatamodelConstraints[<<entrytype1>>]{
  \constraint[type=data, datatype=integer, rangemin=3, rangemax=10]{
    \constraintfield{<<field1>>}
  }
  \constraint[type=mandatory]{
    \constraintfield{<<field1>>}
    \constraintfieldsxor{
      \constraintfield{<<field2>>}
      \constraintfield{<<field3>>}
    }
  }
}
\DeclareDatamodelConstraints{
  \constraint[type=conditional]{
    \antecedent[quantifier=none]{
      \constraintfield{<<field2>>}
    }
    \consequent[quantifier=all]{
      \constraintfield{<<field3>>}
      \constraintfield{<<field4>>}
    }
  }
}
\end{ltxexample}
%
该模型设置了:
%This model specifies:

\begin{itemize}
\item 清除所有默认的数据模型
%Clear the default data model completely
\item 设置两种有效的条目类型\bibtype{entrytype1} and \bibtype{entrytype2}
%Two valid entry types \bibtype{entrytype1} and \bibtype{entrytype2}
\item 设置四个有效的literal域。
%Four valid literal field fields
\item 设置\bibfield{field1} 对所有条目类型都有效。
%\bibfield{field1} is valid for all entrytypes
\item 设置\bibfield{field2} 和\bibfield{field3} 对\bibfield{entrytype1} 有效。
%\bibfield{field2} and \bibfield{field3} are valid for \bibfield{entrytype1}
\item 设置\bibfield{field2}, \bibfield{field3} 和\bibfield{field4} 对\bibfield{entrytype2} 有效。
%\bibfield{field2}, \bibfield{field3} and \bibfield{field4} are valid for \bibtype{entrytype2}
\item 设置\bibtype{entrytype1} 的约束:
%For \bibtype{entrytype1}:
  \begin{itemize}
  \item \bibfield{field1} 必须是一个3和10之间的整数
  %\bibfield{field1} must be an integer between 3 and 10
  \item \bibfield{field1} 必须给出
  %\bibfield{field1} must be present
  \item \bibfield{field2} 或\bibfield{field3} 其中之一必须唯一给出。
  %One and only one of \bibfield{field2} or \bibfield{field3} must be present
  \end{itemize}
\item 对于所有类型，\bibfield{field2} 如果不给出，\bibfield{field3} 和\bibfield{field4} 必须要给出。
%For any entrytype, if \bibfield{field2} is not present, \bibfield{field3} and \bibfield{field4} must be present
\end{itemize}

\subsubsection{标签}%Labels
\label{aut:ctm:lab}
字母顺序制样式使用一个标签来区分参考文献条目。这个标签使用一个描述怎么构建标签的模板由条目的内容构建。该模板可以全局自定义或者根据具体条目类型定义。如何抽取姓名域的成分作为标签则使用一个独立的模板，因为姓名域是相当复杂的域。
%标签的自定义需要用\biber 后端程序而不能用其它后端程序。
%Alphabetic styles use a label to identify bibliography entries. This label is constructed from components of the entry using a template which describes how to build the label. The template can be customised on a global or per-type basis. A separate template is used to specify how to extract parts of name fields for labels, since names can be quite complex fields.

\begin{ltxsyntax}

\cmditem{DeclareLabelalphaTemplate}[entrytype, \dots]{specification}

为指定的条目类型定义字母顺序制标签模板。如果第一个参数中不指定具体的条目类型，则定义的是通用标签模板。\prm{specification} 是\cmd{labelelement} 指令的一个无分隔列表，用来指定构建标签的元素。为实现良好的代码显示效果，可以自由使用空格、制表符、行末符号来整理\prm{specification} 中的代码，但空行不能使用。该命令仅可在导言区使用。
%Defines the alphabetic label template for the given entrytypes. If no entrytypes are specified in the first argument, then the global label template is defined. The \prm{specification} is an undelimited list of \cmd{labelelement} directives which specify the elements used to build the label. Spaces, tabs, and line endings may be used freely to visually arrange the \prm{specification}. Blank lines are not permissible. This command may only be used in the preamble.

\cmditem{labelelement}{elements}

指定用于构建标签的元素。\prm{elements} 是一个\cmd{field} 或\cmd{literal} 命令构成的无分隔列表，这些命令以它们给出的顺序进行处理。从第一个展开为非空字符串的\cmd{field} 或\cmd{literal} 作为\cmd{labelelement} 展开内容开始，后面的\cmd{labelelement} 如果存在的话，接着进行处理。
%Specifies the elements used to build the label. The \prm{elements} are an undelimited list of \cmd{field} or \cmd{literal} commands which are evaluated in the order in which they are given. The first \cmd{field} or \cmd{literal} which expands to a non-empty string is used as the \cmd{labelelement} expansion and the next \cmd{labelelement}, if any, is then processed.

\cmditem{field}[options]{field}

如果\prm{field} 非空，并作为当前标签的\cmd{labelelement}，那么受如下选项约束。\prm{field} 的有用参数通常是姓名列表类型的域、日期域和标题域。可以使用虚域`citekey'来将引用关键词作为标签的一部分。姓名列表域需要特殊处理，当给出一个姓名列表域时，用\cmd{DeclareLabelalphaNameTemplate} 命令定义的模板用来从姓名中抽取某些部分，并返回字符串给\cmd{field} 选项使用。
%If \prm{field} is non-empty, use it as the current label \cmd{labelelement}, subject to the options below. Useful values for \prm{field} are typically the name list type fields, date fields, and title fields. You may also use the `citekey' pseudo-field to specify the citation key as part of the label. Name list fields are treated specially and when a name list field is specified, the template defined with \cmd{DeclareLabelalphaNameTemplate} is used to extract parts from the name which then returns the string that the \cmd{field} option uses.

\begin{optionlist*}

\boolitem[false]{final}

该选项标记一个\cmd{field} 指令作为\prm{specification} 中的最后一个。如果\prm{field} 非空，该域用于标签中，\prm{specification} 中后面的剩余内容将被忽略。简写形式\opt{final} 等价于\kvopt{final}{true}。
%This option marks a \cmd{field} directive as the final one in the \prm{specification}. If the \prm{field} is non-empty, then this field is used for the label and the remainder of the \prm{specification} will be ignored. The short form \opt{final} is equivalent to \kvopt{final}{true}.

\boolitem[false]{lowercase}

将从域中得到标签内容转换为小写。默认情况下，直接从域的源数据中取出的内容大小写形式不做改变。
%Forces the label part derived from the field to lowercase. By default, the case is taken from the field source and not modified.

\intitem[1]{strwidth}

使用的\prm{field} 的固定字符数。当从一个姓名中抽取字符时，该设置可能会被一个独立的姓名成分覆盖，见下面的\cmd{DeclareLabelalphaNameTemplate}。
%The number of characters of the \prm{field} to use. This setting may be overridden by an individual name part when extracting characters from a name. See \cmd{DeclareLabelalphaNameTemplate} below.

\choitem[left]{strside}{left, right}

取\texttt{strwidth} 数量字符开始的方向。当从一个姓名中抽取字符时，该设置可能会被一个独立的姓名成分覆盖，见下面的\cmd{DeclareLabelalphaNameTemplate}。
%The side of the string from which to take the \texttt{strwidth} number of characters. This setting may be overridden by an individual name part when extracting characters from a name. See \cmd{DeclareLabelalphaNameTemplate} below.

\choitem[right]{padside}{left, right}

当使用\texttt{padchar} 选项时，向标签部分添加衬垫字符的方向。仅用于固定宽度标签字符串(\texttt{strwidth})。
%Side to pad the label part when using the \texttt{padchar} option. Only for use with fixed-width label strings (\texttt{strwidth}).

\valitem{padchar}{character}

如果存在，则将在标签部分的\texttt{padside} 侧添加衬垫字符直到字符串长度为\texttt{strwidth}，仅用于固定宽度标签字符串(\texttt{strwidth})。
%If present, pads the label part on the \texttt{padside} side with the specified character to the length of \texttt{strwidth}. Only for use with fixed-width label strings (\texttt{strwidth}).

\boolitem[false]{uppercase}

将从域中得到标签内容转换为大写。默认情况下，直接从域的源数据中取出的内容大小写形式不做改变。
%Forces the label part derived from the field to uppercase. By default, the case is taken from the field source and not modified.

\boolitem[false]{varwidth}

使用一个宽度变量，并从\prm{field} 返回的字符串的左侧开始抽取字符。字符串的长度由要区分标签相同位置上字符串所需的最小长度来确定。对于姓名列表域，这意味着每个姓名的子字符串要与姓名列表中相同位置的所以其他姓名的字符串相区别(见下面示例)。该选项会覆盖\texttt{strwidth}，如果两者同时用。简写形式\opt{varwidth} 等价于\kvopt{varwidth}{true}。对于姓名列表域，设置\opt{pre} 选项的\cmd{namepart}s将添加在非歧义化过程返回的字符串前面。
%Use a variable width, left-side substring of characters from the string returned for \prm{field}. The length of the string is determined by the minimum length needed to disambiguate the substring from all other \prm{field} elements in the same position in the label. For name list fields, this means that each name substring is disambiguated from all other name substrings which occur in the same position in the name list (see examples below). This option overrides \texttt{strwidth} if both are used. The short form \opt{varwidth} is equivalent to \kvopt{varwidth}{true}. For name list fields, the \cmd{namepart}s with the \opt{pre} option set are prepended to the string returned from this disambiguation.

\boolitem[false]{varwidthnorm}

类似\texttt{varwidth}，但使得\prm{field} 的可区分子字符串长度为最长的子字符串。这可以用于调整标签的格式，如果需要的话。该选项覆盖\texttt{strwidth}，如果两者同时用的话。简写形式\opt{varwidthnorm} 等价于\kvopt{varwidthnorm}{true}。
%As \texttt{varwidth} but will force the disambiguated substrings for the \prm{field} to be the same length as the longest disambiguated substring. This can be used to regularise the format of the labels if desired. This option overrides \texttt{strwidth} if both are used. The short form \opt{varwidthnorm} is equivalent to \kvopt{varwidthnorm}{true}.

\boolitem[false]{varwidthlist}

当域作为一个整体能与在标签相同位置的所有其它域区分时，标签自动非歧义化的替代方法。对于非姓名列表域，这等价于\texttt{varwidth}。对于姓名列表域，姓名列表中某一相同位置的姓名无法区分，但整个列表可以区分。该选项覆盖\texttt{strwidth}，如果两者同时用。简写形式\opt{varwidthlist} 等价于\kvopt{varwidthlist}{true}。对于姓名列表域，设置\opt{pre} 选项的\cmd{namepart}s将添加在从非歧义化过程返回的字符串前面。
%Alternative method of automatic label disambiguation where the field as a whole is disambiguated from all other fields in the same label position. For non-name list fields, this is equivalent to \texttt{varwidth}. For name list fields, names in a name list are not disambiguated from other names in the same position in their name lists but instead the entire name list is disambiguated as a whole from other name lists (see examples below). This option overrides \texttt{strwidth} if both are used. The short form \opt{varwidthlist} is equivalent to \kvopt{varwidthlist}{true}.  For name list fields, the \cmd{namepart}s with the \opt{pre} option set are prepended to the string returned from this disambiguation.

\intitem{strwidthmax}

当使用\texttt{varwidth}，该选项在可变宽度子字符串上设置一个限制(在字符数上)。
%When using \texttt{varwidth}, this option sets a limit (in number of characters) on the length of variable width substrings. This option can be used to regularise the label.

\intitem[1]{strfixedcount}

当使用\texttt{varwidthnorm}，至少存在\texttt{strfixedcount} 个可区分子字符串具有相同的最大长度来促使所有的可区分字符串具有该最大长度。
%When using \texttt{varwidthnorm}, there must be at least \texttt{strfixedcount} disambiguated substrings with the same, maximal length to trigger the forcing of all disambiguated substrings to this same maximal length.

\valitem{ifnames}{range}

当一个姓名列表域具有的姓名数在\texttt{ifnames} 范围内，仅使用这一\cmd{field} 设置。这允许\cmd{labelelement} 可以有姓名长度条件(见下面的示例)。范围可以设置如下:
%Only use this \cmd{field} specification if it is a name list field with a number of names matching the \texttt{ifnames} range value. This allows a \cmd{labelelement} to be conditionalised on name length (see below). The range can specified as in the following examples:

\begin{lstlisting}[language=xml]
ifnames=3     -> Only apply to name lists containing exactly 3 names
ifnames={2-4} -> Only apply to name lists containing minimum 2 and maximum 4 names
ifnames={-3}  -> Only apply to name lists containing at most 3 names
ifnames={2-}  -> Only apply to name lists containing at least 2 names
\end{lstlisting}

\valitem{names}{range}

默认情况下，对于姓名列表域，使用姓名从第一个姓名开始到\cnt{maxalphanames}\slash \cnt{minalphanames} 截止。该选项可以覆盖该设置为一个显式的姓名范围。加号<+>是一个特殊范围终止标记代表max/minalphanames的截断点。范围分隔符可以是任意的数字字符和统一码(unicode)破折号。例如:
%By default, for name list fields, the names used range from the first name to the \cnt{maxalphanames}\slash \cnt{minalphanames} truncation. This option can be used to override this with an explicit range of names to consider. The plus <+> sign is a special end of range marker denoting the truncation point of max/minalphanames. The range separator can be any number of characters with the Unicode Dash property. For example:

\begin{lstlisting}[language=xml]
name=3     -> Use first 3 names in the name list
name={2-3} -> Use second and thirds names only
name={-3}  -> Same as 1-3
name={2-}  -> Use all names starting with the second name (ignoring max/minalphanames truncation)
name={2-+} -> Use all names starting with the second name (respecting max/minalphanames truncation)
\end{lstlisting}

\valitem[empty]{namessep}{string}

在姓名列表的姓名之间插入任意的分隔字符串。
%An arbitrary string separator to put between names in a namelist.

\boolitem[false]{noalphaothers}

默认情况下，当姓名列表中的姓名数大于标签中显示的姓名数时，\cmd{labelalphaothers} 附加在由姓名列表得到的标签部分后面。该选项可以关闭这一默认方式。
%By default, \cmd{labelalphaothers} is appended to label parts derived from name lists if there are more names in the list than are shown in the label part. This option can be used to disable the default behaviour.

\end{optionlist*}

\cmditem{literal}{characters}

在标签的当前位置插入文本\prm{characters}。
%Insert the literal \prm{characters} into the label at this point.

\end{ltxsyntax}
%
当一个姓名列表域已经给出，从中抽取字符串的方法由一个独立模板给出，该模板由如下命令设置:
%When a name list \cmd{field} is specified, the method of extracting the string is specified by a separate template specified by the following command:

\begin{ltxsyntax}

\cmditem{DeclareLabelalphaNameTemplate}[name]{specification}


%Defines the \opt{labelalphaname} template \prm{name}. The \prm{name} is optional and defaults to \prm{<global>}.
%Such templates specify how to extract a label string from a name list when a \cmd{field} specification in \cmd{DeclareLabelalphaTemplate} contains a name list.

定义\opt{labelalphaname}模板\prm{name}。\prm{name}是可选的默认是\prm{<global>}。
当\cmd{DeclareLabelalphaTemplate}的\cmd{field}设置中包含一个姓名列表时，这些模板可以确定从姓名列表中抽取标签字符串的方式。

%老版本信息
%\cmditem{DeclareLabelalphaNameTemplate}[entrytype, \dots]{specification}
%当\cmd{DeclareLabelalphaTemplate} 中的一个\cmd{field} 设置包含有一个姓名列表时，由该命令指出从姓名列表中抽取标签字符串的模板。该模板可以根据具体的条目类型定义。

\cmditem{namepart}[options]{namepart}

\prm{namepart} 是由\cmd{DeclareDatamodelConstant} 命令定义的数据模型的姓名成分之一(见\secref{aut:bbx:drv} 节)。选项有:
%\prm{namepart} is one of the datamodel nameparts defined with the \cmd{DeclareDatamodelConstant} command (see \secref{aut:bbx:drv}). The \opt{options} are:

\begin{optionlist*}

\boolitem[false]{use}

当存在一个相应的选项\opt{use<namepart>}(比如\opt{useprefix})并且值为true，仅使用\prm{namepart} 用于构建标签信息。
%Only use the \prm{namepart} in constructing the label information if there is a corresponding option \opt{use<namepart>} and that option is true.

\boolitem[false]{pre}

当从姓名构建标签字符串时，无\opt{pre} 选项的\cmd{namepart} 将用于构建标签字符串，通过非歧义化处理过程，实施由\cmd{DeclareLabelalpaTemplate} 中的\cmd{field} 选项指定的子字符串操作。然后有\opt{pre} 选项的\cmd{namepart} 将会添加在结果前面(当存在多个这种\cmd{namepart} 时，按给出的顺序处理)。这就允许在姓名标签字符串前面无条件的添加一定的姓名成分信息，比如尊称。注意: \cmd{DeclareLabelalphaTemplate} 中\cmd{field} 的\opt{uppercase} 和\opt{lowercase} 选项应用于从\cmd{DeclareLabelalphaTemplate} 返回的整个标签，无论它是不是带\opt{pre} 选项的\cmd{namepart}。
%When constructing label strings from names, the \cmd{namepart} \emph{without} a \opt{pre} option will be used to construct label string, passing through disambiguation, substring etc. operations as specified by the \cmd{field} options in \cmd{DeclareLabelalpaTemplate}. Then the \cmd{namepart} options \emph{with} the \opt{pre} option set will be prepended to the result, (in the order given, if there are more than one such \cmd{namepart}s). This allows to unconditionally prepend certain namepart information to name label strings, like name prefices. Note that the \opt{uppercase} and \opt{lowercase} options of \cmd{field} in \cmd{DeclareLabelalphaTemplate} are applied to the entire label returned from \cmd{DeclareLabelalphaTemplate}, both \opt{pre} parts and non \opt{pre}.

\boolitem[false]{compound}

对于\cmd{DeclareLabelalphaTemplate} 中静态(非varwidth)区分方法，由空格或连字符(混合姓名)分隔的姓名成分在标签生成中将作为独立姓名成分。这意味着从如<Ballam Forsyth> 这样的姓中形成标签时，当用1个字符，左侧开始抽取子字符串，当\kvopt{compound}{true} 时，该姓名会给出<BF>，而\kvopt{compound}{false} 时会给出<B>。简写形式\opt{compound} 等价于\kvopt{compound}{true}。
%For static (non-varwidth) disambiguation in \cmd{DeclareLabelalphaTemplate}, nameparts separated by whitespace or hyphens (compound names) as separate names for label generation. This means that when forming a label out of, for example the surname <Ballam Forsyth> with a 1 character, left-side substring, this name would give <BF> with \kvopt{compound}{true} and <B> with \kvopt{compound}{false}. The short form \opt{compound} is equivalent to \kvopt{compound}{true}.

\intitem[1]{strwidth}

使用的\prm{namepart} 的字符数。
%The number of characters of the \prm{namepart} to use.

\choitem[left]{strside}{left, right}

获取\texttt{strwidth} 数量字符开始的方向。
%The side of the string from which to take the \texttt{strwidth} number of characters.

\end{optionlist*}

\end{ltxsyntax}

注意标签模板可以根据具体类型分别定义，当使用自动标签非歧义化功能时应注意这一点。非歧义化是不分类型的，因此不同类型的不同标签格式在各自非歧义化过程中可能产生歧义。一般情况，需要针对不同类型使用非常不同的标签格式，使得标签的类型可以明确。
%Note that the templates for labels can be defined per-type and you should be aware of this when using the automatically disambiguated label functionality. Disambiguation is not per-type as this might lead to ambiguity due to different label formats for different types being isolated from each others disambiguation process. Normally, you will want to use very different label formats for different types to make the type obvious by the label.

下面是一些示例。\biblatex 字母顺序标签默认模板全局定义如下。首先\bibfield{shorthand} 具有\kvopt{final}{true}，因此当存在\bibfield{shorthand} 域时，它将作为标签，模板的其它内容不再考虑。接着，\bibfield{label} 作为第一个标签元素，如果它存在的话。另外，如果\bibfield{labelname} 列表中仅有一个姓名(\kvopt{ifnames}{1})，那么\bibfield{labelname} 中从姓的左侧取3个字符作为第一个标签元素。如果\bibfield{labelname} 具有超过1个的姓名，从每个名字的姓的左侧取1个字符作为第一个标签元素。第二个标签元素包含从\bibfield{year} 域的右侧取的两个字符。
%Here are some examples. The default global \biblatex alphabetic label template is defined below. Firstly, \bibfield{shorthand} has \kvopt{final}{true} and so if there is a \bibfield{shorthand} field, it is used as the label and nothing more of the template is considered. Next, the \bibfield{label} field is used as the first label element if it exists. Otherwise, if there is only one name (\kvopt{ifnames}{1}) in the \bibfield{labelname} list, then three characters from the left side of the family name in the \bibfield{labelname} are used as the first label element. If the \bibfield{labelname} has more than one name in it, one character from the left side of each family name is used as the first label element. The second label element consists of 2 characters from the right side of the \bibfield{year} field.

示例中也给出了姓名构建标签的默认模板。该模板将任何尊称(如果\opt{useprefix} 选项为true)左侧的第一个字符添加到由姓(根据调用来自\cmd{DeclareLabelalphaTemplate} 的\cmd{field} 的选项实现)中抽取的标签之前，并支持混合(compound)的姓处理。
%The default template for constructing labels from names is also shown. This prepends the first character from the left side of any prefix (if the \opt{useprefix} option is true) to a label extracted from the family name (according to the options on the calling \cmd{field} option from \cmd{DeclareLabelalphaTemplate}), allowing for compound family names.

\begin{ltxexample}
\DeclareLabelalphaTemplate{
  \labelelement{
    \field[final]{<<shorthand>>}
    \field{<<label>>}
    \field[strwidth=3,strside=left,ifnames=1]{<<labelname>>}
    \field[strwidth=1,strside=left]{<<labelname>>}
  }
  \labelelement{
    \field[strwidth=2,strside=right]{<<year>>}
  }
}

\DeclareLabelalphaNameTemplate{
  \namepart[use=true, pre=true, strwidth=1, compound=true]{prefix}
  \namepart{family}
}

\end{ltxexample}
%
要了解标签自动非歧义化(消除歧义)(非模糊化)处理的工作方式，观察如下的作者列表:
%To get an idea of how the label automatic disambiguation works, consider the following author lists:

\begin{lstlisting}{}
Agassi, Chang, Laver   (2000)
Agassi, Connors, Lendl (2001)
Agassi, Courier, Laver (2002)
Borg, Connors, Edberg  (2003)
Borg, Connors, Emerson (2004)
\end{lstlisting}
%
假设一个模板定义如下:
%Assuming a template declaration such as:

\begin{ltxexample}
\DeclareLabelalphaTemplate{
  \labelelement{
    \field[varwidth]{<<labelname>>}
  }
}
\end{ltxexample}
%
那么标签会是:
%Then the labels would be:

\begin{lstlisting}{}
Agassi, Chang, Laver    [AChLa]
Agassi, Connors, Lendl  [AConLe]
Agassi, Courier, Laver  [ACouLa]
Borg, Connors, Edberg   [BConEd]
Borg, Connors, Emerson  [BConEm]
\end{lstlisting}
%
使用规范化可变宽度标签定义:
%With normalised variable width labels defined:

\begin{ltxexample}
\DeclareLabelalphaTemplate{
  \labelelement{
    \field[varwidthnorm]{<<labelname>>}
  }
}
\end{ltxexample}
%
会得到如下结果，其中每个位置的姓名子字符串拓展为相同位置上最长子字符串的长度:
%You would get the following as the substrings of names in each position are extended to the length of the longest substring in that same position:

\begin{lstlisting}{}
Agassi, Chang, Laver    [AChaLa]
Agassi, Connors, Lendl  [AConLe]
Agassi, Courier, Laver  [ACouLa]
Borg, Connors, Edberg   [BConEd]
Borg, Connors, Emerson  [BConEm]
\end{lstlisting}
%
对标签元素的姓名成分有2个字符的限制，定义如下:
%With a restriction to two characters for the name components of the label element defined like this:

\begin{ltxexample}
\DeclareLabelalphaTemplate{
  \labelelement{
    \field[varwidthnorm,strwidthmax=2]{<<labelname>>}
  }
}
\end{ltxexample}
%
得到结果如下(注意每个姓构成的标签部分不再具有非歧义性):
%This would be the result (note that the individual family name label parts are no longer unambiguous):

\begin{lstlisting}{}
Agassi, Chang, Laver    [AChLa]
Agassi, Connors, Lendl  [ACoLe]
Agassi, Courier, Laver  [ACoLa]
Borg, Connors, Edberg   [BCoEd]
Borg, Connors, Emerson  [BCoEm]
\end{lstlisting}
%
或者，可以将姓名列表作为一个整体进行消除歧义处理的:
%Alternatively, you could choose to disambiguate the name lists as a whole with:

\begin{ltxexample}
\DeclareLabelalphaTemplate{
  \labelelement{
    \field[varwidthlist]{<<labelname>>}
  }
}
\end{ltxexample}
%
将得到:
%Which would result in:

\begin{lstlisting}{}
Agassi, Chang, Laver    [AChL]
Agassi, Connors, Lendl  [ACoL]
Agassi, Courier, Laver  [ACL]
Borg, Connors, Edberg   [BCEd]
Borg, Connors, Emerson  [BCE]
\end{lstlisting}
%
或者仅需要考虑最多两个姓名用于标签生成，但又在姓名列表层次进行非歧义化处理:
%Perhaps you only want to consider at most two names for label generation but disambiguate at the whole name list level:
\begin{ltxexample}
\DeclareLabelalphaTemplate{
  \labelelement{
    \field[varwidthlist,names=2]{<<labelname>>}
  }
}
\end{ltxexample}
%
将得到:
%Which would result in:
\begin{lstlisting}{}
Agassi, Chang, Laver    [ACh+]
Agassi, Connors, Lendl  [ACo+]
Agassi, Courier, Laver  [AC+]
Borg, Connors, Edberg   [BC+a]
Borg, Connors, Emerson  [BC+b]
\end{lstlisting}
%
在这最后一个示例中，可以看到已经添加了\cmd{labelalphaothers} 以显示存在更多姓名。最后两个标签需要利用\cmd{extraalpha} 来实现非歧义性，因为仅依靠列表中前两个姓名无法消除歧义。
%In this last example, you can see \cmd{labelalphaothers} has been appended to show that there are more names. The last two labels now require disambiguating with \cmd{extraalpha} as there is no way of disambiguating this label name list with only two names.

最后是一个使用多个标签元素的示例:
%Finally, here is an example using multiple label elements:

\begin{ltxexample}
\DeclareLabelalphaTemplate{
  \labelelement{
    \field[varwidthlist]{<<labelname>>}
  }
  \labelelement{
    \literal{-}
  }
  \labelelement{
    \field[strwidth=3,strside=right]{<<labelyear>>}
  }
}
\end{ltxexample}
%
将得到:
%Which would result in:
\begin{lstlisting}{}
Agassi, Chang, Laver    [AChL-000]
Agassi, Connors, Lendl  [AConL-001]
Agassi, Courier, Laver  [ACouL-002]
Borg, Connors, Edberg   [BCEd-003]
Borg, Connors, Emerson  [BCEm-004]
\end{lstlisting}
%
下面是精心设计的另一个示例，展示当指定衬垫字符或文本时，不需要特别的引用\latex 特殊字符(显然除了<\%>之外):
%Here is another rather contrived example showing that you don't need to specially quote \latex special characters (apart from <\%>, obviously) when specifying padding characters and literals:

\begin{ltxexample}
\DeclareLabelalphaTemplate{
  \labelelement{
    \literal{>}
  }
  \labelelement{
    \literal{\%}
  }
  \labelelement{
    \field[namessep={/}, strwidth=4, padchar=_]{<<labelname>>}
  }
  \labelelement{
    \field[strwidth=3, padchar=&, padside=left]{title}
  }
  \labelelement{
    \field[strwidth=2,strside=right]{<<year>>}
  }
}
\end{ltxexample}
%
当有:
%which given:
\begin{lstlisting}[style=bibtex]{}
@Book{test,
  author    = {XXX YY and WWW ZZ},
  title     = {T},
  year      = {2007},
}
\end{lstlisting}
将得到\footnote{译者:注意这里没有说明姓名模板使用的是哪个？所以对于该结果是有疑惑的，strwidth是应用到一个姓名还是多个姓名？}:
%would resulting a label looking like this:
\begin{verbatim}
[>%YY/ZZ__&&T07]
\end{verbatim}

当域中包含变音符(diacritic)，连字符(hyphen)，空格(space)等时，从域中生成标签可能存在一些困难。通常，在生成标签时需要忽略分隔符或者空格之类的字符。一个选项可以用来定制正则表达式使得在域传递给标签生成系统前能将其内容取出。
%Generating labels from fields may involve some difficulties when you have fields containing diacritics, hyphens, spaces etc. Often, you want to ignore things like separator characters or spaces when generating labels. An option is provided to customise the regular expression(s) to strip from a field before it is passed to the label generation system.

\begin{ltxsyntax}

\cmditem{DeclareNolabel}{specification}

定义正则表达式实现在生成域的标签部分前从任意域取出其内容。\prm{specification} 是一个\cmd{nolabel} 指令构成的无分隔列表，该列表指定了正则表达式用于将其匹配内容从多个域中去除。可以自由使用空格，制表符，行末符号来整理其中的代码，达到满意的代码显示效果，但空行则不允许。该命令只能用于导言中。
%Defines regular expressions to strip from any field before generating a label part for the field. The \prm{specification} is an undelimited list of \cmd{nolabel} directives which specify the regular expressions to remove from fields. Spaces, tabs and line endings may be used freely to visually arrange the \prm{specification}. Blank lines are not permissible. This command may only be used in the preamble.

\cmditem{nolabel}{regexp}

可以给出任意数量的\cmd{nolabel} 命令，用来指定去除副本域的\prm{regexp}，该副本域能被标签生成系统看见。
%Any number of \cmd{nolabel} commands can be given each of which specifies to remove the \prm{regexp} from the copy of the field which the label generation system sees. Since regular expressions usually contain special characters, it is best to enclose them in the provided \cmd{regexp} macro as shown---this will pass the expression through to \biber correctly.

\end{ltxsyntax}

如果不存在\cmd{DeclareNolabel} 设置，\biber 将默认设置:
%If there is no \cmd{DeclareNolabel} specification, \biber will default to:

\begin{ltxexample}
\DeclareNolabel{
  % strip punctuation, symbols, separator and control characters
  \nolabel{\regexp{<<[\p{P}\p{S}\p{C}]+>>}}
}
\end{ltxexample}
%
这一\biber 默认设置将在向标签生成系统传递域字符串之前去除标点，符号，分隔符和控制符。(译者:注意这里正则表达式中的\cmd{p}，用于匹配有命名属性的字符。)
%This \biber default strips punctuation, symbol, separator and control characters from fields before passing the field string to the label generation system.

\begin{ltxsyntax}

\cmditem{DeclareNolabelwidthcount}{specification}

当在固定宽度子字符串中统计字符数时，定义任意域中需要忽略的\prm{regexp}(即正则表达式匹配的内容)。\prm{specification} 是一个\cmd{nolabelwidthcount} 指令构成的无分隔列表，该列表指定了正则表达式用于在固定宽度子字符串中统计字符时将其匹配内容忽略。可以自由使用空格，制表符，行末符号来整理其中的代码，达到满意的代码显示效果，但空行则不允许。该命令只能用于导言中。
%Defines regular expressions to ignore from any field when counting characters in fixed-width substrings. The \prm{specification} is an undelimited list of \cmd{nolabelwidthcount} directives which specify the regular expressions to ignore when counting characters for fixed-width substrings. Spaces, tabs and line endings may be used freely to visually arrange the \prm{specification}. Blank lines are not permissible. This command may only be used in the preamble.

\cmditem{nolabelwidthcount}{regexp}

可以给出任意数量的\cmd{nolabelwidthcount} 命令，用来指定在标签生成过程中当生成固定宽度子字符串时忽略的\prm{regexp}。
%Any number of \cmd{nolabelwidthcount} commands can be given each of which specifies to ignore the \prm{regexp} when generating fixed-width substrings during label generation. Since regular expressions usually contain special characters, it is best to enclose them in the provided \cmd{regexp} macro as shown---this will pass the expression through to \biber correctly.

\end{ltxsyntax}

没有默认的\cmd{DeclareNolabelwidthcount} 设置。注意该设置只有在标签部分生成过程中使用固定宽度子字符串时考虑。见\secref{aut:ctm:lab} 节。
%There is no default \cmd{DeclareNolabelwidthcount} specification. Note that
%this setting is only taken into account when using fixed-width substrings
%(non-varwidth) during label part generation. See \secref{aut:ctm:lab}.

\subsubsection{排序}%Sorting
\label{aut:ctm:srt}

除了应用\secref{use:srt} 节讨论的预定义的排序格式外，还可以定义新的排序方式或者修改默认的格式。还可以通过根据具体的条目类型排除某些域和自动添加\bibfield{presort} 域来进一步定义。
%In addition to the predefined sorting templates discussed in \secref{use:srt}, it is possible to define new ones or modify the default definitions. The sorting process may be customized further by excluding certain fields from sorting on a per-type basis and by automatically populating the \bibfield{presort} field on a per-type basis.

\begin{ltxsyntax}

\cmditem{DeclareSortingTemplate}[options]{name}{specification}

定义排序格式\prm{name}。当选择了指定排序格式时，\prm{name} 是传递给\opt{sorting} 选项(见\secref{use:opt:pre:gen})的标识。\cmd{DeclareSortingScheme} 命令支持如下可选参数:
%Defines the sorting Template \prm{name}. The \prm{name} is the identifier passed to the \opt{sorting} option (\secref{use:opt:pre:gen}) when selecting the sorting scheme. The \cmd{DeclareSortingScheme} command supports the following optional arguments:

\begin{optionlist*}

\choitem{locale}{\prm{locale}}

排序格式中的locale用于覆盖\opt{sortlocale} 选项(在\secref{use:opt:pre:gen} 节讨论)给出的全局排序locale。
%The locale for the sorting Template which then overrides the global sorting locale in the \opt{sortlocale} option discussed in \secref{use:opt:pre:gen}.

\end{optionlist*}

\prm{specification} 是\cmd{sort} 指令的无分隔列表，这些\cmd{sort} 指令用于指定需要在排序过程中考虑的元素。可以自由使用空格，制表符，行末符来调整代码呈现格式以达到满意视觉效果，空行不允许。该命令只能用于导言中。
%The \prm{specification} is an undelimited list of \cmd{sort} directives which specify the elements to be considered in the sorting process. Spaces, tabs, and line endings may be used freely to visually arrange the \prm{specification}. Blank lines are not permissible. This command may only be used in the preamble.

\cmditem{sort}{elements}

指定在排序过程中考虑的元素。\prm{elements} 是\cmd{field} ，\cmd{literal}，和 \cmd{citeorder} 命令的无分隔列表，这些命令以给定的顺序考虑。\emph{注意:} 一旦定义了一个元素，它将被添加到排序关键词中，然后排序过程跳到下一条\cmd{sort} 指令。如果该元素未定义，则考虑下一个元素。因为文本字符串总是存在，\cmd{literal} 命令应该单独或者最后出现在\cmd{sort} 指令中。所有的\prm{elements} 应该与\secref{bib:fld:dat} 节中描述数据类型一致，因为它们将会与其它条目中的\prm{elements} 进行比较。\cmd{sort} 命令支持如下可选参数:
%Specifies the elements considered in the sorting process. The \prm{elements} are an undelimited list of \cmd{field}, \cmd{literal}, and \cmd{citeorder} commands which are evaluated in the order in which they are given. If an element is defined, it is added to the sort key and the sorting routine skips to the next \cmd{sort} directive. If it is undefined, the next element is evaluated. Since literal strings are always defined, any \cmd{literal} commands should be the sole or the last element in a \cmd{sort} directive. All \prm{elements} should be the same datatype as described in \secref{bib:fld:dat} since they will be potentially compared to any of the other \prm{elements} in other entries. The \cmd{sort} command supports the following optional arguments:

\begin{optionlist*}

\choitem{locale}{\prm{locale}}

在排序元素的一个特定集层级覆盖用于排序的locale。如果给出，locale将覆盖在\cmd{DeclareSortingScheme} 层级和全局设置的locale集。另可参见\secref{use:opt:pre:gen} 节关于全局排序locale选项\opt{sortlocale} 的讨论。
%Override the locale used for sorting at the level of a particular set of sorting elements. If specified, the locale overrides the locale set at the level of \cmd{DeclareSortingScheme} and also the global setting. See also the discussion of the global sorting locale option \opt{sortlocale} in \secref{use:opt:pre:gen}.

\choitem[ascending]{direction}{ascending, descending}

排序方向，可以是\texttt{ascending} 或\texttt{descending}。默认是升序(ascending)。
%The sort direction, which may be either \texttt{ascending} or \texttt{descending}. The default is ascending order.

\boolitem[false]{final}

该选项标记一个\cmd{sort} 指令作为\prm{specification} 中的最后一个。如果\prm{elements} 中的元素存在，\prm{specification} 中剩下的内容将被忽略。简写形式\opt{final} 等价于\kvopt{final}{true}。
%This option marks a \cmd{sort} directive as the final one in the \prm{specification}. If one of the \prm{elements} is available, the remainder of the \prm{specification} will be ignored. The short form \opt{final} is equivalent to \kvopt{final}{true}.

\boolitem{sortcase}

设置排序是否大小写敏感(case"=sensitively)。默认的设置取决于全局选项\opt{sortcase}。
%Whether or not to sort case"=sensitively. The default setting depends on the global \opt{sortcase} option.

\boolitem{sortupper}

设置排序是否大写字母开头的在小写字母开头的条目之前(即<uppercase before lowercase>(\texttt{true})or <lowercase before uppercase> order (\texttt{false}))。 默认设置取决于全局选项\opt{sortupper}。
%Whether or not to sort in <uppercase before lowercase> (\texttt{true}) or <lowercase before uppercase> order (\texttt{false}). The default setting depends on the global \opt{sortupper} option.

\end{optionlist*}

\cmditem{field}[key=value, \dots]{field}

\cmd{field} 元素向排序设置中添加\prm{field}。如果\prm{field} 未定义，则跳过该元素。\cmd{field} 支持如下可选参数:
%The \cmd{field} element adds a \prm{field} to the sorting specification. If the \prm{field} is undefined, the element is skipped. The \cmd{field} command supports the following optional arguments:

\begin{optionlist*}

\choitem[left]{padside}{left, right}

使用\opt{padchar} 在一个域的\texttt{left} 或\texttt{right} 侧添加衬垫字符，使其宽度为\opt{padwidth}。如果padding选项没有设置，则不做任何衬垫。否则将执行衬垫，选项缺省将使用默认值。如果padding和子字符串匹配选项同时存在，那么子字符串匹配首先处理。
%Pads a field on the \texttt{left} or \texttt{right} side using \opt{padchar} so that its width is \opt{padwidth}. If no padding option is set, no padding is done at all. If any padding option is specified, then padding is performed and the missing options are assigned built-in default values. If padding and substring matching are both specified, the substring match is performed first.

\intitem[4]{padwidth}

所需衬垫字符目标宽度
%The target width in characters.

\valitem[0]{padchar}{character}

用于衬垫的字符。
%The character to be used when padding the field.

\choitem[left]{strside}{left, right}

从域的\texttt{left} 或\texttt{right} 侧执行子字符串匹配。匹配的字符数由相应的\texttt{strwidth} 选择指定。如果没有设置substring选项，则不做匹配。如果存在substring选项，将执行匹配，选项缺省将使用默认值。如果padding和子字符串匹配选项同时存在，那么子字符串匹配首先处理。
%Performs a substring match on the \texttt{left} or \texttt{right} side of the field. The number of characters to match is specified by the corresponding \texttt{strwidth} option. If no substring option is set, no substring matching is performed at all. If any substring option is specified, then substring matching is performed and the missing options are assigned built-in default values. If padding and substring matching are both specified, the substring match is performed first.

\intitem[4]{strwidth}

用于匹配的字符数。
%The number of characters to match.

\end{optionlist*}

\cmditem{literal}{string}

\cmd{literal} 元素添加一个文本的\prm{string} 到排序配置中。这在一些域不存在时作为一个备选使用。
%The \cmd{literal} element adds a literal \prm{string} to the sorting specification. This is useful as a fallback if some fields are not available.

\csitem{citeorder}

\cmd{citeorder} 元素有特殊意义。它要求排序基于实际标注的词汇表顺序。对于在一个标注命令中的多个条目，如:
%The \cmd{citeorder} element has a special meaning. It requests a sort based on the lexical order of the actual citations. For entries cited within the same citation command like:

\begin{ltxexample}
\cite{one,two}
\end{ltxexample}
%
词汇表顺序和语义顺序是不同的。这里的«one»和«two»有相同的语义顺序，但有不同的词汇表顺序。语义顺序只关心相同语义顺序下是否指定后续的排序设置来区分条目。比如，一个排序格式\opt{none} 的定义为:
%there is a distinction between the lexical order and the semantic order. Here «one» and «two» have the same semantic order but a unique lexical order. The semantic order only matters if you specify further sorting to disambiguate entries with the same semantic order. For example, this is the definition of the \opt{none} sorting scheme:

\begin{ltxexample}
\DeclareSortingTemplate{none}{
  \sort{\citeorder}
}
\end{ltxexample}
%
这将单纯地根据标注命令中的关键词顺序来排序文献。在上一个示例中， «one»排在«two»前面。如果假设«one»和«two»具有相同的语义顺序因为它们同时被引用，但需要根据year进一步排序，假设«two»条目的年份早于«one»:
%This sorts the bibliography purely lexically by the order of the keys in the citation commands. In the example above, it sorts «one» before «two». However, suppose that you consider «one» and «two» to have the same order (semantic order) since they are cited at the same time and want to further sort these by year. Suppose «two» has an earlier \bibfield{year} than «one»:

\begin{ltxexample}
\DeclareSortingTemplate{noneyear}{
  \sort{\citeorder}
  \sort{<<year>>}
}
\end{ltxexample}
%
这次将«two»排在«one»，尽管从词汇表上看，«one»应排在«two»前面。这是可能的，因为语义顺序可以根据年份进一步排序区分。使用标准的\opt{none} 排序格式，词汇表顺序和语义顺序是相同的，因为没有进一步的排序设置来区分。这意味着可以像使用其它元素一样来使用\cmd{citeorder}，选择怎么来对同时引用(在一个标注命令中)的条目进行进一步排序。
%This sorts «two» before «one», even though lexically, «one» would sort before «two». This is possible because the semantic order can be disambiguated by the further sorting on year. With the standard \opt{none} sorting scheme, the lexical order and semantic order are identical because there is nothing further to disambiguate them. This means that you can use \cmd{citeorder} just like any other sorting specification element, choosing how to further sort entries cited at the same time (in the same citation command).

\cmditem{DeclareSortingNamekeyTemplate}[name]{specification}

定义姓名的排序关键词如何构建。这可以用来改变姓名的排序，因为在构建排序要比较的字符串时可以自由选择姓名成分来组合。如此定义的排序关键词的构建格式称为\prm{Templatename}，默认是全局的(«global»)，如果该可选参数缺省的话。当为姓名构建排序关键词时，构建每个姓名成分的排序关键词，并利用一个专门的内部分隔符构成一个顺序的关键词列表。这一选项的目的是兼容语言或者需要自定义姓名排序的情况(例如，冰岛人的姓名有时是用名排序而不是姓)。该宏可以多次使用为不同姓名的定义格式，以便后面使用。姓名排序关键词格式具有如下作用范围，以优先级增加的顺序包括:
%Defines how the sorting keys for names are constructed. This can change the sorting order of names arbitrarily because you can choose how to put together the name parts when constructing the string to compare when sorting. The sorting key construction scheme so defined is called \prm{Templatename} which defaults to «global» if this optional parameter is absent. When constructing the sorting key for a name, a sorting key for each name part is constructed and the key for each name is formed into an ordered key list with a special internal separator. The point of this option is to accommodate languages or situations where sorting of names needs to be customised (for example, Icelandic names are sometimes sorted by given names rather than by family names). This macro may be used multiple times to define schemes with different names which can then be referred to later. Sorting name key schemes can have the following scopes, in order of increasing precedence:

\begin{itemize}
\item 无可选姓名参数定义的默认格式。
%The default template defined without the optional name argument
\item 为一个参考文献环境(见\secref{use:bib:context})给出\opt{sortingnamekeytemplate} 选项。
%Given as the \opt{sortingnamekeytemplate} option to a reference context (see \secref{use:bib:context})
\item 在参数文献数据源条目中给出具体条目的\opt{sortnamekeytemplate} 选项。
%Given as a per-entry option \opt{sortnamekeyscheme} in a bibliography data source entry
\item 为姓名列表给出的\opt{sortnamekeytemplate} 选项。
%Given as a per-namelist option \opt{sortnamekeytemplate}
\item 为一个姓名给出的\opt{sortnamekeytemplate} 选项。
%Given as a per-name option \opt{sortnamekeytemplate}
\end{itemize}

默认情况下，仅有一个全局格式，\prm{specification} 定义如下:
%By default there is only a global template which has the following \prm{specification}:

\begin{ltxexample}
\DeclareSortingNamekeyTemplate{
  \keypart{
    \namepart[use=true]{<<prefix>>}
  }
  \keypart{
    \namepart{<<family>>}
  }
  \keypart{
    \namepart{<<given>>}
  }
  \keypart{
    \namepart{<<suffix>>}
  }
  \keypart{
    \namepart[use=false]{<<prefix>>}
  }
}
\end{ltxexample}
%
这意味着关键词由如下姓名成分按给出顺序联合构建: 前缀(尊称)(仅当\opt{useprefix} 选项为true)，姓，名，后缀和前缀(仅当\opt{useprefix} 选项为false)
%This means that the key is constructed by concatenating, in order, the name prefix (only if the \opt{useprefix} option is true), the family name(s), the given names(s), the name suffix and then the name prefix (only if the \opt{useprefix} option is false).

\cmditem{keypart}{part}

\prm{part} 是一个\cmd{namepart} 和\cmd{literal} 设置构成的有序列表，这些设置联接在一起构建姓名排序关键词的一部分。
\prm{part} is an ordered list of of \cmd{namepart} and \cmd{literal} specifications which are concatenated together when constructing a part of the name sorting key. The \cmd{keyparts} are then concatenated together with terminal padding to ensure correct sorting.



\cmditem{literal}{string}

插入姓名排序关键词中的文本字符串。
%A literal string to insert into the name sorting key.

\cmditem{namepart}{name}

指定姓名成分的\prm{name}，用于构建姓名排序关键词。
%Specifies the \prm{name} of a namepart to use in constructing the name sorting key.

\begin{optionlist*}

\boolitem[true]{use}

表示仅当姓名成分\prm{name} 对应的\opt{use<name>} 选项设置为指定的布尔值时使用该\prm{name} 用于构建排序关键词。
%Indicates that the namepart \prm{name} is only to be used in this concatenation position if the corresponding \opt{use<name>} option is set to the specified boolean value.

\boolitem[true]{inits}

表示仅使用姓名成分\prm{name} 的首字母来构建排序关键词。
%Indicates that only the initials of namepart \prm{name} are to be used in
%constructing the sorting specification.

\end{optionlist*}

\end{ltxsyntax}

举个例子，假设用于排序的姓名成分中名要优先于姓，可以定义姓名排序关键词如下:
%As an example, suppose you wanted to be able to sort names by given name rather than family name, you could define a sorting name key scheme like this:

\begin{ltxexample}
\DeclareSortingNamekeyTemplate[givenfirst]{
  \keypart{
    \namepart{<<given>>}
  }
  \keypart{
    \namepart[use=true]{<<prefix>>}
  }
  \keypart{
    \namepart{<<family>>}
  }
  \keypart{
    \namepart[use=false]{<<prefix>>}
  }
}
\end{ltxexample}
%
然后可以在适当的范围内使用\opt{givenfirst} 来使得\biber 根据该格式构建排序关键词。比如，可以用在一个参考文献环境中使用:
%You can then use the name \opt{givenfirst} at the appropriate scope in order to make \biber use this scheme when constructing sorting name keys. For example, you could enable this for one bibliography list like this:

\begin{ltxexample}
\begin{refcontext}[sortnamekeytemplate=givenfirst]
\printbibliography
\end{refcontext}
\end{ltxexample}
%
或者在某一个特定条目中使用:
%or perhaps you only want to do this for a particular entry:

\begin{lstlisting}[style=bibtex]{}
@BOOK{key,
  OPTIONS = {sortnamekeytemplate=givenfirst},
  AUTHOR = {Arnar Vigfusson}
}
\end{lstlisting}
%
或者在一个姓名列表中使用，该选项作为一个假名会自动忽略。
%or just a name list by using the option as a pseudo-name which will be ignored:

\begin{lstlisting}[style=bibtex]{}
@BOOK{key,
  AUTHOR = {sortnamekeytemplate=givenfirst and Arnar Vigfusson}
}
\end{lstlisting}
%
或者在一个姓名中使用，通过将其作为\biber 支持的姓名信息格式的一个扩展成分传递该选项(见\biber 文档):
%or just a single name by passing the option as part of the extended name information
%format which \biber supports (see \biber doc):

\begin{lstlisting}[style=bibtex]{}
@BOOK{key,
  AUTHOR = {given=Arnar, family=Vigfusson, sortnamekeyscheme=givenfirst}
}
\end{lstlisting}
%

下面我们给出一些排序格式的示例。在第一个示例中，我们定义了一个简单的name\slash title\slash year格式。姓名元素可以是\bibfield{author}，\bibfield{editor}，或\bibfield{translator}。根据这一设置，排序过程将首先使用存在的第一个元素，然后继续处理\bibfield{title}。注意\opt{use$<$name$>$} 类选项在排序过程中自动处理:
%Now we give some examples of sorting templates. In the first example, we define a simple name\slash title\slash year scheme. The name element may be either the \bibfield{author}, the \bibfield{editor}, or the \bibfield{translator}. Given this specification, the sorting routine will use the first element which is available and continue with the \bibfield{title}. Note that the options \opt{use$<$name$>$} options are considered automatically in the sorting process:

\begin{ltxexample}
\DeclareSortingTemplate{sample}{
  \sort{
    \field{<<author>>}
    \field{<<editor>>}
    \field{<<translator>>}
  }
  \sort{
    \field{<<title>>}
  }
  \sort{
    \field{<<year>>}
  }
}
\end{ltxexample}
%
下一个示例中，我们以更详尽的方式定义了一个格式，考虑了\bibfield{presort}, \bibfield{sortkey}, \bibfield{sortname} 等特殊域。因为\bibfield{sortkey} 域指定了排序的主关键词，它需要覆盖所有除\bibfield{presort} 之外的元素。这通过\opt{final} 选项体现。如果\bibfield{sortkey} 域存在，排序过程将停在此处。如果不存在，排序过程将继续下一个\cmd{sort} 指令。这一设置就是\texttt{nty} 格式的默认定义。
%In the next example, we define the same template in a more elaborate way, considering special fields such as \bibfield{presort}, \bibfield{sortkey}, \bibfield{sortname}, etc. Since the \bibfield{sortkey} field specifies the master sort key, it needs to override all other elements except for \bibfield{presort}. This is indicated by the \opt{final} option. If the \bibfield{sortkey} field is available, processing will stop at this point. If not, the sorting routine continues with the next \cmd{sort} directive. This setup corresponds to the default definition of the \texttt{nty} scheme:

\begin{ltxexample}
\DeclareSortingTemplate{nty}{
  \sort{
    \field{<<presort>>}
  }
  \sort[final]{
    \field{<<sortkey>>}
  }
  \sort{
    \field{<<sortname>>}
    \field{<<author>>}
    \field{<<editor>>}
    \field{<<translator>>}
    \field{<<sorttitle>>}
    \field{<<title>>}
  }
  \sort{
    \field{<<sorttitle>>}
    \field{<<title>>}
  }
  \sort{
    \field{<<sortyear>>}
    \field{<<year>>}
  }
}
\end{ltxexample}
%
最后，给出一个覆盖全局的排序locale并在根据\bibfield{origtitle} 域排序时再次覆盖的示例。注意: 在格式层覆盖babel/polyglossia语言名的是一个真实的locale标识。\biber 会将其映射到一个合适的真实locale标识上(本例中是\texttt{sv\_SE})
%Finally, here is an example of a sorting template which overrides the global sorting locale and additionally overrides again when sorting by the \bibfield{origtitle} field. Note the use in the scheme-level override of a babel/polyglossia language name instead of a real locale identifier. \biber will map this to a suitable, real locale identifier (in this case, \texttt{sv\_SE}):

\begin{ltxexample}
\DeclareSortingTemplate[locale=swedish]{custom}{
  \sort{
    \field{<<sortname>>}
    \field{<<author>>}
    \field{<<editor>>}
    \field{<<translator>>}
    \field{<<sorttitle>>}
    \field{<<title>>}
  }
  \sort[locale=de_DE_phonebook]{
    \field{<<origtitle>>}
  }
}
\end{ltxexample}

\begin{ltxsyntax}

\cmditem{DeclareSortExclusion}{entrytype, \dots}{field, \dots}

指定排序具体类型的条目需要排除的域。\prm{entrytype} 和\prm{field} 参数可以是逗号分隔的列表。空的\prm{field} 将会清除该\prm{entrytype} 类型的所有排除设置。\prm{entrytype} 参数如果设置为<*> ，则排除的\prm{field,\dots} 针对所有类型。这等价于从排序设置中简单的删除一些域，且一般仅与\cmd{DeclareSortInclusion} 连用，特别是当希望为显式给出的条目类型排除某个域时候使用。示例见下面的\cmd{DeclareSortInclusion}。该命令只能用于导言区。
%Specifies fields to be excluded from sorting on a per-type basis. The \prm{entrytype} argument and the \prm{field} argument may be a comma"=separated list of values. A blank \prm{field} argument will clear all exclusions for this \prm{entrytype}. A value of <*> for \prm{entrytype} will exclude \prm{field,\dots} for every entrytype. This is equivalent to simply deleting the field from the sorting specification and is only normally used in combination with \cmd{DeclareSortInclusion} when one wishes to exclude a field for all but explicitly included entrytypes. See example in \cmd{DeclareSortInclusion} below. This command may only be used in the preamble.

\cmditem{DeclareSortInclusion}{entrytype, \dots}{field, \dots}

仅与\cmd{DeclareSortExclusion} 一同使用。指定具体条目类型排序需要包含的域。这使得用户可以为所有类型排序排除一个域，然后为某些特定条目类型改变这一设置。这有时比\cmd{DeclareSortExclusion} 更便于为一些条目列出排除项。\prm{entrytype} 和\prm{field} 参数可以是逗号分隔的列表。该命令只能用于导言区。例如，可以设置\bibfield{title} 在排序中仅用于\bibtype{article} 类型:
%Only used along with \cmd{DeclareSortExclusion}. Specifies fields to be included in sorting on a per-type basis. This allows the user to exclude a field from sorting for all entrytypes and then to override this for certain entrytypes. This is easier sometimes than using \cmd{DeclareSortExclusion} to list exclusions for many entrytypes. The \prm{entrytype} argument and the \prm{field} argument may be a comma"=separated list of values. This command may only be used in the preamble. For example, this would use \bibfield{title} during sorting only for \bibtype{article}s:

\begin{ltxexample}
\DeclareSortExclusion{*}{title}
\DeclareSortInclusion{article}{title}
\end{ltxexample}

\cmditem{DeclarePresort}[entrytype, \dots]{string}

定义一个字符串，用于当条目中不存在\bibfield{presort} 域时，复制该字符串到\bibfield{presort} 域。\bibfield{presort} 可以全局定义或者根据具体条目定义。如果给出可选参数\prm{entrytype}，\prm{string} 用于指定的条目类型。否则作为全局的默认值。给具体条目\prm{entrytype} 指定一个空的\prm{string}，将会清除原来的条目设置。而\prm{entrytype} 参数可以是一个逗号分隔的列表。该命令只能用于导言中。
%Specifies a string to be used to automatically populate the \bibfield{presort} field of entries without a \bibfield{presort} field. The \bibfield{presort} may be defined globally or on a per-type basis. If the optional \prm{entrytype} argument is given, the \prm{string} applies to the respective entry type. If not, it serves as the global default value. Specifying an \prm{entrytype} in conjunction with a blank \prm{string} will clear the type-specific setting. The \prm{entrytype} argument may be a comma"=separated list of values. This command may only be used in the preamble.

\cmditem{DeclareSortTranslit}[entrytype]{specification}

Languages which can be written in different scripts or alphabets often only have CLDR sorting tailoring for one script and it is expected that you transliterate into the supported script for sorting purposes. A common example is Sanskrit which is often written in academic contexts in IAST
romanised script but which needs to be sorted in the <sa> locale which expects the Devanāgarī script. Another common case is transliteration of Russian Cyrillic into Latin as defined by the ALA-LC standard. Such requirement means that it is necessary to transliterate into the sorting script internally. \cmd{DeclareSortTranslit} declares which parts of an entry you would like to transliterate for sorting purposes. Without the \prm{entrytype} parameter, the \prm{specification} applies to all entrytypes. The \prm{specification} is one or more \cmd{translit} commands:


能用不同文字或字母书写的语言对于一种文字常常仅有CLDR排序方式，为了进行排序往往需要将其转换为支持的文字。一个常见示例是梵文(Sanskrit)，它常用罗马化的婆罗米系文字书写正式文献，但需要在<sa> locale中排序，而这需要Devanāgarī文字。这意味着需要在内部转换排序文字。\cmd{DeclareSortTranslit} 声明条目的那个部分需要为排序目的而转化。如果没有\prm{entrytype} 参数，\prm{specification} 用于所有条目。\prm{specification} 包含一个或多个\cmd{translit} 命令。


\cmditem{translit}[langids]{field or fieldset}{from}{to}

指定数据域\bibfield{field} 或由\cmd{DeclareDatafieldSet}(见\secref{aut:ctm:dsets})声明的\prm{fieldset} 集中的所有域为排序目的应从\prm{from} 文字转换为\prm{to} 文字。域和集参数可以是 <*> 使其应用于所有域。有效的\prm{from} 和\prm{to} 在表\ref{tab:translit} 中给出。注意\biblatex 无意于支持通用的转换，而仅做排序目的。如果需要更多的转换，可以在GitHub上的\biblatex\ 查找或询问。
Specifies that the data field \bibfield{field} or all fields in a fieldset \prm{fieldset} declared with \cmd{DeclareDatafieldSet} (see \secref{aut:ctm:dsets}) should be transliterated from script \prm{from} to script \prm{to} for sorting purposes. The field/set argument should be <*> to apply transliteration to all fields. The valid \prm{from} and \prm{to} values are given in table \ref{tab:translit}. The optional \prm{langids} parameter is a comma-separated list of \bibfield{langid} fields and the transliteration will apply only to bibliography entries containing one of the \bibfield{langid}s in the list. Note that \biblatex does not aim to support general transliteration, only those which are useful for sorting purposes. Please open a GitHub ticket for \biblatex\ if you think you need additional transliterations.


下面给出一个标题转换的示例，从而可以正确的排序梵文:
%An example of transliterating titles so that they sort correctly in Sanskrit. This example assumes that entries that should have their title fields transliterated have a \bibfield{langid} field set to <sanskrit>.:

\begin{ltxexample}
\DeclareDatafieldSet{settitles}{
  \member[field=title]
  \member[field=booktitle]
  \member[field=eventtitle]
  \member[field=issuetitle]
  \member[field=journaltitle]
  \member[field=maintitle]
  \member[field=origtitle]
}

\DeclareSortTranslit{
  \translit[sanskrit]{settitles}{iast}{devanagari}
}
\end{ltxexample}

\end{ltxsyntax}

\begin{table}
\tablesetup\centering
\begin{tabular}{lll}
\toprule
\sffamily\bfseries\spotcolor From
  & \sffamily\bfseries\spotcolor To
  & Description\\
\midrule
iast & devanagari & Sanskrit IAST to Devanāgarī\\
russian & ala-lc & ALA-LC romanisation for Russian\\
russian & bgn/pcgn-standard & BGN/PCGN:1947 (Standard Variant), Cyrillic to Latin, Russian\\
 \bottomrule
\end{tabular}
\caption{可互相转换的文字}%Valid transliteration pairs%有效的转换文字对
\label{tab:translit}
\end{table}

\subsubsection[参考文献表过滤器]{参考文献表过滤器}%Bibliography List Filters
\label{aut:ctm:bibfilt}

当使用定制的参考文献表时(见\secref{use:bib:biblist})，常需要在\file{.bbl} 中仅写入具有特定域的条目用于在文献表中总结。比如，当打印一个缩略词的常规列表，需要让\biber 仅往\file{.bbl} 中写入一个仅包含具有\bibfield{shorthand} 域的条目的列表。这可以通过利用\cmd{DeclareBiblistFilter} 命令定义一个参考文献表过滤器来实现。这与\cmd{defbibfilter}(见\secref{use:bib:flt})定义的过滤器不同，因为\cmd{defbibfilter} 定义的过滤器在\biblatex 内运行且在\file{.bbl} 被生成之后。而且，\file{.bbl} 中的Bibliography List不包含条目数据，仅是条目的引用关键词，所有\cmd{defbibfilter} 定义的过滤器不能用于bibliography list。\footnote{译者:这里Bibliography List不是简单参考文献表，而是写入到bbl文件中某个列表，仅包含列表中各条目的关键词}
%When using customisable bibliography lists (See \secref{use:bib:biblist}), usually one wants to return in the \file{.bbl} only those entries which have the particular fields which the bibliography list is summarising. For example, when printing a normal list of shorthands, you want the list returned by \biber in the \file{.bbl} to contain only those entries which have a \bibfield{shorthand} field. This is accomplished by defining a bibliography list filter using the \cmd{DeclareBiblistFilter} command. This differs from the filters defined using \cmd{defbibfilter} (see \secref{use:bib:flt}) since the filters defined by \cmd{defbibfilter} run inside \biblatex after the \file{.bbl} has been generated. In addition, bibliography lists in the \file{.bbl} do not contain entry data, only the citation keys for the entries and so no filtering by \biblatex using \cmd{defbibfilter} is possible for bibliography lists.

\begin{ltxsyntax}
\cmditem{DeclareBiblistFilter}{name}{specification}

定义一个参考文献列表过滤器\prm{name}。\prm{specification} 由一个或多个的\cmd{filter} 或\cmd{filteror} 宏构成，对于传递给过滤器的条目所有这些宏都需要满足。
%Defines a bibliography list filter with \prm{name}. The \prm{specification} consists of one or more \cmd{filter} or \cmd{filteror} macros, all of which must be satisfied for the entry to pass the filter:

\cmditem{filter}[filterspec]{filter}

根据\prm{filterspec} 和\prm{filter} 过滤条目。\prm{filterspec} 可以是:
%Filter entries according to the \prm{filterspec} and \prm{filter}. \prm{filterspec} can be one of:

\end{ltxsyntax}

\begin{description}
\item[type/nottype] 条目是/不是\bibfield{entrytype} \prm{filter}
%Entry is/is not of \bibfield{entrytype} \prm{filter}
\item[subtype/notsubtype] 条目是/不是\bibfield{subtype} \prm{filter}
%Entry is/is not of \bibfield{subtype} \prm{filter}
\item[keyword/notkeyword] 条目具有/不具有\bibfield{keyword} \prm{filter}
%Entry has/does not have \bibfield{keyword} \prm{filter}
\item[field/notfield] 条目具有/不具有\prm{filter} 域
%Entry has/does not have a field called \prm{filter}
\end{description}

\begin{ltxsyntax}
\cmditem{filteror}{type}{filters}

在一个或多个\cmd{filter} 命令外的封套，用于指定这些\cmd{filter} 构成了一个并集，即其中任意一个\prm{filters} 都要满足。
%A wrapper around one or more \cmd{filter} commands specifying that they form a disjunctive set, i.e. any one of the \prm{filters} must be satisfied.

\end{ltxsyntax}

数据模型中标记为<Label fields>(见\secref{aut:ctm:dm})的域自动拥有为其定义的过滤器，过滤器名同域名，能将不包含该域的条目过滤掉。比如，\biblatex 自动为\bibfield{shorthand} 域生成一个过滤器:
%Fields in the datamodel which are marked as <Label fields> (see \secref{aut:ctm:dm}) automatically have a filter defined for them with the same name and which filters out any entries which do no contain the field. For example, \biblatex automatically generates a filter for the \bibfield{shorthand} field:

\begin{ltxexample}
\DeclareBiblistFilter{<<shorthand>>}{
  \filter[type=field,filter=shorthand]
}
\end{ltxexample}

\subsubsection{姓名首字母生成控制}%Controlling Name Initials Generation
\label{aut:ctm:noinit}

当姓名中存在前缀，变音符，连字符等时，要从一个给定姓名中生成各姓名成分的首字母存在一些困难。当生成首字母时，我们经常需要忽略像前缀之类的东西，比如«al-Hasan»的首字母就是«H»而不是«a-H»，但当你需要将姓名«Ho-Pun»生成首字母为«H-P»时这就变得相当棘手。
%Generating initials for name parts from a given name involves some difficulties when you have names with prefixes, diacritics, hyphens etc. Often, you want to ignore things like prefixes when generating initials so that the initials for «al-Hasan» is just «H» instead of «a-H». This is tricky when you also have names like «Ho-Pun» where you want the initials to be «H-P», for example.

\begin{ltxsyntax}

\cmditem{DeclareNoinit}{specification}

定义用于在生成首字母前从姓名剥离的匹配正则表达式。\prm{specification} 是\cmd{noinit} 指令的不分隔列表，\cmd{noinit} 指令指定从姓名中移除匹配内容的正则表达式。可以自由使用空格，制表符，行末符来调整代码呈现格式以达到满意代码显示效果，空行不允许。该命令只能用于导言中。
%Defines regular expressions to strip from names before generating initials. The \prm{specification} is an undelimited list of \cmd{noinit} directives which specify the regular expressions to remove from the name. Spaces, tabs and line endings may be used freely to visually arrange the \prm{specification}. Blank lines are not permissible. This command may only be used in the preamble.

\cmditem{noinit}{regexp}

可以给出任意数量的\cmd{noinit} 命令，每一个\cmd{noinit} 都用来指定从首字母生成系统能看到的姓名副本中去除\prm{regexp}。因为正则表达式常包含特殊字符，最好将他们用\cmd{regexp} 宏包围起来---使得能将表达式正确地传递给\biber 。
%Any number of \cmd{noinit} commands can be given each of which specifies to remove the \prm{regexp} from the copy of the name which the initials generation system sees. Since regular expressions usually contain special characters, it is best to enclose them in the provided \cmd{regexp} macro as shown---this will pass the expression through to \biber correctly.

\end{ltxsyntax}

如果没有\cmd{DeclareNoinit} 设置，\biber 采取默认方式为:
%If there is no \cmd{DeclareNoinit} specification, \biber will default to:

\begin{ltxexample}
\DeclareNoinit{
  % strip lowercase prefixes like 'al-' when generating initials from names
  \noinit{\regexp{<<\b\p{Ll}{2}\p{Pd}>>}}
  % strip some common diacritics when generating initials from names
  \noinit{\regexp{<<[\x{2bf}\x{2018}]>>}}
}
\end{ltxexample}
%
\biber 利用这一代码默认在生成首字母前从姓名中剥离小写的前缀和一对变音符。
%This \biber default strips a couple of diacritics and also strips lowercase prefixes from names before generating initials.

\subsubsection{排序微调}% Fine Tuning Sorting
\label{aut:ctm:nosort}
对排序进行微调是有用的，它可以忽略一些特殊域的某些部分。
%It can be useful to fine tune sorting so that it ignores certain parts of particular fields.

\begin{ltxsyntax}

\cmditem{DeclareNosort}{specification}

定义正则表达式用来在排序时对特定的域或者特定类型的域的内容做剥离处理。\prm{specification} 是\cmd{nosort} 指令的无分隔列表，\cmd{nosort} 指令用于定义正则表达式来移除特定域或特定类型的域中的某些内容。可以自由使用空格，制表符，行末符来调整代码呈现格式以达到满意视觉效果，空行不允许。该命令只能用于导言中。
%Defines regular expressions to strip from particular fields or types of fields when sorting. The \prm{specification} is an undelimited list of \cmd{nosort} directives which specify the regular expressions to remove from particular fields or type of field. Spaces, tabs and line endings may be used freely to visually arrange the \prm{specification}. Blank lines are not permissible. This command may only be used in the preamble.

\cmditem{nosort}{field or datafield set}{regexp}

可以给出任意数量的\cmd{nosort} 命令，这些命令将\prm{field} 或\prm{field type} 中的\prm{regexp} 移除。\prm{field type} 简单方便的构建了一个语义类似的域的集，在这些域中希望移除regexp。表\ref{aut:nosort} 给出了可用的域类型。因为正则表达式常包含特殊字符，最好将他们用\cmd{regexp} 宏包围起来---使得能将表达式正确地传递给\biber 。
Any number of \cmd{nosort} commands can be given each of which specifies to remove the \prm{regexp} from the \prm{field} or \prm{datafield set}. A \prm{datafield set} is simply a convenience grouping of semantically similar fields from which you might want to remove a regexp. See \secref{aut:ctm:dsets} for the avaiable sets, their members and customisation. Since regular expressions usually contain special characters, it is best to enclose them in the provided \cmd{regexp} macro as shown---this will pass the expression through to \biber correctly.


\end{ltxsyntax}

默认是:
%The default is:

\begin{ltxexample}
\DeclareNosort{
  % strip prefixes like 'al-' when sorting names
  \nosort{setnames}{\regexp{<<\A\p{L}{2}\p{Pd}>>}}
  % strip some diacritics when sorting names
  \nosort{setnames}{\regexp{<<[\x{2bf}\x{2018}]>>}}
}
\end{ltxexample}
%
排序时，\biber 默认从姓名中去除一对变音符以及前缀。如果排序时需要忽略掉\bibfield{title} 域开头的«The»，那么可以设置如下:
%This \biber default strips a couple of diacritics and also strips two-letter prefixes (like «Al-») from names when sorting. Suppose you wanted to ignore «The» at the beginning of a \bibfield{title} field when sorting:

\begin{ltxexample}
\DeclareNosort{
  \nosort{<<title>>}{\regexp{<<\AThe\s+>>}}
}
\end{ltxexample}
%
或者如果想要忽略任意标题域开头的«The»:
%Or if you wanted to ignore «The» at the beginning of any title field:

\begin{ltxexample}
\DeclareNosort{
  \nosort{<<settitles>>}{\regexp{<<\AThe\s+>>}}
}
\end{ltxexample}

\begin{table}[h]
\tablesetup
\begin{tabular}{@{}V{0.5\textwidth}@{}V{0.5\textwidth}@{}}
\toprule
\multicolumn{1}{@{}H}{Field Type} &
\multicolumn{1}{@{}H}{Fields} \\
\cmidrule(r){1-1}\cmidrule{2-2}
|type_name| & |author| \\
             & |afterword| \\
             & |annotator| \\
             & |bookauthor| \\
             & |commentator| \\
             & |editor| \\
             & |editora| \\
             & |editorb| \\
             & |editorc| \\
             & |foreword| \\
             & |holder| \\
             & |introduction| \\
             & |namea| \\
             & |nameb| \\
             & |namec| \\
             & |shortauthor| \\
             & |shorteditor| \\
             & |translator| \\
|type_title| & |booktitle| \\
              & |eventtitle| \\
              & |issuetitle| \\
              & |journaltitle| \\
              & |maintitle| \\
              & |origtitle| \\
              & |title| \\
\bottomrule
\end{tabular}
\caption{\cmd{nosort} 中使用的域类型}%Field types for \cmd{nosort}
\label{aut:nosort}
\end{table}

\subsubsection{特殊域}% Special Fields
\label{aut:ctm:fld}
\secref{aut:bbx:fld:lab} 节的一些自动生成的域可以重新定制:
%Some of the automatically generated fields from \secref{aut:bbx:fld:lab} may be customized.

\begin{ltxsyntax}

\cmditem{DeclareLabelname}[entrytype, \dots]{specification}

当生成\bibfield{labelname} 域时(见\secref{aut:bbx:fld:lab})，定义要考虑的域。\prm{specification} 是\cmd{field} 命令的一个有序列表。这些域以列出的顺序进行检查，第一个有效的域作为\bibfield{labelname}，默认的定义为:
%Defines the fields to consider when generating the \bibfield{labelname} field (see \secref{aut:bbx:fld:lab}). The \prm{specification} is an ordered list of \cmd{field} commands. The fields are checked in the order listed and the first field which is available will be used as \bibfield{labelname}. This is the default definition:

\begin{ltxexample}
\DeclareLabelname{%
  \field{shortauthor}
  \field{author}
  \field{shorteditor}
  \field{editor}
  \field{translator}
}
\end{ltxexample}
%
\bibfield{labelname} 域可以全局的或者根据具体条目类型定制。如果给出了可选参数\prm{entrytype}，设置应用于相应的条目类型。如果没有给出，则是全局的。\prm{entrytype} 参数可以是逗号分隔的列表。该命令只能用于导言区。
%The \bibfield{labelname} field may be customized globally or on a per-type basis. If the optional \prm{entrytype} argument is given, the specification applies to the respective entry type. If not, it is applied globally. The \prm{entrytype} argument may be a comma"=separated list of values. This command may only be used in the preamble.

\cmditem{DeclareLabeldate}[entrytype, \dots]{specification}

当生成\bibfield{labelyear}, \bibfield{labelmonth}, \bibfield{labelday}, \bibfield{labelendyear}, \bibfield{labelendmonth} 和\bibfield{labelendday} 域(见\secref{aut:bbx:fld:lab})时，定义要考虑的日期成分。\prm{specification} 是\cmd{field} 或 \cmd{literal} 命令的有序列表。其中各项以列出的顺序检查，可用的第一项将复制为前述生成的域。注意: \cmd{field} 项不一定必须是数据模型中的<date>日期类型，所以可以创建假年标签，例如利用\bibfield{pubstate} 域的内容(如果存在该域)，适当地作为定义\cmd{DeclareLabeldate} 的年标签。注意: 当\cmd{literal} 命令被发现时，将总被使用，所以它应该放到列表的最后。如果\cmd{literal} 命令的值是一个有效的本地化字符串，那么它将会解析为当前语言的字符串，否则将作为文本字符串照抄。默认定义如下:
%Defines the date components to consider when generating \bibfield{labelyear}, \bibfield{labelmonth}, \bibfield{labelday}, \bibfield{labelendyear}, \bibfield{labelendmonth} and \bibfield{labelendday} fields (see \secref{aut:bbx:fld:lab}). The \prm{specification} is an ordered list of \cmd{field} or \cmd{literal} commands. The items are checked in the order listed and the first item which is available will be used to popluate the mentioned fields. Note that the \cmd{field} items do not have to be datetype <date> in the data model so that you can create pseudo-year labels by, for example, using a \bibfield{pubstate} field contents, if available, as the year label by defining \cmd{DeclareLabeldate} suitably. Note also that a \cmd{literal} command will always be used when found and so this should always be the last thing in the list. If the value of a \cmd{literal} command is a valid localisation string, then this will be resolved in the current language, otherwise the value is used as a literal string as-is. This is the default definition:

\begin{ltxexample}
\DeclareLabeldate{%
  \field{date}
  \field{year}
  \field{eventdate}
  \field{origdate}
  \field{urldate}
  \literal{nodate}
}
\end{ltxexample}
%
注意: \bibfield{date} 域由后端自动分割成为\bibfield{year}, \bibfield{month}\footnote{译者: 这是需要注意的，在设计样式时判断日期域存在要用year而不是date，因为date已经自动解析分割了。}，它们在默认的数据模型中也是有效域。为了支持传统的数据，比如直接设置\bibfield{year} 和/或 \bibfield{month}，\cmd{DeclareLabeldate} 中的<\bibfield{date}>设置也将匹配\bibfield{year} 和\bibfield{month}，如果它们存在。
%Note that the \bibfield{date} field is split by the backend into \bibfield{year}, \bibfield{month} which are also valid fields in the default data model. In order to support legacy data which directly sets \bibfield{year} and/or \bibfield{month}, the specification <\bibfield{date}> in \cmd{DeclareLabeldate} will also match \bibfield{year} and \bibfield{month} fields, if present.
\bibfield{label*} 域可以全局的或者根据具体条目类型定制。如果给出了可选参数\prm{entrytype}，设置应用于相应的条目类型。如果没有给出，则是全局的。\prm{entrytype} 参数可以是逗号分隔的列表。该命令只能用于导言区。另见\secref{aut:bbx:fld:dat} 节。
%The \bibfield{label*} fields may be customized globally or on a per-type basis. If the optional \prm{entrytype} argument is given, the specification applies to the respective entry type. If not, it is applied globally. The \prm{entrytype} argument may be a comma"=separated list of values. This command may only be used in the preamble. See also \secref{aut:bbx:fld:dat}.

\cmditem{DeclareExtradate}{specification}

Defines how \biber tracks information used to construct the \bibfield{extradate} field. This field (see \secref{aut:bbx:fld:lab}) is printed to disambiguate works by the same author which occur in the same date scope. By default, the date scope is the year and so two works by the same author within the same year will have different \bibfield{extradate} values which are used to disambiguate the works in the bibliography in the usual manner seen in many authoryear type styles. The \prm{specification} is one or more \cmd{scope} specifications which can contain one or more \cmd{field} specifications. Within a \cmd{scope}, the existence of each \cmd{field} will be checked and if found, the first \cmd{field} is used and the rest are ignored. This allows a fallback in case certain fields are not available in all entries. All \cmd{scope}s are used to track information and \cmd{scope}s should be specified in decreasing order of generality (e.g. year then month then day etc) The default definition is:

\begin{ltxexample}
\DeclareExtradate{%
  \scope{
    \field{labelyear}
    \field{year}
  }
}
\end{ltxexample}
%
This means that the \bibfield{labelyear} field only (or \bibfield{year} if this does not exist) will be used to track works by the same author. With the following datasource entries:

\begin{lstlisting}[style=bibtex]{}
@BOOK{extra1,
  AUTHOR = {John Doe},
  DATE   = {2001-01}
}

@BOOK{extra2,
  AUTHOR = {John Doe},
  DATE   = {2001-02}
}
\end{lstlisting}
%
The default definition would result in:

\begin{lstlisting}{}
Doe 2001a
Doe 2001b
\end{lstlisting}
%
Here, \bibfield{extradate} only considers the \bibfield((label)year) information and since this is identical, disambiguation is required. However, consider the following definition:
\begin{ltxexample}
\DeclareExtradate{%
  \scope{
    \field{labelyear}
    \field{year}
  }
  \scope{
    \field{labelmonth}
  }
}
\end{ltxexample}
%
The result would be:
\begin{lstlisting}{}
Doe 2001
Doe 2001
\end{lstlisting}
%
If only years were printed, this would be ambiguous because \bibfield{extradate} now considers \bibfield{labelmonth} and since this differs, no disambiguation is necessary. Care should therefore be taken to synchronise the printed information with the \bibfield{extradate} disambiguation settings. Notice that the second definition is <month-in-year> disambiguation and quite different from:
\begin{ltxexample}
\DeclareExtradate{%
  \scope{
    \field{labelmonth}
  }
}
\end{ltxexample}
%
which is just plain <month> disambiguation which is very unlikely to be what you ever want to do since this disambiguation only based on month and ignores the year entirely. \bibfield{extradate} calculation should almost always be based on all information down to the resolution you require. For example, if you wish to disambiguate right down to the hour level (perhaps useful in large bibliographies of rapidly changing online material), you would specify something like this:
\begin{ltxexample}
\DeclareExtradate{%
  \scope{
    \field{labelyear}
    \field{year}
  }
  \scope{
    \field{labelmonth}
  }
  \scope{
    \field{labelday}
  }
  \scope{
    \field{labelhour}
  }
}
\end{ltxexample}
%
Entries without the specified granularity of information will disambiguate at the lowest granularity they contain, so, for example, with:
\begin{ltxexample}
\DeclareExtradate{%
  \scope{
    \field{labelyear}
    \field{year}
  }
  \scope{
    \field{labelmonth}
  }
}
\end{ltxexample}
%
\begin{lstlisting}[style=bibtex]{}
@BOOK{extra1,
  AUTHOR = {John Doe},
  DATE   = {2001}
}

@BOOK{extra2,
  AUTHOR = {John Doe},
  DATE   = {2001}
}
\end{lstlisting}
%
The result would still be:

\begin{lstlisting}{}
Doe 2001a
Doe 2001b
\end{lstlisting}
%
This command may only be used in the preamble.
\cmditem{DeclareLabeltitle}[entrytype, \dots]{specification}

定义生成\bibfield{labeltitle} 域(见\secref{aut:bbx:fld:lab})时要考虑的域。\prm{specification} 是\cmd{field} 命令的一个有序列表。这些域以给出的顺序检查，第一个有效的域作为\bibfield{labeltitle}，默认的定义是:
%Defines the fields to consider when generating the \bibfield{labeltitle} field (see \secref{aut:bbx:fld:lab}). The \prm{specification} is an ordered list of \cmd{field} commands. The fields are checked in the order listed and the first field which is available will be used as \bibfield{labeltitle}. This is the default definition:

\begin{ltxexample}
\DeclareLabeltitle{%
  \field{shorttitle}
  \field{title}
}
\end{ltxexample}
%
\bibfield{labeltitle} 可以全局的或者根据具体条目类型定义。如果给出了可选参数\prm{entrytype}，设置应用于相应的条目类型。如果没有给出，则是全局的。\prm{entrytype} 参数可以是逗号分隔的列表。该命令只能用于导言区。
%The \bibfield{labeltitle} field may be customized globally or on a per-type basis. If the optional \prm{entrytype} argument is given, the specification applies to the respective entry type. If not, it is applied globally. The \prm{entrytype} argument may be a comma"=separated list of values. This command may only be used in the preamble.

\end{ltxsyntax}

\subsubsection{数据继承(\bibfield{crossref})}% Data Inheritance (\bibfield{crossref})
\label{aut:ctm:ref}

\biber 提供了高度可定制的交叉引用机制和灵活的数据继承规则。本节介绍这些配置接口。默认配置见\apxref{apx:ref} 节。关于术语: \emph{child} 或\emph{target} 是具有\bibfield{crossref} 域的条目，\emph{parent} 或\emph{source} 是\bibfield{crossref} 域指向的条目。子条目从父条目继承数据:
%\biber features a highly customizable cross-referencing mechanism with flexible data inheritance rules. This sections deals with the configuration interface. See \apxref{apx:ref} for the default configuration. A note on terminology: the \emph{child} or \emph{target} is the entry with the \bibfield{crossref} field, the \emph{parent} or \emph{source} is the entry the \bibfield{crossref} field points to. The child inherits data from the parent.

\begin{ltxsyntax}

\cmditem{DefaultInheritance}[exceptions]{options}

配置默认的继承行为。该命令只能用于导言区。默认的继承行为可以通过下面的\prm{options} 定制:
%Configures the default inheritance behavior. This command may only be used in the preamble. The default behavior may be customized be setting the following \prm{options}:

\begin{optionlist*}

\boolitem[true]{all} 是否默认从父条目继承所有的域
%\boolitem[true]{all} Whether or not to inherit all fields from the parent by default.

\kvopt{all}{true} means that the child entry inherits all fields from the parent, unless a more specific inheritance rule has been set up with \cmd{DeclareDataInheritance}. If an inheritance rule is defined for a field, data inheritance is controlled by that rule. \kvopt{all}{false} means that no data is inherited from the parent by default and each field to be inherited requires an explicit inheritance rule set up with \cmd{DeclareDataInheritance}. The package default is \kvopt{all}{true}.


\kvopt{all}{true} 意为子条目从父条目继承所有域，除非有\cmd{DeclareDataInheritance} 设置的更具体的继承规则。如果对于一个域定义了继承规则，则数据继承由该规则控制。
\kvopt{all}{false} 意为默认不从父条目继承数据，每个域都需要根据\cmd{DeclareDataInheritance} 设定的明确继承规则来执行继承。包默认是\kvopt{all}{true}。

\boolitem[false]{override} 是否用源域覆盖目标域，当两者都存在时。该选项能作用于自动继承和显式继承两种规则。包默认是\kvopt{override}{false}，即子条目存在的域都不覆盖。
%\boolitem[false]{override} Whether or not to overwrite target fields with source fields if both are defined. This applies both to automatic inheritance and to explicit inheritance rules. The package default is \kvopt{override}{false}, \ie existing fields of the child entry are not overwritten.

\valitem{ignore}{csv list of uniqueness options}

该选项的取值是一个逗号分隔的列表，由一个或多个<singletitle>, <uniquetitle>, <uniquebaretitle> 和/或 <uniquework>构成。该选项的目的是，当会触发这些信息追踪的域(表\ref{use:opt:wu})被继承时，忽略这三个选项的追踪信息。一个例子是，假设有多个\bibtype{book} 条目都引用一个\bibtype{mvbook} 条目中的\bibfield{author} 域。你可能需要一个\cmd{ifsingletitle} 判断来返回<true>，这一作者的唯一著作(<work>)是\bibtype{mvbook} 条目。类似的情况也会出现在应用\cmd{ifuniquetitle}, \cmd{ifuniquebaretitle}，\cmd{ifuniquework} 判断时。\opt{ignore} 选项列出需要忽略追踪信息的判断，当继承的域会引发它们产生追踪信息时。思路是一个继承的域不参与决定参考文献数据中姓名/标题组合的唯一性。例如，下面修改的默认设置将会忽略\opt{singletitle} 和\opt{uniquetitle} 追踪:
%This option takes a comma-separated list of one of more of <singletitle>, <uniquetitle>, <uniquebaretitle> and/or <uniquework>. The purpose of this option is to ignore tracking information for these three options when the field which would trigger the tracking (\tabref{use:opt:wu}) is inherited. An example---Suppose that you have several \bibtype{book} entries which all crossref a \bibtype{mvbook} from which they get their \bibfield{author} field. You might reasonably want the \cmd{ifsingletitle} test to return <true> for this author as their only <work> is the \bibtype{mvbook}. Similar comments would apply to situations involving the \cmd{ifuniquetitle}, \cmd{ifuniquebaretitle} and \cmd{ifuniquework} tests. The \opt{ignore} option lists which of these should have their tracking information ignored when the fields which would trigger them are inherited. The idea is that the presence of an inherited field does not contribute towards the determination of whether some combination of name/title is unique in the bibliographic data. For example, this modified default setting would ignore \opt{singletitle} and \opt{uniquetitle} tracking:

\begin{ltxexample}
\DefaultInheritance{ignore={singletitle,uniquetitle}, all=true, override=false}
\end{ltxexample}
%
当然，当继承的域不参与信息追踪，追踪忽略不做任何处理。只有表\ref{use:opt:wu} 列出的域与这一选项相关。
%Of course, the ignoring of tracking does nothing if the fields inherited do not play a role in tracking. Only the fields listed in \tabref{use:opt:wu} are relevant to this option.

\end{optionlist*}

可选的\prm{exceptions} 是\cmd{except} 指令的一个不分隔列表。可以自由使用空格，制表符，行末符来调整代码呈现格式以达到满意视觉效果，空行不允许。
%The optional \prm{exceptions} are an undelimited list of \cmd{except} directives. Spaces, tabs, and line endings may be used freely to visually arrange the \prm{exceptions}. Blank lines are not permissible.

\cmditem{except}{source}{target}{options}

定义默认继承规则的例外规则。
%Defines an exception to the default inheritance rules.

\cmd{DeclareDataInheritance} 为一个具体的\prm{source} 和\prm{target} 组合设置继承选项\prm{options}。\prm{source} 和\prm{target} 参数指定了父条目和子条目。星号匹配所有的类型，可用于任一参数中。
\cmd{DeclareDataInheritance} sets the inheritance \prm{options} for a specific \prm{source} and \prm{target} combination. The \prm{source} and \prm{target} arguments specify the parent and the child entry type. The asterisk matches all types and is permissible in either argument.


\cmditem{DeclareDataInheritance}[options]{source, \dots}{target, \dots}{rules}

定义继承规则，\prm{source} 和\prm{target} 参数指定了父条目和子条目。每个参数可以是单个条目，或者一个逗号分隔的类型列表或者星号。星号匹配所有的类型。\prm{rules} 是\cmd{inherit} 和\slash 或\cmd{noinherit} 指令的无分隔列表。可以自由使用空格，制表符，行末符来调整代码呈现格式以达到满意视觉效果，空行不允许。
%Declares inheritance rules. The \prm{source} and \prm{target} arguments specify the parent and the child entry type. Either argument may be a single entry type, a comma"=separated list of types, or an asterisk. The asterisk matches all entry types. The \prm{rules} are an undelimited list of \cmd{inherit} and\slash or \cmd{noinherit} directives. Spaces, tabs, and line endings may be used freely to visually arrange the \prm{rules}. Blank lines are not permissible. This command may only be used in the preamble. The options are:

\begin{optionlist*}

\valitem{ignore}{csv list of uniqueness options}

类似于上述\cmd{DefaultInheritance} 的\opt{ignore} 选项。当给出设置，它将高于由\cmd{DefaultInheritance} 设置的全局选项。下面示例中，当一个\bibtype{book} 条目从\bibtype{mvbook} 条目继承数据时，将忽略\opt{singletitle} 和\opt{uniquetitle} 追踪。
%As the \opt{ignore} option on \cmd{DefaultInheritance} explained above. When set here, it takes precedence over any global options set with \cmd{DefaultInheritance}. For example, this would ignore \opt{singletitle} and \opt{uniquetitle} tracking for a \bibtype{book} inheriting from a \bibtype{mvbook}.

\begin{ltxexample}
\DeclareDataInheritance[ignore={singletitle,uniquetitle}]{mvbook}{book}{<<...>>}
\end{ltxexample}

\end{optionlist*}

\cmditem{inherit}[option]{source}{target}

定义一个继承规则，通过从\prm{source} 域向\prm{target} 域映射实现，\prm{option} 可以是:
%Defines an inheritance rule by mapping a \prm{source} field to a \prm{target} field. \prm{option} can be one of

\begin{optionlist*}

\boolitem[false]{override}

类似于上述\cmd{DefaultInheritance} 中的\opt{override} 选项，当给出设置，它将高于\cmd{DefaultInheritance} 设置的全局选项。
%As the \opt{override} option for \cmd{DefaultInheritance} explained above. When set here, it takes precedence over any global options set with \cmd{DefaultInheritance}.

\end{optionlist*}

\cmditem{noinherit}{source}

无条件阻止从\prm{source} 域的继承。
%Unconditionally prevents inheritance of the \prm{source} field.

\csitem{ResetDataInheritance}

清除由\cmd{DeclareDataInheritance} 定义所有继承规则。该命令只能用于导言中。
%Clears all inheritance rules defined with \cmd{DeclareDataInheritance}. This command may only be used in the preamble.

\end{ltxsyntax}

下面是一些实际示例:
%Here are some practical examples:

\begin{ltxexample}
\DefaultInheritance{<<all=true>>,<<override=false>>}
\end{ltxexample}
%
该示例给出了怎么设置默认的继承行为。该设置是包的默认设置。
%This example shows how to configure the default inheritance behavior. The above settings are the package defaults.

\begin{ltxexample}
\DefaultInheritance[
  \except{<<*>>}{<<online>>}{<<all=false>>}
]{all=true,override=false}
\end{ltxexample}
%
该示例类似于上一示例，差别在于增加了一个例外规则:\bibtype{online} 类型的条目默认将不从任何父条目继承数据。
%This example is similar to the one above but adds one exception: entries of type \bibtype{online} will, by default, not inherit any data from any parent.

\begin{ltxexample}
\DeclareDataInheritance{<<collection>>}{<<incollection>>}{
  \inherit{<<title>>}{<<booktitle>>}
  \inherit{<<subtitle>>}{<<booksubtitle>>}
  \inherit{<<titleaddon>>}{<<booktitleaddon>>}
}
\end{ltxexample}
%
到目前为止，我们已经看到了标准的继承设置。例如\kvopt{all}{true} 意味着一个源条目的\bibfield{publisher} 域将被复制到目标条目的\bibfield{publisher} 域中。然而，在一些情况下，需要非对称的映射。它们通过\cmd{DeclareDataInheritance} 来定义。上面的示例为\bibtype{incollection} 条目引用\bibtype{collection} 信息设置了3条典型规则。将源条目的\bibfield{title} 及其相关域映射到目标条目对应的\bibfield{booktitle} 相关域中。
%So far we have looked at setting up standard inheritance. For example, \kvopt{all}{true} means that the \bibfield{publisher} field of a source entry is copied to the \bibfield{publisher} field of the target entry. In some cases, however, asymmetric mappings are required. They are defined with \cmd{DeclareDataInheritance}. The above example sets up three typical rules for \bibtype{incollection} entries referencing a \bibtype{collection}. We map the \bibfield{title} and related fields of the source to the corresponding \bibfield{booktitle} fields of the target.

\begin{ltxexample}
\DeclareDataInheritance{<<mvbook,book>>}{<<inbook,bookinbook>>}{
  \inherit{<<author>>}{<<author>>}
  \inherit{<<author>>}{<<bookauthor>>}
}
\end{ltxexample}
%
这一规则是一个一对多映射的规则: 为了能运行压缩\bibfield{inbook}\slash \bibfield{bookinbook} 条目，它将源条目的\bibfield{author} 域映射到目标条目的\bibfield{author} 和\bibfield{bookauthor} 域中。源可以是一个\bibtype{mvbook} 或\bibtype{book} 条目，目标可以是一个\bibtype{inbook} 或\bibtype{bookinbook} 条目。
%This rule is an example of one-to-many mapping: it maps the \bibfield{author} field of the source to both the \bibfield{author} and the \bibfield{bookauthor} fields of the target in order to allow for compact \bibfield{inbook}\slash \bibfield{bookinbook} entries. The source may be either a \bibtype{mvbook} or a \bibtype{book} entry, the target either an \bibtype{inbook} or a \bibtype{bookinbook} entry.

\begin{ltxexample}
\DeclareDataInheritance{<<*>>}{<<inbook,incollection>>}{
  \noinherit{<<introduction>>}
}
\end{ltxexample}
%
这一规则阻止对\bibfield{introduction} 域的继承。应用的目标条目是\bibtype{inbook} 或 \bibtype{incollection}，源条目则是任意的。
%This rule prevents inheritance of the \bibfield{introduction} field. It applies to all targets of type
%\bibtype{inbook} or \bibtype{incollection}, regardless of the source entry type.

\begin{ltxexample}
\DeclareDataInheritance{<<*>>}{<<*>>}{
  \noinherit{<<abstract>>}
}
\end{ltxexample}
%
该规则应用于所有条目类型，阻止\bibfield{abstract} 域的继承。
%This rule, which applies to all entries, regardless of the source and target entry types, prevents inheritance of the \bibfield{abstract} field.

\begin{ltxexample}
\DefaultInheritance{all=true,override=false}
\ResetDataInheritance
\end{ltxexample}
%
该例展示怎么模拟实现传统的\bibtex 的交叉引用机制。它默认启用继承功能，禁止覆盖，并清除所有的其它规则和映射。
%This example demonstrates how to emulate traditional \bibtex's cross"=referencing mechanism. It enables inheritance by default, disables overwriting, and clears all other inheritance rules and mappings.

在一个参考文献条目中，当值是由\cmd{DeclareDatafieldSet}(\secref{aut:ctm:dsets})定义的数据域的集合，可以给出一个<noinherit>选项。这会阻止具体条目对在该集中的域的继承。例如:
%In a bibliography entry, you can give an option <noinherit> where the value
%is a datafield set defined with \cmd{DeclareDatafieldSet}
%(\secref{aut:ctm:dsets}). This will block inheritance of the fields in the
%set on a per-entry basis. For example:

\begin{ltxexample}
\DeclareDatafieldSet{nobtitle}{
  \member[field=booktitle]
}
\end{ltxexample}

\begin{lstlisting}[style=bibtex]{}
@INBOOK{s1,
  OPTIONS  = {noinherit=nobtitle},
  TITLE    = {Subtitle},
  CROSSREF = {s2}
}

@BOOK{s2,
  TITLE = {Title}
}
\end{lstlisting}
%
这里\bibfield{s2} 的\bibfield{TITLE} 域将不会被继承为 \bibfield{s1} 的\bibfield{BOOKTITLE}，这一继承之所以被阻止是因为\opt{noinherit} 选项的值是数据域集合，且集合中包含\bibfield{BOOKTITLE}域。
%Here, \bibfield{s1} will not inherit the \bibfield{TITLE} of \bibfield{s2}
%as \bibfield{BOOKTITLE} as this is blocked by the datafield set given as
%the value to the \opt{noinherit} option.
%

需要重点注意的是，如果他们已经具有某一类型日期的某一成分，子条目不会从父条目继承该类型日期的任何成分域。例如:
%One important thing to note is that children will never inherit any dateparts of a given type if they already contain a datepart of that type. So, for example:

\begin{lstlisting}[style=bibtex]{}
@INBOOK{b1,
  DATE     = {2004-03-03},
  ORIGDATE = {2004-03},
  CROSSREF = {b2}
}

@BOOK{b2,
  DATE      = {2004-03-03/2005-08-09},
  ORIGDATE  = {2004-03/2005-08},
  EVENTDATE = {2004-03/2005-08},
}
\end{lstlisting}
%
这里，\bibfield{b1} 条目将不会继承任何的\bibfield{endyear}, \bibfield{endmonth}, \bibfield{endday}, \bibfield{origendyear} or \bibfield{origendmonth}，因为这可能导致与自身日期的混乱。考虑默认继承规则，它将继承所有的\bibfield{event*} 日期成分。
%Here, \bibfield{b1} will not inherit any of \bibfield{endyear}, \bibfield{endmonth}, \bibfield{endday}, \bibfield{origendyear} or \bibfield{origendmonth} as this would make a mess of its own dates. It will, given the inheritance defaults, inherit all of the \bibfield{event*} date parts.



\subsection{辅助命令}%Auxiliary Commands
\label{aut:aux}
本节的工具用来分析和保存参考文献数据而不是对其进行格式化或者打印。
%The facilities in this section are intended for analyzing and saving bibliographic data rather than formatting and printing it.

\subsubsection{数据命令}%Data Commands
\label{aut:aux:dat}
本节的命令允许对未格式化的参考文献数据进行底层访问。这些命令不是用来输出，而是用来将数据保存到临时宏中，可以用于下一步的比较。
%The commands in this section grant low"=level access to the unformatted bibliographic data. They are not intended for typesetting but rather for things like saving data to a temporary macro so that it may be used in a comparison later.

\begin{ltxsyntax}

\cmditem{thefield}{field}

展开为未格式化的\prm{field}。如果\prm{field} 未定义那么展开为一个空字符串。
%Expands to the unformatted \prm{field}. If the \prm{field} is undefined, this command expands to an empty string.

\cmditem{strfield}{field}

类似于\cmd{thefield} 命令，但其值经自动处理(sanitized)，以便安全地用于构成控制序列名。
%Similar to \cmd{thefield}, except that the field is automatically sanitized such that its value may safely be used in the formation of a control sequence name.

\cmditem{csfield}{field}

类似于\cmd{thefield} 命令，但禁止展开
%Similar to \cmd{thefield}, but prevents expansion.

\cmditem{usefield}{command}{field}

执行\prm{command} 命令使用未格式化的\prm{field} 作为其参数
%Executes \prm{command} using the unformatted \prm{field} as its argument.

\cmditem{thelist}{literal list}

%Expands to the unformatted \prm{literal list}. If the list is undefined, this command expands to an empty string. Note that this command will dump the \prm{literal list} in the internal format used by this package. This format is not suitable for printing.
展开为未格式化的\prm{literal list}。如果list未定义那么展开为一个空字符串。注意该命令中将\prm{literal list} 转存为本宏包使用的内部格式。这一格式不适合打印。

\cmditem{strlist}{literal list}

类似于\cmd{thelist}，差别在于该命令能自动处理列表的内部表示，因此列表的值可以安全地用于控制序列名的构建。
%Similar to \cmd{thelist}, except that the list internal representation is automatically sanitized such that its value may safely be used in the formation of a control sequence name.

\cmditem{thefirstlistitem}{literal list}

Expands to the unformatted first item in \prm{literal list}. If the \prm{literal list} is undefined, this command expands to an empty string.

\cmditem{strfirstlistitem}{literal list}

Similar to \cmd{thefirstlistitem}, except that the item is automatically sanitized such that its value may safely be used in the formation of a control sequence name.

\cmditem{usefirstlistitem}{command}{literal list}

Executes \prm{command} using the unformatted first item of \prm{literal list} as its argument.

\cmditem{thename}{name list}

%Expands to the unformatted \prm{name list}. If the list is undefined, this command expands to an empty string. Note that this command will dump the \prm{name list} in the internal format used by this package. This format is not suitable for printing.
展开为未格式化的\prm{name list}。如果list未定义那么展开为一个空字符串。注意该命令中将\prm{name list} 转存为本宏包使用的内部格式。这一格式不适合打印。

\cmditem{strname}{name list}

类似于\cmd{thename}，差别在于该命令能自动处理列表的内部表示，因此列表的值可以安全地用于控制序列名的构建。
%Similar to \cmd{thename}, except that the name internal representation is automatically sanitized such that its value may safely be used in the formation of a control sequence name.

\cmditem{savefield}{field}{macro}
\cmditem*{savefield*}{field}{macro}

将未格式化的\prm{field} 拷贝到一个\prm{macro} 中。不带星的命令全局的定义\prm{macro}，而带星的命令是局部定义。
%Copies an unformatted \prm{field} to a \prm{macro}. The regular variant of this command defines the \prm{macro} globally, the starred one works locally.

\cmditem{savelist}{literal list}{macro}
\cmditem*{savelist*}{literal list}{macro}

将未格式化的\prm{literal list} 拷贝到一个\prm{macro} 中。不带星的命令全局的定义\prm{macro}，而带星的命令是局部定义。
%Copies an unformatted \prm{literal list} to a \prm{macro}. The regular variant of this command defines the \prm{macro} globally, the starred one works locally.

\cmditem{savename}{name list}{macro}
\cmditem*{savename*}{name list}{macro}

将未格式化的\prm{name list} 拷贝到一个\prm{macro} 中。不带星的命令全局的定义\prm{macro}，而带星的命令是局部定义。
%Copies an unformatted \prm{name list} to a \prm{macro}. The regular variant of this command defines the \prm{macro} globally, the starred one works locally.

\cmditem{savefieldcs}{field}{csname}
\cmditem*{savefieldcs*}{field}{csname}

类似于\cmd{savefield} 命令，但将控制序列名\prm{csname}(即没有斜杠)作为参数，而不是宏。
%Similar to \cmd{savefield}, but takes the control sequence name \prm{csname} (without a leading backslash) as an argument, rather than a macro name.

\cmditem{savelistcs}{literal list}{csname}
\cmditem*{savelistcs*}{literal list}{csname}

类似于\cmd{savelist} 命令，但将控制序列名\prm{csname}(即没有斜杠)作为参数，而不是宏。
%Similar to \cmd{savelist}, but takes the control sequence name \prm{csname} (without a leading backslash) as an argument, rather than a macro name.

\cmditem{savenamecs}{name list}{csname}
\cmditem*{savenamecs*}{name list}{csname}

类似于\cmd{savename} 命令，但将控制序列名\prm{csname}(即没有斜杠)作为参数，而不是宏。
%Similar to \cmd{savename}, but takes the control sequence name \prm{csname} (without a leading backslash) as an argument, rather than a macro name.

\cmditem{restorefield}{field}{macro}

从之前用\cmd{savefield} 命令定义的\prm{macro} 中将\prm{field} 恢复回来。该域是在局部范围内恢复。
%Restores a \prm{field} from a \prm{macro} defined with \cmd{savefield} before. The field is restored within a local scope.

\cmditem{restorelist}{literal list}{macro}

从之前用\cmd{savelist} 命令定义的\prm{macro} 中将\prm{literal list} 恢复回来。该list是在局部范围内恢复。
%Restores a \prm{literal list} from a \prm{macro} defined with \cmd{savelist} before. The list is restored within a local scope.

\cmditem{restorename}{name list}{macro}

从之前用\cmd{savename} 命令定义的\prm{macro} 中将\prm{name list} 恢复回来。该list是在局部范围内恢复。
%Restores a \prm{name list} from a \prm{macro} defined with \cmd{savename} before. The list is restored within a local scope.

\cmditem{clearfield}{field}

在局部范围内清除\prm{field}。以这种方式清除的域对于后续的数据命令来说相当于没有定义。
%Clears the \prm{field} within a local scope. A field cleared this way is treated as undefined by subsequent data commands.

\cmditem{clearlist}{literal list}

在局部范围内清除\prm{literal list}。以这种方式清除的list对于后续的数据命令来说相当于没有定义。
%Clears the \prm{literal list} within a local scope. A list cleared this way is treated as undefined by subsequent data commands.

\cmditem{clearname}{name list}

在局部范围内清除\prm{name list}。以这种方式清除的list对于后续的数据命令来说相当于没有定义。
%Clears the \prm{name list} within a local scope. A list cleared this way is treated as undefined by subsequent data commands.

\end{ltxsyntax}

\subsubsection{独立判断命令}%Stand-alone Tests
\label{aut:aux:tst}
本节的命令是不同类型的独立(stand-alone)判断命令，用于参考文献著录和标注样式中。
%The commands in this section are various kinds of stand"=alone tests for use in bibliography and citation styles.

\begin{ltxsyntax}

\cmditem{if$<$datetype$>$julian}{true}{false}

当日期<datetype>date因为\opt{julian} 和\opt{gregorianstart} 选项的设置转换为儒略历(Julian Calendar) 时，展开为\prm{true}。
%Expands to \prm{true} if the date <datetype>date (\opt{date}, \opt{urldate}, \opt{eventdate} etc.) Was converted to the Julian Calendar due to the settings of the \opt{julian}and \opt{gregorianstart}  options.

\cmditem{ifdatejulian}{true}{false}

类似于\cmd{if$<$datetype$>$julian} 但用于\cmd{mkbibdate*} 格式化命令中(\secref{aut:fmt:lng})，在这些格式化命令中恰当使用\cmd{if$<$datetype$>$julian} 命令等价于应用该命令。
%As \cmd{if$<$datetype$>$julian} but for use in \cmd{mkbibdate*} formatting commands (\secref{aut:fmt:lng}) inside which the appropriate \cmd{if$<$datetype$>$julian} command is aliased to this command.

\cmditem{if$<$datetype$>$dateera}{era}{true}{false}

当日期<datetype>date(\opt{date}, \opt{urldate}, \opt{eventdate} 等)指定了一个纪元等于\prm{era}，则展开为\prm{true}，否则展开为\prm{false}。\biber 确认并在\file{.bbl} 文件中传递的可用\prm{era} 字符串是:
%Expands to \prm{true} if the date <datetype>date (\opt{date}, \opt{urldate}, \opt{eventdate} etc.) has an era specification equal to \prm{era} and \prm{false} otherwise.  The supported \prm{era} strings which \biber determines and passes in the \file{.bbl} are:

\begin{description}
\item[bce]  BCE/BC era
\item[ce]  CE/AD era
\end{description}

该命令用于确定是否打印\secref{aut:lng:key:dt} 节的本地化字符串\footnote{译者:这里的location strings 应是笔误，而应是local strings，这从\secref{aut:lng:key:dt} 节内容可以看出}。
%This command is useful for determining whether to print the location
%strings in \secref{aut:lng:key:dt}.

\cmditem{ifdateera}{era}{true}{false}

类似于\cmd{if$<$datetype$>$dateera}，但用于\cmd{mkbibdate*} 格式化命令(\secref{aut:fmt:lng})，在这些格式化命令中恰当使用\cmd{if$<$datetype$>$dateera} 命令等价于应用该命令。
%As \cmd{if$<$datetype$>$dateera} but for use in \cmd{mkbibdate*} formatting commands (\secref{aut:fmt:lng}) inside which the appropriate \cmd{if$<$datetype$>$dateera} command is aliased to this command.

\cmditem{if$<$datetype$>$datecirca}{true}{false}

当日期<datetype>date(\opt{date}, \opt{urldate}, \opt{eventdate} 等)在数据源中具有一个<circa>标记时，则展开为\prm{true}，否则展开为\prm{false}。参见\secref{bib:use:dat}。该命令用于确定是否打印\secref{aut:lng:key:dt} 节中的本地化字符串。
%Expands to \prm{true} if the date <datetype>date (\opt{date}, \opt{urldate}, \opt{eventdate} etc.) had a <circa> marker in the source and \prm{false} otherwise.  See \secref{bib:use:dat}. This command is useful for determining whether to print the location strings in \secref{aut:lng:key:dt}.

\cmditem{ifdatecirca}{true}{false}

类似于\cmd{if$<$datetype$>$datecirca}，但用于\cmd{mkbibdate*} 格式化命令(\secref{aut:fmt:lng})，在这些格式化命令中恰当使用的\cmd{if$<$datetype$>$datecirca} 命令等价于该命令。
%As \cmd{if$<$datetype$>$datecirca} but for use in \cmd{mkbibdate*} formatting commands (\secref{aut:fmt:lng}) inside which the appropriate \cmd{if$<$datetype$>$datecirca} command is aliased to this command.

\cmditem{if$<$datetype$>$dateuncertain}{true}{false}

当日期<datetype>date(\opt{date}, \opt{urldate}, \opt{eventdate} 等)在数据源中具有一个不确定标记时，则展开为\prm{true}，否则展开为\prm{false}。参见\secref{bib:use:dat}。该命令用于确定是否打印例如年份后的一个问号。
%Expands to \prm{true} if the date <datetype>date (\opt{date}, \opt{urldate}, \opt{eventdate} etc.) had an uncertainty marker in the source and \prm{false} otherwise.  See \secref{bib:use:dat}. This command is useful for determining whether to print, for example, a question mark after a year.

\cmditem{ifdateuncertain}{true}{false}

类似于\cmd{if$<$datetype$>$dateuncertain}，但用于\cmd{mkbibdate*} 格式化命令(\secref{aut:fmt:lng})，在这些格式化命令中恰当使用\cmd{if$<$datetype$>$dateuncertain} 命令等价于应用该命令。
%As \cmd{if$<$datetype$>$dateuncertain} but for use in \cmd{mkbibdate*} formatting commands (\secref{aut:fmt:lng}) inside which the appropriate \cmd{if$<$datetype$>$dateuncertain} command is aliased to this command.

\cmditem{ifenddateuncertain}{true}{false}

类似于\cmd{ifend$<$datetype$>$dateuncertain}，但用于\cmd{mkbibdate*} 格式化命令(\secref{aut:fmt:lng})，在这些格式化命令中恰当使用\cmd{ifend$<$datetype$>$dateuncertain} 命令等价于应用该命令。
%As \cmd{ifend$<$datetype$>$dateuncertain} but for use in \cmd{mkbibdate*} formatting commands (\secref{aut:fmt:lng}) inside which the appropriate \cmd{ifend$<$datetype$>$dateuncertain} command is aliased to this command.
\cmditem{if$<$datetype$>$dateunknown}{true}{false}

%Expands to \prm{true} if the date <datetype>date (\opt{date}, \opt{urldate}, \opt{eventdate} etc.) is marked as unknown (as opposed to open) in the source and \prm{false} otherwise.  See \secref{bib:use:dat}.
展开为\prm{true}，如果数据源中日期<datetype>date (\opt{date}, \opt{urldate}, \opt{eventdate} etc.) 标记为未知(与未终止(open)不同)，
否则展开为\prm{false}，见 \secref{bib:use:dat}节。


\cmditem{ifdateunknown}{true}{false}

%As \cmd{if$<$datetype$>$dateunknown} but for use in \cmd{mkbibdate*} formatting commands (\secref{aut:fmt:lng}) inside which the appropriate \cmd{if$<$datetype$>$dateunknown} command is aliased to this command.
类似于\cmd{if$<$datetype$>$dateunknown}，但用在\cmd{mkbibdate*} 格式化命令中(见\secref{aut:fmt:lng})，
在这类命令中类似的\cmd{if$<$datetype$>$dateunknown}命令逻辑与\cmd{ifdateunknown}一致。


\cmditem{ifenddateunknown}{true}{false}

%As \cmd{ifend$<$datetype$>$dateunknown} but for use in \cmd{mkbibdate*} formatting commands (\secref{aut:fmt:lng}) inside which the appropriate \cmd{ifend$<$datetype$>$dateunknown} command is aliased to this command.
类似于\cmd{ifend$<$datetype$>$dateunknown}，但用在\cmd{mkbibdate*} 格式化命令中(见\secref{aut:fmt:lng})，
在这类命令中类似的\cmd{ifend$<$datetype$>$dateunknown}命令逻辑与\cmd{ifenddateunknown}一致。


\cmditem{iflabeldateisdate}{true}{false}

%Expands to \prm{true} if labeldate is defined and was obtained from date, and to \prm{false} otherwise.
展开为\prm{true}如果labeldate已定义且从date中获取，否则为\prm{false}



\cmditem{ifdatehasyearonlyprecision}{datetype}{true}{false}

%Expands to \prm{true} if the \prm{datetype}date is defined and would be shown with year precision \cmd{print$<$datetype$>$date}, and to false otherwise.
展开为\prm{true}，如果\prm{datetype}date已定义，且将在\cmd{print$<$datetype$>$date}命令中以明确年份显示，否则为\prm{false}。


\cmditem{ifdatehastime}{datetype}{true}{false}

%Expands to \prm{true} if the \prm{datetype}date is defined, has a time component and \opt{$<$datetype$>$dateusetime} is true, and to false otherwise.
展开为\prm{true}，如果\prm{datetype}date已定义，且包含时间成分，且\opt{$<$datetype$>$dateusetime}为\prm{true}，否则为\prm{false}。


\cmditem{ifdateshavedifferentprecision}{datetype1}{datetype2}{true}{false}

%Expands to \prm{true} if the two dates \prm{datetype1} and \prm{datetype2} would show in different precision when printed with \cmd{print$<$datetype1$>$date} and \cmd{print$<$datetype2$>$date} respectively, and to \prm{false} otherwise.
展开为\prm{true}，如果两个日期\prm{datetype1}和\prm{datetype2}以不同精度在\cmd{print$<$datetype1$>$date}和
\cmd{print$<$datetype2$>$date}命令中分别打印时，否则展开为\prm{false}。


\cmditem{ifdateyearsequal}{datetype1}{datetype2}{true}{false}

%Expands to \prm{true} if the two dates \prm{datetype1} and \prm{datetype2} have the same year and era. Since the sign of the date is saved in the era field, years should be compared using this command to avoid confusion when the two years have opposite signs

展开为\prm{true}，如果两个日期\prm{datetype1}和\prm{datetype2}具有相同的年份和纪年。
因为日期纪年的符号保存在era域中，可以利用该命令来避免混淆，当两个年份具有相反纪年时，比如公元前和公元后。

\cmditem{ifdatesequal}{datetype1}{datetype2}{true}{false}

Expands to \prm{true} if the two dates \prm{datetype1} and \prm{datetype2} are the same. Here \prm{datetype2} may be the <end> bit of \prm{datetype1} (or vice versa).

\cmditem{ifdaterangesequal}{datetype1}{datetype2}{true}{false}

Expands to \prm{true} if the two date ranges---that is the start and the end date---\prm{datetype1} and \prm{datetype2} are the same.

\cmditem{ifcaselang}[language]{true}{false}

如果可选的\prm{language} 是\cmd{DeclareCaseLangs}(见\secref{aut:aux:msc})声明的语言之一，展开为\prm{true}，否则展开为\prm{false}。当可选参数不给出时，对\cmd{currentlang} 值进行判断。
%Expands to \prm{true} if the the optional \prm{language} is one of those
%declared by \cmd{DeclareCaseLangs} (see \secref{aut:aux:msc}) and to
%\prm{false} otherwise. Without the optional argument, checks the current
%value of \cmd{currentlang}.

\cmditem{ifsortingnamekeytemplatename}{string}{true}{false}

如果\prm{string} 与当前作用范围内姓名排序关键词格式名(见\ref{aut:ctm:srt})相同则展开为\prm{true}，否则展开为\prm{false}。
%Expands to \prm{true} if the \prm{string} is equal to the current in scope sorting name key template name (see \ref{aut:ctm:srt}), and to \prm{false} otherwise.

\cmditem{ifuniquenametemplatename}{string}{true}{false}

%Expands to \prm{true} if the \prm{string} is equal to the current in scope uniqueness name key template name (see \ref{aut:ctm:srt}), and to \prm{false} otherwise.
展开为\prm{true}，如果\prm{string}等于当前范围内的唯一姓名关键字模板名(见\ref{aut:ctm:srt})，否则展开为\prm{false}。


\cmditem{iflabelalphanametemplatename}{string}{true}{false}

%Expands to \prm{true} if the \prm{string} is equal to the current in scope alphabetic label name template name (see \ref{aut:ctm:srt}), and to \prm{false} otherwise.
展开为\prm{true}，如果\prm{string}等于当前范围内的唯一标签姓名模板名(见\ref{aut:ctm:srt})，否则展开为\prm{false}。

\cmditem{iffieldundef}{field}{true}{false}

展开为\prm{true}，如果\prm{field} 未定义，否则展开为\prm{false}
%Expands to \prm{true} if the \prm{field} is undefined, and to \prm{false} otherwise.

\cmditem{iflistundef}{literal list}{true}{false}

展开为\prm{true}，如果\prm{literal list} 未定义，否则展开为\prm{false}
%Expands to \prm{true} if the \prm{literal list} is undefined, and to \prm{false} otherwise.

\cmditem{ifnameundef}{name list}{true}{false}

展开为\prm{true}，如果\prm{name list} 未定义，否则展开为\prm{false}
%Expands to \prm{true} if the \prm{name list} is undefined, and to \prm{false} otherwise.

\cmditem{iffieldsequal}{field 1}{field 2}{true}{false}

展开为\prm{true}，如果\prm{field 1} 和\prm{field 2} 相等，否则展开为\prm{false}
%Expands to \prm{true} if the values of \prm{field 1} and \prm{field 2} are equal, and to \prm{false} otherwise.

\cmditem{iflistsequal}{literal list 1}{literal list 2}{true}{false}

展开为\prm{true}，如果\prm{literal list 1} 和\prm{literal list 2} 相等，否则展开为\prm{false}
%Expands to \prm{true} if the values of \prm{literal list 1} and \prm{literal list 2} are equal, and to \prm{false} otherwise.

\cmditem{ifnamesequal}{name list 1}{name list 2}{true}{false}

展开为\prm{true}，如果\prm{name list 1} 和\prm{name list 2} 相等，否则展开为\prm{false}
%Expands to \prm{true} if the values of \prm{name list 1} and \prm{name list 2} are equal, and to \prm{false} otherwise.

\cmditem{iffieldequals}{field}{macro}{true}{false}

展开为\prm{true}，如果\prm{field} 的值和\prm{macro} 的定义相等，否则展开为\prm{false}。\footnote{译者: 比如应用于gb7714-2015中的新闻和标准条目类型的判断}
%Expands to \prm{true} if the value of the \prm{field} is equal to the definition of \prm{macro}, and to \prm{false} otherwise.

\cmditem{iflistequals}{literal list}{macro}{true}{false}

展开为\prm{true}，如果\prm{literal list} 的值和\prm{macro} 的定义相等，否则展开为\prm{false}。
%Expands to \prm{true} if the value of the \prm{literal list} is equal to the definition of \prm{macro}, and to \prm{false} otherwise.

\cmditem{ifnameequals}{name list}{macro}{true}{false}

展开为\prm{true}，如果\prm{name list} 的值和\prm{macro} 的定义相等，否则展开为\prm{false}。
%Expands to \prm{true} if the value of the \prm{name list} is equal to the definition of \prm{macro}, and to \prm{false} otherwise.

\cmditem{iffieldequalcs}{field}{csname}{true}{false}

类似于\cmd{iffieldequals}，但将控制序列名\prm{csname}(不带斜杠)作为参数，而不是一个宏名。
%Similar to \cmd{iffieldequals} but takes the control sequence name \prm{csname} (without a leading backslash) as an argument, rather than a macro name.

\cmditem{iflistequalcs}{literal list}{csname}{true}{false}

类似于\cmd{iflistequals}，但将控制序列名\prm{csname}(不带斜杠)作为参数，而不是一个宏名。
%Similar to \cmd{iflistequals} but takes the control sequence name \prm{csname} (without a leading backslash) as an argument, rather than a macro name.

\cmditem{ifnameequalcs}{name list}{csname}{true}{false}

类似于\cmd{ifnameequals}，但将控制序列名\prm{csname}(不带斜杠)作为参数，而不是一个宏名。
%Similar to \cmd{ifnameequals} but takes the control sequence name \prm{csname} (without a leading backslash) as an argument, rather than a macro name.

\cmditem{iffieldequalstr}{field}{string}{true}{false}

展开为\prm{true}，如果\prm{field} 的值和字符串\prm{string} 的定义相等，否则展开为\prm{false}。该命令是鲁棒的。
%Executes \prm{true} if the value of the \prm{field} is equal to \prm{string}, and \prm{false} otherwise. This command is robust.

\cmditem{iffieldxref}{field}{true}{false}

如果一个条目定义了\bibfield{crossref}\slash \bibfield{xref}，该命令检测\prm{field} 是否与cross"=referenced父条目相关联。如果子条目的\prm{field} 与父条目对应的\prm{field} 相等，那么执行\prm{true}，否则执行\prm{false}。如果\bibfield{crossref}\slash \bibfield{xref} 未定义，总是执行\prm{false}。该命令是鲁棒的。\bibfield{crossref} 和 \bibfield{xref} 域的描述见\secref{bib:fld:spc}，更多关于cross"=referencing的信息见\secref{bib:cav:ref}。
%If the \bibfield{crossref}\slash \bibfield{xref} field of an entry is defined, this command checks if the \prm{field} is related to the cross"=referenced parent entry. It executes \prm{true} if the \prm{field} of the child entry is equal to the corresponding \prm{field} of the parent entry, and \prm{false} otherwise. If the \bibfield{crossref}\slash \bibfield{xref} field is undefined, it always executes \prm{false}. This command is robust. See the description of the \bibfield{crossref} and \bibfield{xref} fields in \secref{bib:fld:spc} as well as \secref{bib:cav:ref} for further information concerning cross"=referencing.

\cmditem{iflistxref}{literal list}{true}{false}

类似于\cmd{iffieldxref} 命令，但检测\prm{literal list} 是否与cross"=referenced父条目相关联。
\bibfield{crossref} 和 \bibfield{xref} 域的描述见\secref{bib:fld:spc}，更多关于cross"=referencing的信息见\secref{bib:cav:ref}。
%Similar to \cmd{iffieldxref} but checks if a \prm{literal list} is related to the cross"=referenced parent entry. See the description of the \bibfield{crossref} and \bibfield{xref} fields in \secref{bib:fld:spc} as well as \secref{bib:cav:ref} for further information concerning cross"=referencing.

\cmditem{ifnamexref}{name list}{true}{false}

类似于\cmd{iffieldxref} 命令，但检测\prm{name list} 是否与cross"=referenced父条目相关联。
\bibfield{crossref} 和 \bibfield{xref} 域的描述见\secref{bib:fld:spc}，更多关于cross"=referencing的信息见\secref{bib:cav:ref}。
%Similar to \cmd{iffieldxref} but checks if a \prm{name list} is related to the cross"=referenced parent entry. See the description of the \bibfield{crossref} and \bibfield{xref} fields in \secref{bib:fld:spc} as well as \secref{bib:cav:ref} for further information concerning cross"=referencing.

\cmditem{ifcurrentfield}{field}{true}{false}

执行\prm{true}，如果当前域为\prm{field}，否则执行\prm{false}。该命令是鲁棒的。它主要用于域格式指令中，如果在其它环境中总是执行\prm{false}。
%Executes \prm{true} if the current field is \prm{field}, and \prm{false} otherwise. This command is robust. It is intended for use in field formatting directives and always executes \prm{false} when used in any other context.

\cmditem{ifcurrentlist}{literal list}{true}{false}

执行\prm{true}，如果当前list为\prm{literal list}，否则执行\prm{false}。该命令是鲁棒的。它主要用于域格式指令中，如果在其它环境中总是执行\prm{false}。
%Executes \prm{true} if the current list is \prm{literal list}, and \prm{false} otherwise. This command is robust. It is intended for use in list formatting directives and always executes \prm{false} when used in any other context.

\cmditem{ifcurrentname}{name list}{true}{false}

执行\prm{true}，如果当前list为\prm{name list}，否则执行\prm{false}。该命令是鲁棒的。它主要用于域格式指令中，如果在其它环境中总是执行\prm{false}。
%Executes \prm{true} if the current list is \prm{name list}, and \prm{false} otherwise. This command is robust. It is intended for use in list formatting directives and always executes \prm{false} when used in any other context.

\cmditem{ifuseprefix}{true}{false}

执行\prm{true}，如果\opt{useprefix} 选项启用(无论是全局的还是针对当前条目)，否则执行\prm{false}。该选项的细节见\secref{use:opt:bib}。
%Expands to \prm{true} if the \opt{useprefix} option is enabled (either globally or for the current entry), and \prm{false} otherwise. See \secref{use:opt:bib} for details on this option.

\cmditem{ifuseauthor}{true}{false}

这只是下面的\cmd{ifuse$<$name$>$} 宏的一个特例，因为\bibfield{author} 是默认数据模型的一部分所以放到这里来说。如果\opt{useauthor} 选项启用(无论是全局的还是针对当前条目)，执行\prm{true}，否则执行\prm{false}。该选项的细节见\secref{use:opt:bib}。
%This is just a particular case of the \cmd{ifuse$<$name$>$} macro below but is mentioned here as \bibfield{author} is part of the default data model. Expands to \prm{true} if the \opt{useauthor} option is enabled (either globally or for the current entry), and \prm{false} otherwise. See \secref{use:opt:bib} for details on this option.

\cmditem{ifuseeditor}{true}{false}

这只是下面的\cmd{ifuse$<$name$>$} 宏的一个特例，因为\bibfield{editor} 是默认数据模型的一部分所以放到这里来说。如果\opt{useeditor} 选项启用(无论是全局的还是针对当前条目)，执行\prm{true}，否则执行\prm{false}。该选项的细节见\secref{use:opt:bib}。
%This is just a particular case of the \cmd{ifuse$<$name$>$} macro below but is mentioned here as \bibfield{editor} is part of the default data model. Expands to \prm{true} if the \opt{useeditor} option is enabled (either globally or for the current entry), and \prm{false} otherwise. See \secref{use:opt:bib} for details on this option.

\cmditem{ifusetranslator}{true}{false}

这只是下面的\cmd{ifuse$<$name$>$} 宏的一个特例，因为\bibfield{translator} 是默认数据模型的一部分所以放到这里来说。如果\opt{usetranslator} 选项启用(无论是全局的还是针对当前条目)，执行\prm{true}，否则执行\prm{false}。该选项的细节见\secref{use:opt:bib}。
%This is just a particular case of the \cmd{ifuse$<$name$>$} macro below but is mentioned here as \bibfield{translator} is part of the default data model. Expands to \prm{true} if the \opt{usetranslator} option is enabled (either globally or for the current entry), and \prm{false} otherwise. See \secref{use:opt:bib} for details on this option.

\cmditem{ifuse$<$name$>$}{true}{false}

%Expands to \prm{true} if the \opt{use$<$name$>$} option is enabled (either globally or for the current entry), and \prm{false} otherwise. See \secref{use:opt:bib} for details on this option.
展开为\prm{true}，如果选项\opt{use$<$name$>$} 启用(无论全局还是当前条目的选项)，否则展开为\prm{false}。这一选项的细节详见第\secref{use:opt:bib} 节。

\cmditem{ifcrossrefsource}{true}{false}

展开为\prm{true}，如果包含在\file{.bbl} 中的条目的间接引用(referenced，译者:是交叉引用)次数大于\opt{mincrossrefs}，否则展开为\prm{false}。见\secref{use:opt:pre:gen}。如果条目被直接引用则展开为\prm{false}。
%Expands to \prm{true} if the entry was inclued in the \file{.bbl} due to being referenced more than \opt{mincrossrefs} times and false otherwise. See \secref{use:opt:pre:gen}. Also expands to false if the entry was directly cited.

\cmditem{ifxrefsource}{true}{false}

展开为\prm{true}，如果包含在\file{.bbl} 中的条目的间接引用(referenced)次数大于\opt{minxrefs}，否则展开为\prm{false}。见\secref{use:opt:pre:gen}。如果条目被直接引用则展开为\prm{false}。类似于ifcrossrefsource，但针对xref域。
%Expands to \prm{true} if the entry was inclued in the \file{.bbl} due to being referenced more than \opt{minxrefs} times and false otherwise. See \secref{use:opt:pre:gen}. Also expands to false if the entry was directly cited.

\cmditem{ifsingletitle}{true}{false}

%Expands to \prm{true} if there is only one work by the \opt{labelname} name in the bibliography, and to \prm{false} otherwise. If \opt{labelname} is not set for an entry, this will always expand to \prm{false}. Note that this feature needs to be enabled explicitly with the package option \opt{singletitle}.
展开为\prm{true}，如果文献表中只有一篇文献具有\opt{labelname}，否则展开为\prm{false}。如果条目的\opt{labelname} 未设置，总是展开为\prm{false}。注意: 使用该功能需要显式启用宏包选项\opt{singletitle}。

\cmditem{ifnocite}{true}{false}

%Expands to \prm{true} if the entry was \emph{only} included in the \file{.bbl} via \cmd{nocite}. That is, returns \prm{false} if an entry was both \cmd{nocite}'d and \cmd{cite}'d.
展开为\prm{true}，如果条目仅是通过\cmd{nocite}而被包含在\file{.bbl}中，即如果一个条目均被\cmd{nocite}和\cmd{cite}命令引用时，返回为\prm{false}。

\cmditem{ifuniquetitle}{true}{false}

展开为\prm{true}，如果只有一篇文献的题名是\opt{labeltitle}，否则展开为\prm{false}。如果条目的\opt{labeltitle} 未设置，总是展开为\prm{false}。注意: 要使用这一功能需要显式地启用包选项\opt{uniquetitle}。
%Expands to \prm{true} if there is only one work with the title \opt{labeltitle} and to \prm{false} otherwise. If \opt{labeltitle} is not set for an entry, this will always expand to \prm{false}. Note that this feature needs to be enabled explicitly with the package option \opt{uniquetitle}.

\cmditem{ifuniquebaretitle}{true}{false}

展开为\prm{true}，如果\bibfield{labelname} 域为空且只有一篇文献的题名是\opt{labeltitle}，否则展开为\prm{false}。如果条目的\opt{labeltitle} 未设置，总是展开为\prm{false}。注意: 要使用这一功能需要显式地启用包选项\opt{uniquebaretitle}。
%Expands to \prm{true} if \bibfield{labelname} is empty and there is only one work with the title \opt{labeltitle} and to \prm{false} otherwise. If \opt{labeltitle} is not set for an entry, this will always expand to \prm{false}. Note that this feature needs to be enabled explicitly with the package option \opt{uniquebaretitle}.

\cmditem{ifuniquework}{true}{false}

展开为\prm{true}，如果文献表中只有一篇文献的标签名是\opt{labelname} 且题名是\opt{labeltitle}，否则展开为\prm{false}。如果条目的\opt{labelname} 和\opt{labeltitle} 均未设置，总是展开为\prm{false}。注意:要使用这一功能需要显式地启用包选项\opt{uniquework}。如果同一条目的\bibfield{singletitle} 和\bibfield{uniquetitle} 都是false，可能是因为有其他条目具有相同的\bibfield{labelname}，还有其他条目具有相同的\bibfield{labeltitle}。\bibfield{uniquework} 可以让我们知道是否有条目同时具有相同的\bibfield{labelname} 和\bibfield{labeltitle}。这在多人合作时很有用，当多人同时维护一个参考文献数据源时，可能存在添加内容相同但条目关键词不同的文献的风险。这一判断能帮助找到这种存在副本情况。
%Expands to \prm{true} if there is only one work by the \opt{labelname} name with the \opt{labeltitle} title in the bibliography, and to \prm{false} otherwise. If neither \opt{labelname} nor \opt{labeltitle} are set for an entry, this will always expand to \prm{false}. Note that this feature needs to be enabled explicitly with the package option \opt{uniquework}. If both \bibfield{singletitle} and \bibfield{uniquetitle} are false for the same entry, this could be because another entry has the same \bibfield{labdlname} and yet another, different, entry has the same \bibfield{labeltitle}. \bibfield{uniquework} would let you know that there is another entry that has \emph{both} the same \bibfield{labelname} \emph{and} the same \bibfield{labeltitle}. This could be helpful in cases where multiple people maintain bibliography datasources and there is a risk of adding the same work with different keys without other parties realising this. This test could help to find such duplicates.

\cmditem{ifuniqueprimaryauthor}{true}{false}

展开为\prm{true}，如果一篇文献的对于其\opt{labelname} 的第一作者的姓是唯一的，否则展开为\prm{false}。如果条目的\opt{labelname} 未设置，将展开为\prm{false}。注意: 使用该功能需要显式启用包选项\opt{uniqueprimaryauthor}。
Expands to \prm{true} if the primary (first) author name of \opt{labelname} is unique in the bibliography list and to \prm{false} otherwise. This effectively answers the question <is there more than one author with the same base name>. The base name parts are defined by \cmd{DeclareUniquenameTemplate} see \secref{aut:cav:amb}. This is required by some styles (e.g. APA) which mandates primary author disambiguation only and only if there are (different) primary authors with the same family name. If \opt{labelname} is not set for an entry, this will always expand to \prm{false}. Note that this feature needs to be enabled explicitly with the package option \opt{uniqueprimaryauthor}.


\cmditem{ifandothers}{list}{true}{false}

展开为\prm{true}，如果\prm{list} 已定义并且在\file{bib} 文件中以关键词<\texttt{and others}> 截短了，否则展开为\prm{false}。\prm{list} 可以是literal 或name 列表。
%Expands to \prm{true} if the \prm{list} is defined and has been truncated in the \file{bib} file with the keyword <\texttt{and others}>, and to \prm{false} otherwise. The \prm{list} may be a literal list or a name list.

\cmditem{ifmorenames}{true}{false}

展开为\prm{true}，如果当前姓名列表已经截短或将截短，否则展开为\prm{false}。该命令用于姓名列表的格式化指令中，在其它地方使用将展开为\prm{false}。该命令对当前列表执行与\cmd{ifandothers} 判断一样的操作。如果判断结果为否，它还将检测\cnt{listtotal} 是否大于\cnt{liststop}。该命令用于格式化命令中用以决定是否需要在列表默认打印«and others» or «et al.»这样的标注。注意: 还需要检测是否处于列表中间或者末尾时，即\cnt{listcount} 是否小于或等于\cnt{liststop}，详见第\secref{aut:bib:dat} 节。
%Expands to \prm{true} if the current name list has been or will be truncated, and to \prm{false} otherwise. This command is intended for use in formatting directives for name lists. It will always expand to \prm{false} when used elsewhere. This command performs the equivalent of an \cmd{ifandothers} test for the current list. If this test is negative, it also checks if the \cnt{listtotal} counter is larger than \cnt{liststop}. This command may be used in a formatting directive to decide if a note such as «and others» or «et al.» is to be printed at the end of the list. Note that you still need to check whether you are in the middle or at the end of the list, \ie whether \cnt{listcount} is smaller than or equal to \cnt{liststop}, see \secref{aut:bib:dat} for details.

\cmditem{ifmoreitems}{true}{false}

类似于\cmd{ifmorenames}，但检测literal列表。用于literal列表的格式化指令，在其它地方使用总是展开为\prm{false}。
%This command is similar to \cmd{ifmorenames} but checks the current literal list. It is intended for use in formatting directives for literal lists. It will always expand to \prm{false} when used elsewhere.

\cmditem{if$<$namepart$>$inits}{true}{false}

根据\opt{firstinits} 包选项的状态，展开为\prm{true} 或\prm{false}(见第\secref{use:opt:pre:int} 节)。该命令用于姓名列表的格式化指令。
%Expands to \prm{true} or \prm{false}, depending on the state of the \opt{$<$namepart$>$inits} package option (see \secref{use:opt:pre:int}). This command is intended for use in formatting directives for name lists.

\cmditem{ifterseinits}{true}{false}

根据\opt{terseinits} 包选项的状态，展开为\prm{true} 或\prm{false}(见第\secref{use:opt:pre:int} 节)。该命令用于姓名列表的格式化指令。
%Expands to \prm{true} or \prm{false}, depending on the state of the \opt{terseinits} package option (see \secref{use:opt:pre:int}). This command is intended for use in formatting directives for name lists.

\cmditem{ifentrytype}{type}{true}{false}

如果当前处理条目类型是\prm{type}，则展开为\prm{true}，否则展开为\prm{false}。
%Executes \prm{true} if the entry type of the entry currently being processed is \prm{type}, and \prm{false} otherwise.

\cmditem{ifkeyword}{keyword}{true}{false}

如果\prm{keyword} 能在当前处理条目的\bibfield{keywords} 域中找到，展开为\prm{true}，否则展开为\prm{false}。
%Executes \prm{true} if the \prm{keyword} is found in the \bibfield{keywords} field of the entry currently being processed, and \prm{false} otherwise.

\cmditem{ifentrykeyword}{entrykey}{keyword}{true}{false}

将条目关键词作为第一个参数的\cmd{ifkeyword} 命令的变化形式，用于判断当前处理条目是否是某一条目。
%A variant of \cmd{ifkeyword} which takes an entry key as its first argument. This is useful for testing an entry other than the one currently processed. A user-facing version of this command is available for use in documents see \secref{use:eq}.

\cmditem{ifcategory}{category}{true}{false}

执行\prm{true}，如果当前正在处理条目被指派到由\cmd{addtocategory} 命令定义的\prm{category} 类中，否则执行\prm{false}。
%Executes \prm{true} if the entry currently being processed has been assigned to a \prm{category} with \cmd{addtocategory}, and \prm{false} otherwise.

\cmditem{ifentrycategory}{entrykey}{category}{true}{false}

将条目关键词作为第一个参数的\cmd{ifcategory} 命令的变化形式，用于判断当前处理条目是否是某一条目。
%A variant of \cmd{ifcategory} which takes an entry key as its first argument. This is useful for testing an entry other than the one currently processed.

A user-facing version of this command is available for use in documents see \secref{use:eq}

\cmditem{ifciteseen}{true}{false}

展开为\prm{true}，如果当前条目之前已经被引用过，否则展开为\prm{false}。该命令是鲁棒的，用于标注样式中。如果文档中有\env{refsection} 环境，引用追踪是基于这些环境的。注意: 引用追踪器需要显式启用包选项\opt{citetracker}，如果追踪器未启用，该命令总是展开为\prm{false}。另可参见第\secref{aut:aux:msc} 节的\cmd{citetrackertrue} 和\cmd{citetrackerfalse} 开关。
%Executes \prm{true} if the entry currently being processed has been cited before, and \prm{false} otherwise. This command is robust and intended for use in citation styles. If there are any \env{refsection} environments in the document, the citation tracking is local to these environments. Note that the citation tracker needs to be enabled explicitly with the package option \opt{citetracker}. The behavior of this test depends on the mode the citation tracker is operating in, see \secref{use:opt:pre:int} for details. If the citation tracker is disabled, the test always yields \prm{false}. Also see the \cmd{citetrackertrue} and \cmd{citetrackerfalse} switches in \secref{aut:aux:msc}.

\cmditem{ifentryseen}{entrykey}{true}{false}

将条目关键词作为第一个参数的\cmd{ifciteseen} 命令的变化形式。
因为\prm{entrykey} 先于判断展开，它也可以用来测试在\bibfield{xref} 等域中的条目关键词。
%A variant of \cmd{ifciteseen} which takes an entry key as its first argument. Since the \prm{entrykey} is expanded prior to performing the test, it is possible to test for entry keys in a field such as \bibfield{xref}:

\begin{ltxexample}
\ifentryseen{<<\thefield{xref}>>}{true}{false}
\end{ltxexample}
%
除了一个额外参数，\cmd{ifentryseen} 的操作类似于\cmd{ifciteseen}。 在正文中使用的面向用户的类似命令见\secref{use:eq}。
%Apart from the additional argument, \cmd{ifentryseen} behaves like \cmd{ifciteseen}. A user-facing version of this command is available for use in documents see \secref{use:eq}.

\cmditem{ifentryinbib}{entrykey}{true}{false}

如果\prm{entrykey} 出现当前文献表中，执行\prm{true}，否则执行\prm{false}。该命令用于参考文献著录样式。在正文中使用的面向用户的类似命令见\secref{use:eq}。
%Executes \prm{true} if the entry \prm{entrykey} appears in the current bibliography, and \prm{false} otherwise. A user-facing version of this command is available for use in documents see \secref{use:eq}.

\cmditem{iffirstcitekey}{true}{false}

如果当前处理条目是引用列表中的第一个条目，执行\prm{true}，否则执行\prm{false}。该命令依赖于\cnt{citecount}, \cnt{citetotal}, \cnt{multicitecount} 和 \cnt{multicitetotal} 计数器(见\secref{aut:fmt:ilc})，因此只能用于\cmd{DeclareCiteCommand} 命令定义的标注命令的循环执行代码\prm{loopcode} 中。
%Executes \prm{true} if the entry currently being processed is the first one in the citation list, and \prm{false} otherwise. This command relies on the \cnt{citecount}, \cnt{citetotal}, \cnt{multicitecount} and \cnt{multicitetotal} counters (\secref{aut:fmt:ilc}) and thus is intended for use only in the \prm{loopcode} of a citation command defined with \cmd{DeclareCiteCommand}.

\cmditem{iflastcitekey}{true}{false}

类似于\cmd{iffirstcitekey}，但判断的是是否为引用列表中的最后一个条目。
%Similar \cmd{iffirstcitekey}, but executes \prm{true} if the entry currently being processed is the last one in the citation list, and \prm{false} otherwise.

\cmditem{ifciteibid}{true}{false}

如果当前处理条目与前一条相同，展开为\prm{true}，否则展开为\prm{false}。该命令用于标注样式。如果有\env{refsection} 环境，追踪器是基于这些环境的。注意: <ibidem>追踪器需要由\opt{ibidtracker} 包选项显式启用。该判断命令的运行方式与追踪器运行的模式相关，详见\secref{use:opt:pre:int}。如果追踪器未启用，总是展开为\prm{false}。另可参见\secref{aut:aux:msc} 节的\cmd{citetrackertrue} 和\cmd{citetrackerfalse} 开关。
%Expands to \prm{true} if the entry currently being processed is the same as the last one, and to \prm{false} otherwise. This command is intended for use in citation styles. If there are any \env{refsection} environments in the document, the tracking is local to these environments. Note that the <ibidem> tracker needs to be enabled explicitly with the package option \opt{ibidtracker}. The behavior of this test depends on the mode the tracker is operating in, see \secref{use:opt:pre:int} for details. If the tracker is disabled, the test always yields \prm{false}. Also see the \cmd{citetrackertrue} and \cmd{citetrackerfalse} switches in \secref{aut:aux:msc}.

\cmditem{ifciteidem}{true}{false}

如果当前处理条目的责任者(即作者或编者)与前一条目的相同，展开为\prm{true}，否则展开为\prm{false}。该命令用于标注样式。如果有\env{refsection} 环境，追踪器是基于这些环境的。注意: <idem> 追踪器需要由\opt{idemtracker} 包选项显式启用。该判断命令的运行方式与追踪器运行的模式相关，详见\secref{use:opt:pre:int}。如果追踪器未启用，总是展开为\prm{false}。另可参见\secref{aut:aux:msc} 节的\cmd{citetrackertrue} 和\cmd{citetrackerfalse} 开关。
%Expands to \prm{true} if the primary name (\ie the author or editor) in the entry currently being processed is the same as the last one, and to \prm{false} otherwise. This command is intended for use in citation styles. If there are any \env{refsection} environments in the document, the tracking is local to these environments. Note that the <idem> tracker needs to be enabled explicitly with the package option \opt{idemtracker}. The behavior of this test depends on the mode the tracker is operating in, see \secref{use:opt:pre:int} for details. If the tracker is disabled, the test always yields \prm{false}. Also see \cmd{citetrackertrue} and \cmd{citetrackerfalse} in \secref{aut:aux:msc}.

\cmditem{ifopcit}{true}{false}

该命令类似于\cmd{ifciteibid}，但只要当前处理条目的\emph{作者 或 编者 } 与前一条目相同，则展开为\prm{true}。注意: <opcit> 追踪器需要由\opt{opcittracker} 包选项显式的启用。该判断命令的运行方式与追踪器运行的模式相关，详见\secref{use:opt:pre:int}。如果追踪器未启用，总是展开为\prm{false}。另可参见\secref{aut:aux:msc} 节的\cmd{citetrackertrue} 和\cmd{citetrackerfalse} 开关。
%This command is similar to \cmd{ifciteibid} except that it expands to \prm{true} if the entry currently being processed is the same as the last one \emph{by this author or editor}. Note that the <opcit> tracker needs to be enabled explicitly with the package option \opt{opcittracker}. The behavior of this test depends on the mode the tracker is operating in, see \secref{use:opt:pre:int} for details. If the tracker is disabled, the test always yields \prm{false}. Also see the \cmd{citetrackertrue} and \cmd{citetrackerfalse} switches in \secref{aut:aux:msc}.

\cmditem{ifloccit}{true}{false}

该命令类似于\cmd{ifopcit}，但还要比较\prm{postnote} 的参数，如果他们相同且是数值(\secref{aut:aux:tst} 节的\cmd{ifnumerals} 命令判断)，则展开为\prm{true}。即:如果引文的页码与前一文献相同则展开为\texttt{true}。 注意: <loccit> 追踪器需要由\opt{loccittracker} 包选项显式启用。该判断命令的运行方式与追踪器运行的模式相关，详见\secref{use:opt:pre:int}。如果追踪器未启用，总是展开为\prm{false}。另可参见\secref{aut:aux:msc} 节的\cmd{citetrackertrue} 和\cmd{citetrackerfalse} 开关。
%This command is similar to \cmd{ifopcit} except that it also compares the \prm{postnote} arguments and expands to \prm{true} only if they match and are numerical (in the sense of \cmd{ifnumerals} from \secref{aut:aux:tst}), \ie \cmd{ifloccit} will yield \texttt{true} if the citation refers to the same page cited before. Note that the <loccit> tracker needs to be enabled explicitly with the package option \opt{loccittracker}. The behavior of this test depends on the mode the tracker is operating in, see \secref{use:opt:pre:int} for details. If the tracker is disabled, the test always yields \prm{false}. Also see the \cmd{citetrackertrue} and \cmd{citetrackerfalse} switches in \secref{aut:aux:msc}.

\cmditem{iffirstonpage}{true}{false}

该命令的运行与\opt{pagetracker} 包选项相关，如果选项设置成\texttt{page}，当前项是页中的第一项，展开为\prm{true}，否则展开为\prm{false}。如果选项设置成\texttt{spread}，当前项是合页(double-page spread)中的第一项，展开为\prm{true}，否则展开为\prm{false}。如果选项未启用，总是展开为\prm{false}。根据所处环境不同，<item>可以是一个标注，或者参考文献表中的条目。注意该命令区分正文文本和脚注，例如，当在某页的第一个脚注中使用，即便是文中有一个标注且先于该脚注，它也展开为\prm{true}。另可参见\secref{aut:aux:msc} 节的\cmd{pagetrackertrue} 和\cmd{pagetrackerfalse} 开关。
%The behavior of this command is responsive to the package option \opt{pagetracker}. If the option is set to \texttt{page}, it expands to \prm{true} if the current item is the first one on the page, and to \prm{false} otherwise. If the option is set to \texttt{spread}, it expands to \prm{true} if the current item is the first one on the double-page spread, and to \prm{false} otherwise. If the page tracker is disabled, this test always yields \prm{false}. Depending on the context, the <item> may be a citation or an entry in the bibliography or a bibliography list. Note that this test distinguishes between body text and footnotes. For example, if used in the first footnote on a page, it will expand to \prm{true} even if there is a citation in the body text prior to the footnote. Also see the \cmd{pagetrackertrue} and \cmd{pagetrackerfalse} switches in \secref{aut:aux:msc}.

\cmditem{ifsamepage}{instance 1}{instance 2}{true}{false}

如果两个引用实例位于同于页或者同一合页中，展开为\prm{true}，否则为\prm{false}。一个引用实例可以是一个标注也可以是文献表中的条目。这些实例用\cnt{instcount} 计数区分，见\secref{aut:fmt:ilc}。该命令的运行与\opt{pagetracker} 包选项相关，如果选项设置成\texttt{spread}，其本质是<if same spread>(是否同一合页)的判断。如果选项未启用，总是展开为\prm{false}。参数\prm{instance 1} 和\prm{instance 2} 以\etex's \cmd{numexpr} 方式当成整数表达式处理。这意味着可以在参数中计算。比如:
%This command expands to \prm{true} if two instances of a reference are located on the same page or double-page spread, and to \prm{false} otherwise. An instance of a reference may be a citation or an entry in the bibliography or a bibliography list. These instances are identified by the value of the \cnt{instcount} counter, see \secref{aut:fmt:ilc}. The behavior of this command is responsive to the package option \opt{pagetracker}. If this option is set to \texttt{spread}, \cmd{ifsamepage} is in fact an <if same spread> test. If the page tracker is disabled, this test always yields \prm{false}. The arguments \prm{instance 1} and \prm{instance 2} are treated as integer expressions in the sense of \etex's \cmd{numexpr}. This implies that it is possible to make calculations within these arguments, for example:

\begin{ltxexample}
\ifsamepage{<<\value>>{instcount}}{<<\value>>{instcount}<<-1>>}{true}{false}
\end{ltxexample}
注意: \cmd{value} 命令不是以\cmd{the} 为前缀，在第二个参数中做了减法运算。如果\prm{instance 1} 或 \prm{instance 2} 是无效数字(比如一个负值)，总是展开为\prm{false}。也要注意该命令不区分正文和脚注。另可参见\secref{aut:aux:msc} 节的\cmd{pagetrackertrue} 和\cmd{pagetrackerfalse} 开关。
%Note that \cmd{value} is not prefixed by \cmd{the} and that the subtraction is included in the second argument in the above example. If \prm{instance 1} or \prm{instance 2} is an invalid number (for example, a negative one), the test yields \prm{false}. Also note that this test does not distinguish between body text and footnotes. Also see the \cmd{pagetrackertrue} and \cmd{pagetrackerfalse} switches in \secref{aut:aux:msc}.

\cmditem{ifinteger}{string}{true}{false}

如果\prm{string} 是一个正整数，展开为\prm{true}，否则为\prm{false}，该命令鲁棒。
%Executes \prm{true} if the \prm{string} is a positive integer, and \prm{false} otherwise. This command is robust.

\cmditem{ifnumeral}{string}{true}{false}

如果\prm{string} 是一个阿拉伯或者罗马数字，展开为\prm{true}，否则为\prm{false}，该命令鲁棒。另可参见\secref{aut:aux:msc} 节的\cmd{DeclareNumChars} 和\cmd{NumCheckSetup} 命令。
%Executes \prm{true} if the \prm{string} is an Arabic or Roman numeral, and \prm{false} otherwise. This command is robust. See also \cmd{DeclareNumChars} and \cmd{NumCheckSetup} in \secref{aut:aux:msc}.

\cmditem{ifnumerals}{string}{true}{false}

如果\prm{string} 是一个阿拉伯或者罗马数字的范围或列表，展开为\prm{true}，否则为\prm{false}，该命令鲁棒。相比于\cmd{ifnumeral} 命令，当参数像 «52--58», «14/15», «1,~3,~5» 等时，该命令会执行\prm{true}。
另可参见\secref{aut:aux:msc} 节的\cmd{DeclareNumChars}，\cmd{NumCheckSetup}，\cmd{DeclareRangeCommands} 和 \cmd{NumCheckSetup} 命令。
%Executes \prm{true} if the \prm{string} is a range or a list of Arabic or Roman numerals, and \prm{false} otherwise. This command is robust. In contrast to \cmd{ifnumeral}, it will also execute \prm{true} with arguments like «52--58», «14/15», «1,~3,~5», and so on. See also \cmd{DeclareNumChars}, \cmd{DeclareRangeChars}, \cmd{DeclareRangeCommands},\cmd{NumCheckSetup}, and \cmd{NumsCheckSetup} in \secref{aut:aux:msc}.

\cmditem{ifpages}{string}{true}{false}

类似于\cmd{ifnumerals}，但也考虑\secref{aut:aux:msc} 节的\cmd{DeclarePageCommands} 命令。
%Similar to \cmd{ifnumerals}, but also considers \cmd{DeclarePageCommands} and \cmd{PagesCheckSetup} from \secref{aut:aux:msc}.

\cmditem{iffieldint}{field}{true}{false}

类似于\cmd{ifinteger} 命令，但使用\prm{field} 的值而不是一个字符串，如果域未定义，执行\prm{false}。
%Similar to \cmd{ifinteger}, but uses the value of a \prm{field} rather than a literal string in the test. If the \prm{field} is undefined, it executes \prm{false}.

\cmditem{iffieldnum}{field}{true}{false}

类似于\cmd{ifnumeral} 命令，但使用\prm{field} 的值而不是一个字符串，如果域未定义，执行\prm{false}。
%Similar to \cmd{ifnumeral}, but uses the value of a \prm{field} rather than a literal string in the test. If the \prm{field} is undefined, it executes \prm{false}.

\cmditem{iffieldnums}{field}{true}{false}

类似于\cmd{ifnumerals} 命令，但使用\prm{field} 的值而不是一个字符串，如果域未定义，执行\prm{false}。
%Similar to \cmd{ifnumerals}, but uses the value of a \prm{field} rather than a literal string in the test. If the \prm{field} is undefined, it executes \prm{false}.

\cmditem{iffieldpages}{field}{true}{false}

类似于\cmd{ifpages} 命令，但使用\prm{field} 的值而不是一个字符串，如果域未定义，执行\prm{false}。
%Similar to \cmd{ifpages}, but uses the value of a \prm{field} rather than a literal string in the test. If the \prm{field} is undefined, it executes \prm{false}.

\cmditem{ifbibstring}{string}{true}{false}

如果\prm{string} 是已知的本地化关键词，展开为\prm{true}，否则\prm{false}。默认定义的本地化字符串见\secref{aut:lng:key}。新的字符串可以用命令\cmd{NewBibliographyString} 定义。
%Expands to \prm{true} if the \prm{string} is a known localisation key, and to \prm{false} otherwise. The localisation keys defined by default are listed in \secref{aut:lng:key}. New ones may be defined with \cmd{NewBibliographyString}.

\cmditem{ifbibxstring}{string}{true}{false}

类似于\cmd{ifbibstring}，但\prm{string} 是展开的。
%Similar to \cmd{ifbibstring}, but the \prm{string} is expanded.

\cmditem{iffieldbibstring}{field}{true}{false}

类似于\cmd{ifbibstring}，但使用\prm{field} 域的值而不是一个字符串，如果域未定义，执行\prm{false}。
%Similar to \cmd{ifbibstring}, but uses the value of a \prm{field} rather than a literal string in the test. If the \prm{field}  is undefined, it expands to \prm{false}.

\cmditem{iffieldplusstringbibstring}{field}{string}{true}{false}

%Similar to \cmd{iffieldbibstring}, but appends \prm{string} to the value of \prm{field} and checks if the resulting string is a known localisation key. Expands to \prm{false} if \prm{field} is undefined.

类似于\cmd{iffieldbibstring}，会把\prm{string}附加到\prm{field} 域的值上，并检测形成的字符串是否是一个已定义的本地化字符串关键字。当\prm{field} 未定义，则展开为\prm{false} 。

\cmditem{ifdriver}{entrytype}{true}{false}

展开为\prm{true} 如果\prm{entrytype} 的驱动存在，否则为\prm{false}。
%Expands to \prm{true} if a driver for the \prm{entrytype} is available, and to \prm{false} otherwise.

\cmditem{ifcapital}{true}{false}

如果\biblatex 的标点追踪器将当前位置的本地化字符串大写，则执行\prm{true}，否则执行\prm{false}。该命令鲁棒，用于格式化指令中对姓名的某些成分做有条件的大写。
%Executes \prm{true} if \biblatex's punctuation tracker would capitalize a localisation string at the current location, and \prm{false} otherwise. This command is robust. It may be useful for conditional capitalization of certain parts of a name in a formatting directive.

\cmditem{ifcitation}{true}{false}

当处于标注中则展开为\prm{true}，否则为\prm{false}。注意这一命令与其所在的最外层环境有关。比如，当由\cmd{DeclareCiteCommand} 命令定义的标注命令执行一个由\cmd{DeclareBibliographyDriver} 定义的驱动，则任何在该驱动中的\cmd{ifcitation} 都会展开为\prm{true}。一个例子见\secref{aut:cav:mif} 节。
%Expands to \prm{true} when located in a citation, and to \prm{false} otherwise. Note that this command is responsive to the outermost context in which it is used. For example, if a citation command defined with \cmd{DeclareCiteCommand} executes a driver defined with \cmd{DeclareBibliographyDriver}, any \cmd{ifcitation} tests in the driver code will yield \prm{true}. See \secref{aut:cav:mif} for a practical example.

\cmditem{ifvolcite}{true}{false}

Expands to \prm{true} when located in \cmd{volcite} or a related citation command (\secref{use:cit:spc}), and to \prm{false} otherwise.
\cmditem{ifbibliography}{true}{false}

当处于文献表中则展开为\prm{true}，否则为\prm{false}。注意这一命令与其所在的最外层环境有关。比如，当由\cmd{DeclareBibliographyDriver} 命令定义的驱动执行一个由\cmd{DeclareCiteCommand} 定义的标注，则任何在该标注中的\cmd{ifbibliography} 都会展开为\prm{true}。一个例子见\secref{aut:cav:mif} 节。
%Expands to \prm{true} when located in a bibliography, and to \prm{false} otherwise. Note that this command is responsive to the outermost context in which it is used. For example, if a driver defined with \cmd{DeclareBibliographyDriver} executes a citation command defined with \cmd{DeclareCiteCommand}, any \cmd{ifbibliography} tests in the citation code will yield \prm{true}. See \secref{aut:cav:mif} for a practical example.

\cmditem{ifnatbibmode}{true}{false}

根据\secref{use:opt:ldt} 节的\opt{natbib} 选项展开为\prm{true} 或\prm{false}。
%Expands to \prm{true} or \prm{false} depending on the \opt{natbib} option from \secref{use:opt:ldt}.

\cmditem{ifciteindex}{true}{false}

根据\secref{use:opt:pre:gen} 节的\opt{indexing} 选项展开为\prm{true} 或\prm{false}。
%Expands to \prm{true} or \prm{false} depending on the \opt{indexing} option from \secref{use:opt:pre:gen}.

\cmditem{ifbibindex}{true}{false}

根据\secref{use:opt:pre:gen} 节的\opt{indexing} 选项展开为\prm{true} 或\prm{false}。
%Expands to \prm{true} or \prm{false} depending on the \opt{indexing} option from \secref{use:opt:pre:gen}.

\cmditem{iffootnote}{true}{false}

当处于脚注中时，展开为\prm{true}，否则为\prm{false}。注意: 在\env{minipage} 中的脚注被认为正文的一部分。当处于页面底部的脚注中或者由\sty{endnotes} 提供的endnotes中时，只会展开为\prm{true}。
%Expands to \prm{true} when located in a footnote, and to \prm{false} otherwise. Note that footnotes in \env{minipage} environments are considered to be part of the body text. This command will only expand to \prm{true} in footnotes a the bottom of the page and in endnotes as provided by the \sty{endnotes} package.

\cntitem{citecounter}

这一计数器表示当前处理条目在当前reference section中的引用次数。注意: 该功能需要显式启用包选项\opt{citecounter}。如果选项设置为\texttt{context}，正文和脚注中的引用分别计数。这种情况下，\cnt{citecounter} 记录其所在环境中的值。
%This counter indicates how many times the entry currently being processed is cited in the current reference section. Note that this feature needs to be enabled explicitly with the package option \opt{citecounter}. If the option is set to \texttt{context}, citations in the body text and in footnotes are counted separately. In this case, \cnt{citecounter} will hold the value of the context it is used in.

\cntitem{maxcitecounter}

%This counter holds the maximum value of \cnt{citecounter} across all entries in the current reference section. Like \cnt{citecounter} it is only available if the \opt{citecounter} option is enabled and tracks footnotes and text separately if the option is set to \texttt{context}.

该计数器保存当前文献节中遍历所有条目后的\cnt{citecounter}值，类似于\cnt{citecounter}，它仅在\opt{citecounter}选项启用时有效，
如果该选项设置为\texttt{context}，那么脚注和正文中分别计算。


\cntitem{uniquename}
%This counter refers to the \bibfield{labelname} list. It is set on a per-name basis. Its value is \texttt{0} if the base name (by default the <family> part of the name) is unique, \texttt{1} if adding the other parts of the name (as specified in the uniquename template defined by \cmd{DeclareUniquenameTemplate})as initials will make it unique, and \texttt{2} if the full name is required to disambiguate the name. This information is required by author-year and author-title citation schemes which add additional parts of the name when citing different authors with the same last name. For example, (given the default \cmd{DeclareUniquenameTemplate} definition) if there is one <John Doe> and one <Edward Doe> in the list of references, this counter will be set to \texttt{1}. If there is one <John Doe> and one <Jane Doe>, the value of the counter will be \texttt{2}. If the option is set to \texttt{init}\slash \texttt{allinit}\slash \texttt{mininit}, the counter will be limited to \texttt{1}. This is useful for citations styles which use initials to disambiguate names but never print the full name in citations. If adding the initials is not sufficient to disambiguate the name, \cnt{uniquename} will also be set to \texttt{0} for that name. This feature needs to be enabled explicitly with the package option \opt{uniquename}. Note that the \cnt{uniquename} counter is local to \cmd{printnames} and that it is only set for the \bibfield{labelname} list and to the name list \bibfield{labelname} has been derived from (typically \bibfield{author} or \bibfield{editor}). Its value is zero in any other context, i.e., it must be evaluated in the name formatting directives handling name lists. See \secref{aut:cav:amb} for further details and practical examples.
这一计数器用于\bibfield{labelname} 列表。它以每个名字为基础进行设置。如果姓不同，它的值设置为0，当增加姓名的其它成分的首字母使得姓名能区分时，则设置为1，如果需要完整的姓名才能区分，则设置为2。作者年制和作者标题制的标注格式需要这一信息来增加姓名的其它成分以对同姓的不同作者进行引用。比如: (考虑默认的\cmd{DeclareUniquenameTemplate} 定义)当引用列表中有一个<John Doe> 和一个<Edward Doe>，该计数器将设置为1。如果有一个<John Doe>和一个<Jane Doe>，该计数器将设置为2。如果选项设置成\texttt{init}\slash \texttt{allinit}\slash \texttt{mininit}，那么计数器将限制值最大为\texttt{1}。
这对于标注样式不打印全名而使用首字母来区分姓名很有用。如果添加首字母还无法区分姓名，\cnt{uniquename} 也将设置为\texttt{0}。该功能需要显式启用包选项\opt{uniquename}。注意\cnt{uniquename} 是\cmd{printnames} 局部使用的，仅根据\bibfield{labelname} 列表或其来源姓名列表(典型如\bibfield{author} 或\bibfield{editor})设置。它的值在其它环境中都是0，即它仅在处理姓名的格式化指令中计算，更多细节和实例见\secref{aut:cav:amb}。

This counter refers to the \bibfield{labelname} list. It is set on a per-name basis. Its value is \texttt{0} if the base parts of the name (by default just the <family> part of the name) are unique, \texttt{1} if adding the other non-base parts of the name (as specified in the uniquename template defined by \cmd{DeclareUniquenameTemplate}) as initials will make it unique, and \texttt{2} if adding the full form of the non-base parts of the name are required to disambiguate the name. This information is required by author-year and author-title citation schemes which add additional parts of the name when citing different authors with the same family name. For example, (given the default \cmd{DeclareUniquenameTemplate} definition) if there is one <John Doe> and one <Edward Doe> in the list of references, this counter will be set to \texttt{1}. If there is one <John Doe> and one <Jane Doe>, the value of the counter will be \texttt{2}. If the option is set to \texttt{init}\slash \texttt{allinit}\slash \texttt{mininit}, the counter will be limited to \texttt{1}. This is useful for citations styles which use initials to disambiguate names but never print the full name in citations. If adding the initials is not sufficient to disambiguate the name, \cnt{uniquename} will also be set to \texttt{0} for that name. This feature needs to be enabled explicitly with the package option \opt{uniquename}. Note that the \cnt{uniquename} counter is local to \cmd{printnames} and that it is only set for the \bibfield{labelname} list and for the name list that \bibfield{labelname} has been derived from (typically \bibfield{author} or \bibfield{editor}). Its value is zero in any other context, i.e., it must be evaluated in the name formatting directives handling name lists. See \secref{aut:cav:amb} for further details and practical examples. This counter can be overridden on a per-namepart basis by consulting the \cmd{namepart<namepart>un} macros during name formatting, see \secref{aut:bbx:drv}.

\cntitem{uniquelist}
%This counter refers to the \bibfield{labelname} list. It is set on a per-field basis. Its value indicates the number of names required to disambiguate the name list if automatic \cnt{maxnames}\slash \cnt{minnames} truncation would lead to ambiguous citations. For example, if there is one work by <Doe\slash Smith\slash Johnson> and another one by <Doe\slash Edwards\slash Williams>, setting \kvopt{maxnames}{1} would lead to <Doe et al.> in both cases. In this case, \cnt{uniquelist} would be set to \texttt{2} on the \bibfield{labelname} lists of both entries because at least the first two names are required to disambiguate them. Note that the \cnt{uniquelist} counter is local to \cmd{printnames} and that it is only set for the \bibfield{labelname} list and to the name list \bibfield{labelname} has been derived from (typically \bibfield{author} or \bibfield{editor}). Its value is zero in any other context. If available, the \cnt{uniquelist} value will be used automatically by \cmd{printnames} when processing the name list, \ie it will automatically override \cnt{maxnames}\slash \cnt{minnames}. This feature needs to be enabled explicitly with the package option \opt{uniquelist}. See \secref{aut:cav:amb} for further details and practical examples.
该计数器用于\bibfield{labelname} 列表。它以每个域为基础进行设置。它的值表示当使用\cnt{maxnames}\slash \cnt{minnames} 自动将姓名列表截短后导致标注歧义时，消除歧义需要的最小姓名数。比如，有一篇作者是<Doe\slash Smith\slash Johnson> 的文献和另一篇作者是<Doe\slash Edwards\slash Williams>的文献，设置\kvopt{maxnames}{1} 将导致两篇的作者都是<Doe et al.>。 这种情况下，两个条目的\bibfield{labelname} 列表的\cnt{uniquelist} 将设置成\texttt{2}，因为至少需要两个名字来区分。
注意\cnt{uniquelist} 是\cmd{printnames} 命令局部使用的，仅根据\bibfield{labelname} 列表或其来源姓名列表(典型如\bibfield{author} 或\bibfield{editor})设置。它的值在其它环境中都是0，即它仅在处理姓名的格式化指令中计算，如果该值存在，则\cmd{printnames} 命令在处理姓名列表时将自动应用，即自动覆盖\cnt{maxnames}\slash \cnt{minnames}。该功能需要显式启用选项\opt{uniquelist}。更多细节和实例见\secref{aut:cav:amb}。


\cntitem{parenlevel}

圆括号和/或方括号的嵌套层级。该信息仅在\secref{use:opt:pre:int} 的\opt{parentracker} 选项启用的情况下提供。
%The current nesting level of parentheses and\slash or brackets. This information is only available if the \opt{parentracker} from \secref{use:opt:pre:int} is enabled.

\end{ltxsyntax}

\subsubsection{使用\cmd{ifboolexpr} 和\cmd{ifthenelse} 的判断}%Tests with \cmd{ifboolexpr} and \cmd{ifthenelse}
\label{aut:aux:ife}

第\secref{aut:aux:tst} 节介绍的判断可以与\sty{etoolbox} 宏包提供的\cmd{ifboolexpr} 命令和\sty{ifthen} 宏包提供的\cmd{ifthenelse} 命令一同使用。这种情况下，其语法略有差异，判断命令的\prm{true} 和\prm{false} 参数自动省略，而直接传递给\cmd{ifboolexpr} 或 \cmd{ifthenelse}。 注意，使用这些命令需要一些计算代价。如果不需要任何布尔运算，使用\secref{aut:aux:tst} 节的独立判断命令更高效。
%The tests introduced in \secref{aut:aux:tst} may also be used with the \cmd{ifboolexpr} command provided by the \sty{etoolbox} package and the \cmd{ifthenelse} command provided by the \sty{ifthen} package. The syntax of the tests is slightly different in this case: the \prm{true} and \prm{false} arguments are omitted from the test itself and passed to the \cmd{ifboolexpr} or \cmd{ifthenelse} command instead. Note that the use of these commands implies some processing overhead. If you do not need any boolean operators, it is more efficient to use the stand"=alone tests from \secref{aut:aux:tst}.

\begin{ltxsyntax}

\cmditem{ifboolexpr}{expression}{true}{false}

该\sty{etoolbox} 包命令允许进行包括布尔运算和编组的复杂判断。
%\sty{etoolbox} command which allows for complex tests with boolean operators and grouping:

\begin{lstlisting}[style=ifthen]{}
\ifboolexpr{ (
	       test {\ifnameundef{editor}}
	       and
	       not test {\iflistundef{location}}
	     )
	     or test {\iffieldundef{year}}
  }
  {...}
  {...}
\end{lstlisting}

\cmditem{ifthenelse}{tests}{true}{false}

该\sty{ifthen} 包命令允许进行包括布尔运算和编组的复杂判断。
%\sty{ifthen} command which allows for complex tests with boolean operators and grouping:

\begin{lstlisting}[style=ifthen]{}
\ifthenelse{ \(
		\ifnameundef{editor}
		\and
		\not \iflistundef{location}
	     \)
	     \or \iffieldundef{year}
  }
  {...}
  {...}
\end{lstlisting}
%
\biblatex 提供的附加判断命令，仅在标注命令和文献表中使用\cmd{ifboolexpr} 或\cmd{ifthenelse} 时可用。
%The additional tests provided by \biblatex are only available when \cmd{ifboolexpr} or \cmd{ifthenelse} are used in citation commands and in the bibliography.

\end{ltxsyntax}

\subsubsection{综合命令}%Miscellaneous Commands
\label{aut:aux:msc}

本节介绍参考文献著录和标注样式中使用的一些综合命令和小助手。
%The section introduced miscellaneous commands and little helpers for use in bibliography and citation styles.

\begin{ltxsyntax}

\cmditem{newbibmacro}{name}[arguments][optional]{definition}
\cmditem*{newbibmacro*}{name}[arguments][optional]{definition}

定义一个用于后面\cmd{usebibmacro} 调用的宏。该命令的语法类似于\cmd{newcommand}，除了\prm{name} 可以包含一些数字或标点，但不以斜杠开头。可选参数\prm{arguments} 是一个整数用于指定宏需要处理的参数数量。如果\prm{optional} 给出，它指定了该宏的第一个参数的默认值，这第一个参数自动变成为可选参数。相比于\cmd{newcommand}，当宏已经定义时，\cmd{newbibmacro} 命令会给出一个警告信息，并自动转换为\cmd{renewbibmacro} 命令。类似于\cmd{newcommand}，该命令的常规形式在定义中使用\cmd{long} 前缀，而带星的命令则没有。如果一个宏声明为long，它的参数可以包含\cmd{par} 记号。提供\cmd{newbibmacro} 和\cmd{renewbibmacro} 命令是为了方便使用，样式作者也可以使用\cmd{newcommand} 或\cmd{def}。然而，需要注意，共享文件 \path{biblatex.def} 中的绝大多数定义都是用\cmd{newbibmacro} 定义的，因此，要使用和修改它们要用相应的方式处理。
%Defines a macro to be executed via \cmd{usebibmacro} later. The syntax of this command is very similar to \cmd{newcommand} except that \prm{name} may contain characters such as numbers and punctuation marks and does not start with a backslash. The optional argument \prm{arguments} is an integer specifying the number of arguments taken by the macro. If \prm{optional} is given, it specifies a default value for the first argument of the macro, which automatically becomes an optional argument. In contrast to \cmd{newcommand}, \cmd{newbibmacro} issues a warning message if the macro is already defined, and automatically falls back to \cmd{renewbibmacro}. As with \cmd{newcommand}, the regular variant of this command uses the \cmd{long} prefix in the definition while the starred one does not. If a macro has been declared to be long, it may take arguments containing \cmd{par} tokens. \cmd{newbibmacro} and \cmd{renewbibmacro} are provided for convenience. Style authors are free to use \cmd{newcommand} or \cmd{def} instead. However, note that most shared definitions found in \path{biblatex.def} are defined with \cmd{newbibmacro}, hence they must be used and modified accordingly.

\cmditem{renewbibmacro}{name}[arguments][optional]{definition}
\cmditem*{renewbibmacro*}{name}[arguments][optional]{definition}

类似于\cmd{newbibmacro}，但用于重定义\prm{name}。相比于\cmd{newcommand}，当宏未定义时，\cmd{renewbibmacro} 命令给出一个警告信息，并自动转换为\cmd{newbibmacro} 命令。
%Similar to \cmd{newbibmacro} but redefines \prm{name}. In contrast to \cmd{renewcommand}, \cmd{renewbibmacro} issues a warning message if the macro is undefined, and automatically falls back to \cmd{newbibmacro}.

\cmditem{providebibmacro}{name}[arguments][optional]{definition}
\cmditem*{providebibmacro*}{name}[arguments][optional]{definition}

类似于\cmd{newbibmacro}，但仅在\prm{name} 未定义时定义宏。该命令概念上类似于\cmd{providecommand}。
%Similar to \cmd{newbibmacro} but only defines \prm{name} if it is undefined. This command is similar in concept to \cmd{providecommand}.

\cmditem{letbibmacro}{alias}{name}
\cmditem*{letbibmacro*}{alias}{name}

This command defines the macro \prm{alias} to be an alias of the macro \prm{name}. The definition is perfomed by \cmd{csletcs}.
An error is issued if \prm{name} is undefined.
The regular variant of this command sanitizes \prm{name} while the starred variant does not.

\cmditem{usebibmacro}{name}
\cmditem*{usebibmacro*}{name}

该命令执行由\cmd{newbibmacro} 定义的宏\prm{name}。如果宏带参数，只要简单的跟在\prm{name} 后面即可。该命令的常规形式会处理(净化，改造，sanitize)\prm{name}，而带星的命令不会。
%This command executes the macro \prm{name}, as defined with \cmd{newbibmacro}. If the macro takes any arguments, they are simply appended after \prm{name}. The regular variant of this command sanitizes
%\prm{name} while the starred variant does not.

\cmditem{savecommand}{command}
\cmditem{restorecommand}{command}

这两个命令用来保存和恢复\prm{command}，其中\prm{command} 必须是以斜杠开头的命令。两个命令都在局部范围内起作用。它们主要用于本地化文件中。
%These commands save and restore any \prm{command}, which must be a command name starting with a backslash. Both commands work within a local scope. They are mainly provided for use in localisation files.

\cmditem{savebibmacro}{name}
\cmditem{restorebibmacro}{name}

这两个命令用来保存和恢复宏\prm{name}，其中\prm{name} 由\cmd{newbibmacro} 定义的宏的标识。两个命令都在局部范围内起作用。它们主要用于本地化文件中。
%These commands save and restore the macro \prm{name}, where \prm{name} is the identifier of a macro defined with \cmd{newbibmacro}. Both commands work within a local scope. They are mainly provided for use in localisation files.

\cmditem{savefieldformat}[entry type]{format}
\cmditem{restorefieldformat}[entry type]{format}

这两个命令用来保存和恢复格式化指令\prm{format}，其中\prm{format} 由\cmd{DeclareFieldFormat} 定义。两个命令都在局部范围内起作用。它们主要用于本地化文件中。
%These commands save and restore the formatting directive \prm{format}, as defined with \cmd{DeclareFieldFormat}. Both commands work within a local scope. They are mainly provided for use in localisation files.

\cmditem{savelistformat}[entry type]{format}
\cmditem{restorelistformat}[entry type]{format}

这两个命令用来保存和恢复格式化指令\prm{format}，其中\prm{format} 由\cmd{DeclareListFormat} 定义。两个命令都在局部范围内起作用。它们主要用于本地化文件中。
%These commands save and restore the formatting directive \prm{format}, as defined with \cmd{DeclareListFormat}. Both commands work within a local scope. They are mainly provided for use in localisation files.

\cmditem{savenameformat}[entry type]{format}
\cmditem{restorenameformat}[entry type]{format}

这两个命令用来保存和恢复格式化指令\prm{format}，其中\prm{format} 由\cmd{DeclareNameFormat} 定义。两个命令都在局部范围内起作用。它们主要用于本地化文件中。
%These commands save and restore the formatting directive \prm{format}, as defined with \cmd{DeclareNameFormat}. Both commands work within a local scope. They are mainly provided for use in localisation files.

\cmditem{savelistwrapperformat}[entry type]{format}
\cmditem{restorelistwrapperformat}[entry type]{format}

%These commands save and restore the formatting directive \prm{format}, as defined with \cmd{DeclareListWrapperFormat}. Both commands work within a local scope. They are mainly provided for use in localisation files.
这些命令用于保存和恢复\cmd{DeclareListWrapperFormat}定义的格式，通常在局部范围使用，主要用于本地化文件处理中。


\cmditem{savenamewrapperformat}[entry type]{format}
\cmditem{restorenamewrapperformat}[entry type]{format}

%These commands save and restore the formatting directive \prm{format}, as defined with \cmd{DeclareNameWrapperFormat}. Both commands work within a local scope. They are mainly provided for use in localisation files.
这些命令用于保存和恢复\cmd{DeclareNameWrapperFormat}定义的格式，通常在局部范围使用，主要用于本地化文件处理中。



\cmditem{ifbibmacroundef}{name}{true}{false}

如果参考文献宏\prm{name} 未定义，展开为\prm{true} 否则为\prm{false}。
%Expands to \prm{true} if the bibliography macro \prm{name} is undefined, and to \prm{false} otherwise.

\cmditem{iffieldformatundef}[entry type]{name}{true}{false}
\cmditem{iflistformatundef}[entry type]{name}{true}{false}
\cmditem{ifnameformatundef}[entry type]{name}{true}{false}
\cmditem{iflistwrapperformatundef}[entry type]{name}{true}{false}
\cmditem{ifnamewrapperformatundef}[entry type]{name}{true}{false}
如果参考文献格式化指令\prm{format} 未定义，展开为\prm{true} 否则为\prm{false}。
%Expands to \prm{true} if the formatting directive \prm{format} is undefined, and to \prm{false}
%otherwise.

\cmditem{usedriver}{code}{entrytype}

执行\prm{entrytype} 类条目的参考文献驱动。在由\cmd{DeclareCiteCommand} 定义的标注命令的\prm{loopcode} 中调用该命令是打印类似于一个参考文献条目的完整标注的简单方法。诸如\cmd{newblock} 等命令无法用于标注，自动省略。附加的初始化命令可以通过\prm{code} 参数传递。该参数在一个编组内执行，这一编组用于运行相应驱动。注意: 该参数语法上是必须的，但可以留空。也要注意如果\opt{autolang} 包选项启用的话，该命令会自动切换语言。
%Executes the bibliography driver for an \prm{entrytype}. Calling this command in the \prm{loopcode} of a citation command defined with \cmd{DeclareCiteCommand} is a simple way to print full citations similar to a bibliography entry. Commands such as \cmd{newblock}, which are not applicable in a citation, are disabled automatically. Additional initialization commands may be passed as the \prm{code} argument. This argument is executed inside the group in which \cmd{usedriver} runs the respective driver. Note that it is mandatory in terms of the syntax but may be left empty. Also note that this command will automatically switch languages if the \opt{autolang} package option is enabled.

Executes the bibliography driver for an \prm{entrytype}. Calling this command in the \prm{loopcode} of a citation command defined with \cmd{DeclareCiteCommand} is a simple way to print full citations similar to a bibliography entry. Commands such as \cmd{newblock}, which are not applicable in a citation, are disabled automatically by default. The global initialization can be changed with \cmd{AtUsedriver}, see \secref{aut:fmt:hok}. Additional local initialization commands may be passed as the \prm{code} argument. This argument is executed inside the group in which \cmd{usedriver} runs the respective driver. Note that it is mandatory in terms of the syntax but may be left empty. Also note that this command will automatically switch languages if the \opt{autolang} package option is enabled.

\cmditem{bibhypertarget}{name}{text}

\sty{hyperref} 的\cmd{hypertarget} 命令的封套(包围命令)。\prm{name} 是超链接锚的名字，\prm{text} 的内容作为超链接锚，可以是任意可打印文字或代码。如果文档中存在\env{refsection} 环境，\prm{name} 是基于当前refsection环境。如果\opt{hyperref} 包选项未启用或者\sty{hyperref} 包未加载，该命令简单的传递\prm{text} 变量。另可参见\secref{aut:fmt:ich} 节的格式化指令\texttt{bibhypertarget}。
%A wrapper for \sty{hyperref}'s \cmd{hypertarget} command. The \prm{name} is the name of the anchor, the \prm{text} is arbitrary printable text or code which serves as an anchor. If there are any \env{refsection} environments in the document, the \prm{name} is local to the current environment. If the \opt{hyperref} package option is disabled or the \sty{hyperref} package has not been loaded, this command will simply pass on its \prm{text} argument. See also the formatting directive \texttt{bibhypertarget} in \secref{aut:fmt:ich}.

\cmditem{bibhyperlink}{name}{text}

\sty{hyperref} 的\cmd{hyperlink} 命令的封套。\prm{name} 是由\cmd{bibhypertarget} 定义的超链接锚的名字，\prm{text} 的内容将转变成超链接，可以是任意可打印文字或代码。如果文档中存在\env{refsection} 环境，\prm{name} 是基于当前refsection环境。如果\opt{hyperref} 包选项未启用或者\sty{hyperref} 包未加载，该命令简单的传递\prm{text} 变量。另可参见\secref{aut:fmt:ich} 节的格式化指令\texttt{bibhyperlink}。
%A wrapper for \sty{hyperref}'s \cmd{hyperlink} command. The \prm{name} is the name of an anchor defined with \cmd{bibhypertarget}, the \prm{text} is arbitrary printable text or code to be transformed into a link. If there are any \env{refsection} environments in the document, the \prm{name} is local to the current environment. If the \opt{hyperref} package option is disabled or the \sty{hyperref} package has not been loaded, this command will simply pass on its \prm{text} argument. See also the formatting directive \texttt{bibhyperlink} in \secref{aut:fmt:ich}.

\cmditem{bibhyperref}[entrykey]{text}

将\prm{text} 转变为指向参考文献表中的\prm{entrykey}(即某一条目)的内部链接。如果\prm{entrykey} 省略，该命令使用当前正在处理的条目的引用关键词。该命令用于将标注转换为可点击的超链接，可以链接到参考文献表中的相应条目。链接目标由\biblatex 自动标记。如果文档中有多个文献表，链接目标将是所有文献表中第一个出现的\prm{entrykey} 条目。如果文档中存在\env{refsection} 环境，则超链接基于当前refsection环境。另可参见\secref{aut:fmt:ich} 节的格式化指令\texttt{bibhyperref}。
%Transforms \prm{text} into an internal link pointing to \prm{entrykey} in the bibliography. If \prm{entrykey} is omitted, this command uses the key of the entry currently being processed. This command is employed to transform citations into clickable links pointing to the corresponding entry in the bibliography. The link target is marked automatically by \biblatex. If there are multiple bibliographies in a document, the target will be the first occurence of \prm{entrykey} in one of the bibliographies. If there are \env{refsection} environments, the links are local to the environment. See also the formatting directive \texttt{bibhyperref} in \secref{aut:fmt:ich}.

\cmditem{ifhyperref}{true}{false}

展开为\prm{true}，如果\opt{hyperref} 包选项已启用(意味着\sty{hyperref} 包已加载)，否则展开为\prm{false}。
%Expands to \prm{true} if the \opt{hyperref} package option is enabled (which implies that the \sty{hyperref} package has been loaded), and to \prm{false} otherwise.

\cmditem{docsvfield}{field}

类似于\sty{etoolbox} 包的\cmd{docsvlist} 命令，差别在于它的参数是一个域名。域的值将以一个英文逗号分隔(comma-separated)的列表进行解析。如果\prm{field} 未定义，该命令展开为空字符串。
%Similar to the \cmd{docsvlist} command from the \sty{etoolbox} package, except that it takes a field name as its argument. The value of this field is parsed as a comma"=separated list. If the \prm{field} is undefined, this command expands to an empty string.

\cmditem{forcsvfield}{handler}{field}

类似于\sty{etoolbox} 包的\cmd{forcsvlist} 命令，差别在于它的参数是一个域名。域的值将以一个英文逗号分隔(comma-separated)的列表进行解析。如果\prm{field} 未定义，该命令展开为空字符串。
%Similar to the \cmd{forcsvlist} command from the \sty{etoolbox} package, except that it takes a field name as its argument. The value of this field is parsed as a comma"=separated list. If the \prm{field} is undefined, this command expands to an empty string.

\cmditem{MakeCapital}{text}

类似于\cmd{MakeUppercase}，但仅将\prm{text} 的第一个可打印字符转换为大写。注意: \cmd{MakeUppercase} 命令的限制也适用于这一命令。即: \prm{text} 中的所有命令必须是鲁棒的或者以\cmd{protect} 为前缀，因为在大写操作中\prm{text} 需要展开。除了Ascii字符和标准重音命令外，该命令也处理\sty{inputenc} 包的活动字符和\sty{babel} 包的缩略词。如果\prm{text} 以一个控制序列开头，不做任何大写操作。该命令是鲁棒的。
%Similar to \cmd{MakeUppercase} but only converts the first printable character in \prm{text} to uppercase. Note that the restrictions that apply to \cmd{MakeUppercase} also apply to this command. Namely, all commands in \prm{text} must either be robust or prefixed with \cmd{protect} since the \prm{text} is expanded during capitalization. Apart from Ascii characters and the standard accent commands, this command also handles the active characters of the \sty{inputenc} package as well as the shorthands of the \sty{babel} package. If the \prm{text} starts with a control sequence, nothing is capitalized. This command is robust.

\cmditem{MakeSentenceCase}{text}
\cmditem*{MakeSentenceCase*}{text}

将\prm{text} 参数转换为sentence case(句子模式)，即字符串中的第一个单词首字母大写而剩下其他部分转换为小写。该命令是鲁棒的。带星号的命令与常规命令(不带星号)的差别在于它能考虑条目的语言，根据\bibfield{langid} 域指定。只有当\bibfield{langid} 未定义或者值为由\cmd{DeclareCaseLangs} 命令(见后面)声明的某种语言时，它才将\prm{text} 转换为句子模式。\footnote{默认情况下，如下语言支持转换: \texttt{american}, \texttt{british}, \texttt{canadian}, \texttt{english}, \texttt{australian}, \texttt{newzealand} as well as the aliases \texttt{USenglish} and \texttt{UKenglish}. 要扩展或修改该列表请使用\cmd{DeclareCaseLangs} 命令。} 否则\prm{text} 不做任何改变。推荐使用\cmd{MakeSentenceCase*} 而不是常规命令。两个命令都支持\file{bib} 文件的传统\bibtex 规范，即: 遇到任何以花括号包围的内容大小写都不作变化，例如:
%Converts its \prm{text} argument to sentence case, \ie the first word is capitalized and the remainder of the string is converted to lowercase. This command is robust. The starred variant differs from the regular version in that it considers the language of the entry, as specified in the \bibfield{langid} field. If the \bibfield{langid} field is defined and holds a language declared with \cmd{DeclareCaseLangs} (see below)\footnote{By default, converting to sentence case is enabled for the following language identifiers: \texttt{american}, \texttt{british}, \texttt{canadian}, \texttt{english}, \texttt{australian}, \texttt{newzealand} as well as the aliases \texttt{USenglish} and \texttt{UKenglish}. Use \cmd{DeclareCaseLangs} to extend or change this list.}, then the sentence case conversion is performed. If the \bibfield{langid} field is undefined, then the language list declared with \cmd{DeclareCaseLangs} is checked for the presence of the main document language derived from the \opt{language} option. If found, sentence case conversion is performed, if not, the \prm{text} is not altered in any way. It is recommended to use \cmd{MakeSentenceCase*} rather than the regular variant in formatting directives. Both variants support the traditional \bibtex convention for \file{bib} files that anything wrapped in a pair of curly braces is not modified when changing the case. For example:

 Depending on the option \opt{casechanger} \cmd{MakeCaseChange} and \cmd{MakeCaseChange*} are either implemented using the \sty{expl3} module \sty{l3text} or original \LaTeXe code.

Both variants support the traditional \bibtex convention for \file{bib} files that anything wrapped in a pair of curly braces is not modified when changing the case. For example:

\begin{ltxexample}
\MakeSentenceCase{an Introduction to LaTeX}
\MakeSentenceCase{an Introduction to {LaTeX}}
\end{ltxexample}
%
将得到:
%would yield:

\begin{lstlisting}[style=plain]{}
An introduction to latex
An introduction to LaTeX
\end{lstlisting}
%
在以传统\bibtex 方式设计的\file{bib} 文件中，为阻止字母的大小写变化(case-changing)，将单个字母用花括号包围是一种相当常见的方法。
%In \file{bib} files designed with traditional \bibtex in mind, it has been fairly common to only wrap single letters in braces to prevent case"=changing:

\begin{lstlisting}[style=bibtex]{}
title = {An Introduction to {L}a{T}e{X}}
\end{lstlisting}
%
这种方式存在一个问题是括号会压缩被包围字母两侧的字距。最好的方式是如第一个示例所示的那样，将整个单词都包围起来。标题中的宏也必须要用花括号仅保护。
%The problem with this convention is that the braces will suppress the kerning on both sides of the enclosed letter. It is preferable to wrap the entire word in braces as shown in the first example.
%Macros in titles must also be protected with braces

\begin{lstlisting}[style=bibtex]{}
title = {The {\TeX book}},
\end{lstlisting}
%
%Due to its complex implementation this command can not accept arbitrary input, it only safely operates on raw text or field data. In the standard styles the \texttt{title} and other \texttt{title}-like field formats do not work together with \cmd{MakeSentenceCase} because of their argument structure, so the standard styles offer a dedicated \texttt{titlecase} field format to apply this command. To enable sentence casing in standard styles for languages that support it you would use:

因为实现的复杂性，该命令不接受任意的输入，它仅在处理原始文本或域数据时才是安全。
在标准样式中，\texttt{title}类的域格式因为其参数结构不做\cmd{MakeSentenceCase}格式处理，
所以标准样式特意提供了\texttt{titlecase}域格式来实现这类命令。要在标准样式中对支持的语言启用句子模式，那么需要:

The behaviour of \cmd{MakeSentenceCase} differs slightly between the \opt{latex2e} and \opt{expl3} implementation. Generally speaking, the \opt{expl3} code is closer to the \bibtex behaviour of \texttt{change.case\$}. It is also better equipped to deal with non-ASCII input and macros than the \opt{latex2e} implementation. \cmd{MakeSentenceCase} behaves as follows.
\begin{itemize}\setlength{\labelsep}{1em}
  \item The first letter of its argument is capitalised with \cmd{MakeUppercase}. This is different from \bibtex's \texttt{change.case\$}, which does not touch the first letter of its argument.

  Note that with the \opt{latex2e} code a pair of braces that starts with a control sequence will be treated as a single character for capitalisation purposes. This means that the entire argument of a command protected with a single pair of braces is capitalised.
  \item With the \opt{latex2e} code expandable commands are expanded before the case change, which means that the case change applies to the replacement text. Unexpandable commands are not touched.

  \bibtex does not interpret macros and therefore passes commands through unchanged (this does not necessarily apply to the \emph{arguments} of those commands). The \opt{expl3} implementation also does not expand commands and only applies case change to the arguments.
  \item Text wrapped in one or more pairs of braces is protected from case change \emph{unless} it starts with a control sequence. This is the same behaviour as with \bibtex. Note that the braces could either be explicit groups or argument delimiters.
  \item Text in a single pair of braces that starts with a control sequence is not protected and will be subject to case changes. Note that this need not apply to braces that are argument delimiters, in fact the \opt{latex2e} implementation of \cmd{MakeSentenceCase} may in some cases produce an error or otherwise undesirable output if the argument of a command starts with a control sequence. \bibtex's case change function does not differentiate between argument delimiters and brace groups and always subjects text at brace level~1 to case change if it starts with a control sequence.
\end{itemize}

For most intents and purposes the following rules should give a sensible result.
\begin{itemize}\setlength{\labelsep}{1em}
  \item Protect all words whose case should not be changed by wrapping them in one pair of braces.
  \item If words are already in the braced argument of a command such as \cmd{mkbibquote} or \cmd{emph}, they are automatically protected.
  \begin{itemize}
    \item To \emph{undo} this protection wrap the command in braces again.
    \item It is not possible to selectively re-apply protection if it has been undone with an additional pair of braces. If a more fine-grained control is needed, work-arounds like splitting the argument could be tried.
  \end{itemize}
  \item While it is possible to protect words from case change at the beginning of a field with a pair of braces, it is not possible to undo the case protection that a command automatically implies by wrapping it in braces in that position. In that case work-arounds are necessary.
\end{itemize}
%
\begin{lstlisting}[style=bibtex]{}
title = {The Story of {HMS} \emph{Erebus}
         in {\emph{Really}} Strong Wind},
\end{lstlisting}
would be converted to sentence case by \cmd{MakeSentenceCase} as
\begin{quote}
The story of HMS \emph{Erebus} in {\emph{really}} strong wind
\end{quote}

If the \sty{expl3} implementation of the case changing functions is selected, the \bibtex case protection behaviour can be exchanged for a slightly simpler version. When \opt{bibtexcaseprotection} set to \opt{false}, braces no longer automatically imply case protection. Instead words can be protected from case change with \cmd{NoCaseChange}. The examples from above would then read
\begin{lstlisting}[style=bibtex]{}
title = {An Introduction to \NoCaseChange{LaTeX}},
title = {The Story of \NoCaseChange{HMS \emph{Erebus}}
         in \emph{Really} Strong Wind},
\end{lstlisting}
Generally, this option should allow for a saner case protection input, because curly braces are no longer overloaded with different levels of meaning, but it is a big departure from the standard case protection input that has been with the \latex world for a long time.

Due to its complex implementation \cmd{MakeSentenceCase} can not accept arbitrary input, it only safely operates on raw text or field data. In the standard styles the \bibfield{title} and other \bibfield{title}-like field formats do not work together with \cmd{MakeSentenceCase} because of their argument structure, so the standard styles offer a dedicated \texttt{titlecase} field format to apply this command. To enable sentence casing in standard styles for languages that support it you would use:
\begin{ltxexample}
\DeclareFieldFormat{titlecase}{<<\MakeSentenceCase*{#1}>>}
\end{ltxexample}
%
%Sentence casing can then be disabled by resetting that field format to
然后，句子模式设置可以通过如下域格式来取消:

\begin{ltxexample}
\DeclareFieldFormat{titlecase}{<<#1>>}
\end{ltxexample}

%Custom styles may follow a different approach, but style authors are encouraged to apply the same general ideas to their styles.
定制样式可以采用另一种方法，但鼓励样式作者采用相同的通用方法。

\cmditem{mkpageprefix}[pagination][postpro]{text}

该命令用于域格式化指令中，对标注命令的\prm{postnote} 参数和文献条目的\bibfield{pages} 域进行格式化。默认情况下，它将会解析\prm{text} 参数，并且以<p.> or <pp.>做为前缀。可选参数\prm{pagination} 保存指示pagination类型的域名，可以是\bibfield{pagination} 或\bibfield{bookpagination}，默认是\bibfield{pagination}。前缀与\prm{text} 之间的间距可以通过重定义\cmd{ppspace} 命令来调整。默认是一个不可断行的词内空格。详见\secref{bib:use:pag, use:cav:pag}。另可参见\cmd{DeclareNumChars}, \cmd{DeclareRangeChars}, \cmd{DeclareRangeCommands}, 和\cmd{NumCheckSetup}。可选参数\prm{postpro} 指定了用于对\prm{text} 后处理的宏。如果只给出一个可选参数，将作为\prm{pagination}，下面是两个典型示例:
%This command is intended for use in field formatting directives which format the page numbers in the \prm{postnote} argument of citation commands and the \bibfield{pages} field of bibliography entries. It will parse its \prm{text} argument and prefix it with <p.> or <pp.> by default. The optional \prm{pagination} argument holds the name of a field indicating the pagination type. This may be either \bibfield{pagination} or \bibfield{bookpagination}, with \bibfield{pagination} being the default. The spacing between the prefix and the \prm{text} may be modified by redefining \cmd{ppspace}. The default is an unbreakable interword space. See \secref{bib:use:pag, use:cav:pag} for further details. See also \cmd{DeclareNumChars}, \cmd{DeclareRangeChars}, \cmd{DeclareRangeCommands}, and \cmd{NumCheckSetup}. The optional \prm{postpro} argument specifies a macro to be used for post-processing the \prm{text}. If only one optional argument is given, it is taken as \prm{pagination}. Here are two typical examples:

\begin{ltxexample}
\DeclareFieldFormat{postnote}{<<\mkpageprefix[pagination][\mknormrange]{#1}>>}
\DeclareFieldFormat{pages}{<<\mkpageprefix[bookpagination]{#1}>>}
\end{ltxexample}
%
第一个示例中的可选参数\bibfield{pagination} 可以省略。
%The optional argument \bibfield{pagination} in the first example is omissible.

\cmditem{mkpagetotal}[pagination][postpro]{text}

该命令类似于\cmd{mkpageprefix}，差别在于它用于条目的\bibfield{pagetotal} 域，即它将打印«123 pages»而不是«page 123»。可选参数\prm{pagination} 默认是\bibfield{bookpagination}。在\prm{text} 和后缀之间的间距可由对\cmd{ppspace} 重定义进行调整。可选参数\prm{postpro} 指定了用于对\prm{text} 后处理的宏。如果只给出一个可选参数，将作为\prm{pagination}，下面是一个典型示例:
%This command is similar to \cmd{mkpageprefix} except that it is intended for the \bibfield{pagetotal} field of bibliography entries, \ie it will print «123 pages» rather than «page 123». The optional \prm{pagination} argument defaults to \bibfield{bookpagination}. The spacing inserted between the pagination suffix and the \prm{text} may be modified by redefining the macro \cmd{ppspace}. The optional \prm{postpro} argument specifies a macro to be used for post-processing the \prm{text}. If only one optional argument is given, it is taken as \prm{pagination}. Here is a typical example:

\begin{ltxexample}
\DeclareFieldFormat{pagetotal}{<<\mkpagetotal[bookpagination]{#1}>>}
\end{ltxexample}
%
在本例中可选参数\bibfield{bookpagination} 可省略。pagination本地化字符串取自
\texttt{$<$pagination$>$total} 和 \texttt{$<$pagination$>$totals}。
%The optional argument \bibfield{bookpagination} is omissible in this case.
%The pagination strings are taken from \texttt{$<$pagination$>$total} and \texttt{$<$pagination$>$totals}.

\begin{table}
\tablesetup\lnstyle
\begin{tabularx}{\textwidth}{@{}>{\ttfamily}X@{}p{0.25\textwidth}@{}p{0.25\textwidth}@{}p{0.25\textwidth}@{}}
\toprule
\multicolumn{1}{@{}H}{Input} &
\multicolumn{3}{@{}H}{Output} \\
\cmidrule(r){1-1}\cmidrule{2-4}
& \multicolumn{1}{@{}H}{\ttfamily mincomprange=10}
& \multicolumn{1}{@{}H}{\ttfamily mincomprange=100}
& \multicolumn{1}{@{}H}{\ttfamily mincomprange=1000} \\
\cmidrule(r){2-2}\cmidrule(r){3-3}\cmidrule{4-4}
11--15		& 11--5		& 11--15	& 11--15	\\
111--115	& 111--5	& 111--5	& 111--115	\\
1111--1115	& 1111--5	& 1111--5	& 1111--5	\\
\cmidrule{2-4}
& \multicolumn{1}{@{}H}{\ttfamily maxcomprange=1000}
& \multicolumn{1}{@{}H}{\ttfamily maxcomprange=100}
& \multicolumn{1}{@{}H}{\ttfamily maxcomprange=10} \\
\cmidrule(r){2-2}\cmidrule(r){3-3}\cmidrule{4-4}
1111--1115	& 1111--5	& 1111--5	& 1111--5	\\
1111--1155	& 1111--55	& 1111--55	& 1111--1155	\\
1111--1555	& 1111--555	& 1111--1555	& 1111--1555	\\
\cmidrule{2-4}
& \multicolumn{1}{@{}H}{\ttfamily mincompwidth=1}
& \multicolumn{1}{@{}H}{\ttfamily mincompwidth=10}
& \multicolumn{1}{@{}H}{\ttfamily mincompwidth=100} \\
\cmidrule(r){2-2}\cmidrule(r){3-3}\cmidrule{4-4}
1111--1115	& 1111--5	& 1111--15	& 1111--115	\\
1111--1155	& 1111--55	& 1111--55	& 1111--155	\\
1111--1555	& 1111--555	& 1111--555	& 1111--555	\\
\bottomrule
\end{tabularx}
\caption{\cmd{mkcomprange} 设置}%\cmd{mkcomprange} setup
\label{aut:aux:tab1}
\end{table}

\cmditem{mkcomprange}[postpro]{text}
\cmditem*{mkcomprange*}[postpro]{text}

%This command, which is intended for use in field formatting directives, will parse its \prm{text} argument for page ranges and compress them. For example, «125--129» may be formatted as «125--9». You may configure the behavior of \cmd{mkcomprange} by adjusting the \latex counters \cnt{mincomprange}, \cnt{maxcomprange}, and \cnt{mincompwidth}, as illustrated in \tabref{aut:aux:tab1}. The default settings are \texttt{10}, \texttt{100000}, and \texttt{1}, respectively. This means that the command tries to compress as much as possible by default. Use \cmd{setcounter} to adjust the parameters. The scanner recognizes \cmd{bibrangedash} and hyphens as range dashes. It will normalize the dash by replacing any number of consecutive hyphens with \cmd{bibrangedash}. Lists of ranges delimited with \cmd{bibrangessep} are also supported. The backend will normalise any comma or semi-colons surrounded by optional space by replacing them with \cmd{bibrangessep}. If you want to hide a character from the list/range scanner for some reason, wrap the character or the entire string in curly braces. The optional \prm{postpro} argument specifies a macro to be used for post-processing the \prm{text}. This is important if you want to combine \cmd{mkcomprange} with other formatting macros which also need to parse their \prm{text} argument, such as \cmd{mkpageprefix}. Simply nesting these commands will not work as expected. Use the \prm{postpro} argument to set up the processing chain as follows:
该命令用于域格式化指令，将\prm{text} 参数解析为页码范围并且压缩这些范围。例如，«125--129»可能格式化为«125--9»。可以通过调整\latex 计数器\cnt{mincomprange}, \cnt{maxcomprange} 和 \cnt{mincompwidth} 来设置\cmd{mkcomprange} 的操作方式，如表\ref{aut:aux:tab1} 所示。默认的设置分别是\texttt{10}, \texttt{100000}, and \texttt{1}。
这意味着该命令默认是尽可能的压缩。使用\cmd{setcounter} 来调整参数。扫描程序将\cmd{bibrangedash} 和hyphens作为范围间隔符。它通过将使用\cmd{bibrangedash} 的任意数量连续连字符替换破折号(dash)实现正规化。支持以\cmd{bibrangessep} 分隔的多范围列表。后端会将逗号或冒号(commas/semicolon)的多范围分隔符转换为\cmd{bibrangessep}。如果因为某些原因需要对list/range扫描程序隐藏一个字符，那么可以将该字符或者整个字符串用花括号包围起来。可选参数\prm{postpro} 指定了一个用于对\prm{text} 进行后处理的宏。这对于需要将\cmd{mkcomprange} 和其它也要解析它们自身的\prm{text} 参数的格式化宏(比如\cmd{mkpageprefix})联合使用非常重要。简单的嵌套可能无法如期正常工作。使用\prm{postpro} 参数构建的处理链，如下:


\begin{ltxexample}
\DeclareFieldFormat{postnote}{\mkcomprange[<<{>>\mkpageprefix[pagination]<<}>>]{#1}}
\end{ltxexample}
%
注意:\cmd{mkcomprange} 命令首先处理，\cmd{mkpageprefix} 则作为后处理器。也要注意\prm{postpro} 被额外的一对花括号包围。这仅在特殊情况下需要，为阻止\latex 的可选参数扫描器与嵌套的方括号混淆。带星的命令与不带星命令的差别是它的\prm{postpro} 参数应用于列表中的各项，例如:
%Note that \cmd{mkcomprange} is executed first, using \cmd{mkpageprefix} as post-processor. Also note that the \prm{postpro} argument is wrapped in an additional pair of braces. This is only required in this particular case to prevent \latex's optional argument scanner from getting confused by the nested brackets. The starred version of this command differs from the regular one in the way the \prm{postpro} argument is applied to a list of values. For example:

\begin{ltxexample}
\mkcomprange[\mkpageprefix]{5, 123-129, 423-439}
\mkcomprange*[\mkpageprefix]{5, 123-129, 423-439}
\end{ltxexample}
%
将输出:
%will output:

\begin{ltxexample}
pp. 5, 123-9, 423-39
p. 5, pp. 123-9, pp. 423-39
\end{ltxexample}
%
The second optional argument \prm{itempostpro} is used to post-process each individual number item in the formatted list. It can be used to convert numbers from cardinals to ordinals. If only one optional argument is present, it is treated as \prm{postpro}.

\cmditem{mknormrange}[postpro][itempostpro]{text}
\cmditem*{mknormrange*}[postpro][itempostpro]{text}

%This command, which is intended for use in field formatting directives, will parse its \prm{text} argument for page ranges and will normalise them. The command is similar to \cmd{mkcomprange} except that the page ranges will not be compressed. The scanner recognises \cmd{bibrangedash} and hyphens as range dashes. It will normalize the dash by replacing any number of consecutive hyphens with \cmd{bibrangedash}. Lists of ranges delimited with \cmd{bibrangessep} are also supported. The scanner will normalise any comma or semi-colons surrounded by optional space by replacing them with \cmd{bibrangessep}. If you want to hide a character from the list/range scanner for some reason, wrap the character or the entire string in curly braces. The optional \prm{postpro} argument specifies a macro to be used for post-processing the \prm{text}. See \cmd{mkcomprange} on how to use this argument. The starred version of this command differs from the regular one in the way the \prm{postpro} argument is applied to a list of values.
该命令用于域的格式化指令中，将会解析其\prm{text}参数来实现和规范页码范围。
该命令类似于\cmd{mkcomprange}，不同在于页码范围不被压缩。
扫描器识别\cmd{bibrangedash}，并处理为一个范围破折号。
它会规范破折号来代替连续的\cmd{bibrangedash}。以\cmd{bibrangessep}分隔的范围列表，也支撑这一处理。
扫描器将规范任意逗号或分号为\cmd{bibrangessep}。如果想要隐藏他们，那么将其或整个字符串用花括号包围起来。
可选参数\prm{postpro}指定了\prm{text}后处理中用的宏。如何使用该参数见\cmd{mkcomprange}。带星号的版本差别在于\prm{postpro}参数应用于列表。

This command, which is intended for use in field formatting directives, will parse its \prm{text} argument for page ranges and will normalise them. The command is similar to \cmd{mkcomprange} except that the page ranges will not be compressed. The scanner recognises \cmd{bibrangedash} and hyphens as range dashes. It will normalize the dash by replacing any number of consecutive hyphens with \cmd{bibrangedash}. Lists of ranges delimited with \cmd{bibrangessep} are also supported. The scanner will normalise any comma or semicolons surrounded by optional space by replacing them with \cmd{bibrangessep}. If you want to hide a character from the list/range scanner for some reason, wrap the character or the entire string in curly braces. The optional \prm{postpro} argument specifies a macro to be used for post-processing the \prm{text}. See \cmd{mkcomprange} on how to use this argument. The starred version of this command differs from the regular one in the way the \prm{postpro} argument is applied to a list of values. The second optional argument \prm{itempostpro} is used to post-process each individual number item in the formatted list. It can be used to convert numbers from cardinals to ordinals. If only one optional argument is present, it is treated as \prm{postpro}.

\cmditem{mkfirstpage}[postpro][itempostpro]{text}
\cmditem*{mkfirstpage*}[postpro][itempostpro]{text}

该命令用于域格式化指令，将\prm{text} 参数解析为页码范围并且仅打印这些范围的起始页码。扫描程序将\cmd{bibrangedash} 和hyphens作为范围间隔符。支持范围列表以\cmd{bibrangessep} 分隔。如果因为某些原因需要对list/range扫描程序隐藏一个字符，那么可以将该字符或者整个字符串用花括号包围起来。可选参数\prm{postpro} 指定了一个用于对\prm{text} 进行后处理的宏。怎么使用该参数见\cmd{mkcomprange} 命令。带星的命令的差别在于\prm{postpro} 参数应用于列表的各项。例如:
%This command, which is intended for use in field formatting directives, will parse its \prm{text} argument for page ranges and print the start page of the range only. The scanner recognizes \cmd{bibrangedash} and hyphens as range dashes. Lists of ranges delimited with \cmd{bibrangessep} are also supported. If you want to hide a character from the list/range scanner for some reason, wrap the character or the entire string in curly braces. The optional \prm{postpro} argument specifies a macro to be used for post-processing the \prm{text}. See \cmd{mkcomprange} on how to use this argument. The starred version of this command differs from the regular one in the way the \prm{postpro} argument is applied to a list of values. For example:

This command, which is intended for use in field formatting directives, will parse its \prm{text} argument for page ranges and print the start page of the range only. The scanner recognizes \cmd{bibrangedash} and hyphens as range dashes. Lists of ranges delimited with \cmd{bibrangessep} are also supported. If you want to hide a character from the list/range scanner for some reason, wrap the character or the entire string in curly braces. The optional \prm{postpro} argument specifies a macro to be used for post-processing the \prm{text}. See \cmd{mkcomprange} on how to use this argument. The starred version of this command differs from the regular one in the way the \prm{postpro} argument is applied to a list of values. The second optional argument \prm{itempostpro} is used to post-process each individual number item in the formatted list. It can be used to convert numbers from cardinals to ordinals. If only one optional argument is present, it is treated as \prm{postpro}. For example:

\begin{ltxexample}
\mkfirstpage[\mkpageprefix]{5, 123-129, 423-439}
\mkfirstpage*[\mkpageprefix]{5, 123-129, 423-439}
\end{ltxexample}
%
将输出:
%will output:

\begin{ltxexample}
pp. 5, 123, 423
p. 5, p. 123, p. 423
\end{ltxexample}

\cmditem{rangelen}{rangefield}
该命令将其参数解析为一个范围，并返回范围的长度。计算由\biber 负责可以处理很多特殊情况。对于无终点的(开口的)范围将返回-1。特别的，\cmd{rangelen} 可以:
%这可以作为样式中一些判断的一部分，例如将<f>作为只有两页的范围的后缀，比如范围<36-37>将打印<36f>。这可以通过命令\cmd{ifnumcomp} 实现:
%Takes the name of a bibfield declared as a range field in the data model and returns the length of the range. This is calculated by \biber and can handle many special cases. It will return $-1$ for open ended ranges. Specifically  can:

\begin{itemize}
\item 计算同一个域中多个范围比如<1-10, 20-30>的总数
%Calculate the total of multiple ranges in the same field such as <1-10, 20-30>
\item 处理隐含的范围比如<22-4> and <130-33>
%Handle implicit ranges such as <22-4> and <130-33>
\item 处理大小写的罗马数字范围，处理ASCII码和统一码表示的罗马数字范围。
%Handle roman numeral ranges in upper and lower case and consisting of both ASCII and Unicode roman numeral representations.
\end{itemize}
%
下面是一些示例:
%Here are some examples:

\begin{tabular}{ll}
pages = <10> & |\rangelen{pages}| returns '1'\\
pages = <10-15> & |\rangelen{pages}| returns '6'\\
pages = <10-15,47-53> & |\rangelen{pages}| returns '13'\\
pages = <10-> & |\rangelen{pages}| returns '-1'\\
pages = <-10> & |\rangelen{pages}| returns '-1'\\
pages = <48-9> & |\rangelen{pages}| returns '2'\\
pages = <172-77> & |\rangelen{pages}| returns '6'\\
pages = <i-vi> & |\rangelen{pages}| returns '6'\\
pages = <X-XX> & |\rangelen{pages}| returns '11'\\
pages = <ⅥⅠ-ⅻ> & |\rangelen{pages}| returns '6'\\
pages = <ⅥⅠ-ⅻ, 145-7, 135-39> & |\rangelen{pages}| returns '14'
\end{tabular}

\cmd{rangelen} 命令可以用于判断中:
%The \cmd{rangelen} command can be used in tests:

\begin{ltxexample}
\ifnumcomp{\rangelen{pages}}{=}{1}{add 'f'}{do nothing}
\end{ltxexample}

\cmditem{DeclareNumChars}{characters}
\cmditem*{DeclareNumChars*}{characters}

该命令设置\secref{aut:aux:tst} 节的\cmd{ifnumeral}, \cmd{ifnumerals} 和\cmd{ifpages} 命令。该设置也将影响\cmd{iffieldnum}, \cmd{iffieldnums}, \cmd{iffieldpages}, \cmd{mkpageprefix} 和 \cmd{mkpagetotal} 命令。\prm{characters} 参数是一个无分隔符的符号列表，将作为数字的一部分进行处理。不带星命令将替换当前设置，带星命令则将其参数附加到当前列表中。默认设置为:
%This command configures the \cmd{ifnumeral}, \cmd{ifnumerals}, and \cmd{ifpages} tests from \secref{aut:aux:tst}. The setup will also affect \cmd{iffieldnum}, \cmd{iffieldnums}, \cmd{iffieldpages} as well as \cmd{mkpageprefix} and \cmd{mkpagetotal}. The \prm{characters} argument is an undelimited list of characters which are to be considered as being part of a number. The regular version of this command replaces the current setting, the starred version appends its argument to the current list. The default setting is:

\begin{ltxexample}
\DeclareNumChars{.}
\end{ltxexample}
%
这意味着(节或者其他)数值比如 <3.4.5> 将被认为是一个数字。注意，默认检测的是阿拉伯和罗马数字，没有必要对此做显式声明。
%This means that a (section or other) number like <3.4.5> will be considered as a number. Note that Arabic and Roman numerals are detected by default, there is no need to declare them explicitly.

\cmditem{DeclareRangeChars}{characters}
\cmditem*{DeclareRangeChars*}{characters}

该命令设置\secref{aut:aux:tst} 的\cmd{ifnumerals} 和\cmd{ifpages} 命令。其设置还将影响\cmd{iffieldnums}， \cmd{iffieldpages} ，\cmd{mkpageprefix} 和\cmd{mkpagetotal}。\prm{characters} 参数是一个无分隔符的符号列表，将作为范围指示符进行处理。不带星命令将替换当前设置，带星命令则将其参数附加到当前列表中。默认设置为:
%This command configures the \cmd{ifnumerals} and \cmd{ifpages} tests from \secref{aut:aux:tst}. The setup will also affect \cmd{iffieldnums} and \cmd{iffieldpages} as well as \cmd{mkpageprefix} and \cmd{mkpagetotal}. The \prm{characters} argument is an undelimited list of characters which are to be considered as range indicators. The regular version of this command replaces the current setting, the starred version appends its argument to the current list. The default setting is:

\begin{ltxexample}
\DeclareRangeChars{~,;-+/}
\end{ltxexample}

For engines that fully support Unicode these defaults are extended with
\begin{ltxexample}[escapeinside={(*@}{@*)}]
\DeclareRangeChars*{(*@–—@*)}
\end{ltxexample}
%
这意味着比如<3--5>, <35+>, <8/9>等字符串会被\cmd{ifnumerals} 和\cmd{ifpages} 认为是一个范围。这些字符串中的非范围字符将被认为是数字。因此，类似于<3a--5a>和<35b+>之类的字符串默认情况下不被认为是范围。更多细节详见\secref{bib:use:pag, use:cav:pag}。
%This means that strings like <3--5>, <35+>, <8/9> and so on will be considered as a range by \cmd{ifnumerals} and \cmd{ifpages}. Non-range characters in such strings are recognized as numbers. So strings like <3a--5a> and <35b+> are not deemed to be ranges by default. See also \secref{bib:use:pag, use:cav:pag} for further details.

\cmditem{DeclareRangeCommands}{commands}
\cmditem*{DeclareRangeCommands*}{commands}

该命令类似于\cmd{DeclareRangeChars}，差别在于\prm{commands} 参数是一个无分隔符的命令列表，将被视为范围指示符。不带星命令将替换当前设置，带星命令则将其参数附加到当前列表中。默认列表相当长，应该覆盖所有一般情况。下面是一个简单示例:
%This command is similar to \cmd{DeclareRangeChars}, except that the \prm{commands} argument is an undelimited list of commands which are to be considered as range indicators. The regular version of this command replaces the current setting, the starred version appends its argument to the current list. The default list is rather long and should cover all common cases; here is a shorter example:

\begin{ltxexample}
\DeclareRangeCommands{\&\bibrangedash\textendash\textemdash\psq\psqq}
\end{ltxexample}
%
更多细节参见\secref{bib:use:pag, use:cav:pag}。
%See also \secref{bib:use:pag, use:cav:pag} for further details.

\cmditem{DeclarePageCommands}{commands}
\cmditem*{DeclarePageCommands*}{commands}

该命令类似于\cmd{DeclareRangeCommands}，差别在于它仅影响\cmd{ifpages} 和\cmd{iffieldpages} 判断，而不影响\cmd{ifnumerals} 和\cmd{iffieldnums}。默认设置为:
%This command is similar to \cmd{DeclareRangeCommands}, except that it only affects the \cmd{ifpages} and \cmd{iffieldpages} tests but not \cmd{ifnumerals} and \cmd{iffieldnums}. The default setting is:

\begin{ltxexample}
\DeclarePageCommands{\pno\ppno}
\end{ltxexample}

\cmditem{NumCheckSetup}{code}

该命令用于临时重定义一些将与\secref{aut:aux:tst} 节的\cmd{ifnumeral}, \cmd{ifnumerals}, \cmd{ifpages} 命令执行的判断产生冲突的命令。该设置也将影响\cmd{iffieldnum}, \cmd{iffieldnums}, \cmd{iffieldpages}, \cmd{mkpageprefix} 和\cmd{mkpagetotal}。这些命令将在组内执行\prm{code}。因为上述命令将展开为字符串用于分析，可以利用将冲突命令展开为空字符串(将被判断命令忽略)的方式来移除这些命令。更多细节参见\secref{bib:use:pag, use:cav:pag}。
%Use this command to temporarily redefine any commands which interfere with the tests performed by \cmd{ifnumeral}, \cmd{ifnumerals}, and \cmd{ifpages} from \secref{aut:aux:tst}. The setup will also affect \cmd{iffieldnum}, \cmd{iffieldnums}, \cmd{iffieldpages} as well as \cmd{mkpageprefix} and \cmd{mkpagetotal}. The \prm{code} will be executed in a group by these commands. Since the above mentioned commands will expand the string to be analyzed, it is possible to remove commands to be ignored by the tests by making them expand to an empty string. See also \secref{bib:use:pag, use:cav:pag} for further details.

\cmditem{NumsCheckSetup}{code}

Like \cmd{NumCheckSetup} but only applies to \cmd{ifnumerals} and \cmd{ifpages} from \secref{aut:aux:tst} and their derivative tests.

\cmditem{PagesCheckSetup}{code}

Like \cmd{NumCheckSetup} but only applies to \cmd{ifpages} from \secref{aut:aux:tst} and its derivative tests. The default setting is makes \cmd{pnfmt} transparent to the test:

\begin{ltxexample}
\PagesCheckSetup{\let\pnfmt\@firstofone}
\end{ltxexample}

\cmditem{DeclareBabelToExplLanguageMapping}{babel language}{expl language}

This command is only available if the \sty{expl3} case changing code is used.

Use \prm{expl language} as \prm{language} argument for the \sty{l3text} case changing functions when \sty{babel language} is active. This command is only required if \prm{babel language} should correspond to a language for which \sty{l3text} has special rules set up. The default invocations of this command are
\begin{ltxexample}
\DeclareBabelToExplLanguageMapping{dutch}{nl}
\DeclareBabelToExplLanguageMapping{greek}{el}
\DeclareBabelToExplLanguageMapping{turkish}{tr}
\end{ltxexample}

\cmditem{UndeclareBabelToExplLanguageMapping}{babel language}

This command is only available if the \sty{expl3} case changing code is used.

Removes the \sty{babel}-to-\sty{expl3} language mapping for \prm{babel language}. If the argument is an asterisk \texttt{*}, all language mappings are removed.
\cmditem{DeclareCaseLangs}{languages}
\cmditem*{DeclareCaseLangs*}{languages}

定义语言列表，该列表在\cmd{MakeSentenceCase*} 命令将一个字符串转换成句子模式时考虑。\prm{languages} 参数是一个由\sty{babel}/\sty{polyglossia} 语言标识构成的逗号分隔的列表。不带星命令用于替换当前设置，而带星的命令用于附加当前列表。默认的设置为:
%Defines the list of languages which are considered by the \cmd{MakeSentenceCase*} command as it converts a string to sentence case. The \prm{languages} argument is a comma"=separated list of \sty{babel}/\sty{polyglossia} language identifiers. The regular version of this command replaces the current setting, the starred version appends its argument to the current list. The default setting is:

\begin{ltxexample}
\DeclareCaseLangs{%
  american,british,canadian,english,australian,newzealand,USenglish,UKenglish}
\end{ltxexample}
%
语言标识的列表见\sty{babel}/\sty{polyglossia} 手册和表\ref{bib:fld:tab1}。
%See the \sty{babel}/\sty{polyglossia} manuals and \tabref{bib:fld:tab1} for a list of languages identifiers.

\cmditem{BibliographyWarning}{message}

该命令类似于\cmd{PackageWarning}，但打印内容除了输入行号外还有当前处理条目的引用关键词。如果\prm{message} 相当长，可以使用\cmd{MessageBreak} 命令来断行。注意: 标准的\cmd{PackageWarning} 命令在参考文献中使用时无法提供一个有意义的提示，因为其打印的输入行号只是\cmd{printbibliography} 命令所在的行号。
%This command is similar to \cmd{PackageWarning} but prints the entry key of the entry currently being processed in addition to the input line number. It may be used in the bibliography as well as in citation commands. If the \prm{message} is fairly long, use \cmd{MessageBreak} to include line breaks. Note that the standard \cmd{PackageWarning} command does not provide a meaningful clue when used in the bibliography since the input line number is the line on which the \cmd{printbibliography} command was given.

%该命令用于\file{cbx}\slash\file{bbx} 文件和\file{bib} 文件的\texttt{@preamble}(导言)中。它检测选择的后端程序，如果后端不是\biber 则发出警告。可选参数\prm{severity} 是一个整数用于指定警告的严重程度。当值等于1时将触发一个消息陈述推荐使用\biber；当值等于2触发一个警告陈述需要使用\biber ，否则样式或\slash\file{bib} 文件可能无法正常工作；当值等于3触发一个错误信息陈述\biber 是严格必须的，样式或\slash\file{bib} 文件在其它后端下将无法正常工作。如果\cmd{RequireBiber} 命令多次使用，\prm{severity} 应取最大值。\file{cbx}\slash\file{bbx} 文件和所有\file{bib} 文件的\texttt{@preamble}(导言)部分作为两个方面，其追踪是分别进行的。如果可选参数\prm{severity} 缺省，那么默认值是2(触发一个警告信息)。

\boolitem{pagetracker}
\leavevmode\vspace{\numexpr2\baselineskip}% fix margin spilling into the text

这些命令将启用或关闭局部引用追踪器(这将影响来自\secref{aut:aux:tst} 节的\cmd{iffirstonpage} 和\cmd{ifsamepage} 判断)。可在标注命令定义或者正文中的任意位置使用。要使标注命令完全排除页码追踪，可以在\cmd{DeclareCiteCommand} 命令的\prm{precode} 参数中使用\cmd{pagetrackerfalse}。详见\secref{aut:cbx:cbx}。注意: 当全局页码追踪关闭时，这些命令无效。
%These commands activate or deactivate the citation tracker locally (this will affect the \cmd{iffirstonpage} and \cmd{ifsamepage} test from \secref{aut:aux:tst}). They are intended for use in the definition of citation commands or anywhere in the document body. If a citation command is to be excluded from page tracking, use \cmd{pagetrackerfalse} in the \prm{precode} argument of \cmd{DeclareCiteCommand}. See \secref{aut:cbx:cbx} for details. Note that these commands have no effect if page tracking has been disabled globally.

\boolitem{citetracker}
\leavevmode\vspace{\numexpr2\baselineskip}% fix margin spilling into the text

这些命令将启用或关闭所有的局部引用追踪器(这将影响来自\secref{aut:aux:tst} 节的 \cmd{ifciteseen}, \cmd{ifentryseen}, \cmd{ifciteibid}, 和\cmd{ifciteidem} 判断)。可在标注命令定义或者正文中的任意位置使用。要使标注命令完全排除页码追踪，可以在\cmd{DeclareCiteCommand} 命令的\prm{precode} 参数中使用\cmd{citetrackerfalse}。详见\secref{aut:cbx:cbx}。注意: 当全局追踪关闭时，这些命令无效。
%These commands activate or deactivate all citation trackers locally (this will affect the \cmd{ifciteseen}, \cmd{ifentryseen}, \cmd{ifciteibid}, and \cmd{ifciteidem} tests from \secref{aut:aux:tst}). They are intended for use in the definition of citation commands or anywhere in the document body. If a citation command is to be excluded from tracking, use \cmd{citetrackerfalse} in the \prm{precode} argument of \cmd{DeclareCiteCommand}. See \secref{aut:cbx:cbx} for details. Note that these commands have no effect if tracking has been disabled globally.

\boolitem{backtracker}
\leavevmode\vspace{\numexpr2\baselineskip}% fix margin spilling into the text

这些命令将启用或关闭所有的局部\texttt{backref} 追踪器。可在标注命令定义或者正文中的任意位置使用。要使标注命令完全排除反向链接追踪，可以在\cmd{DeclareCiteCommand} 命令的\prm{precode} 参数中使用\cmd{backtrackerfalse}。注意: 当\texttt{backref} 选项未进行全局设置，这些命令无效。
%These commands activate or deactivate the \texttt{backref} tracker locally. They are intended for use in the definition of citation commands or anywhere in the document body. If a citation command is to be excluded from backtracking, use \cmd{backtrackerfalse} in the \prm{precode} argument of \cmd{DeclareCiteCommand}. Note that these commands have no effect if the \texttt{backref} option has been not been set globally.

\end{ltxsyntax}

\subsection[标点和间距]{标点和间距}%Punctuation and Spacing
\label{aut:pct}

\biblatex 宏包提供了设计用来在文献著录表和标注中管理和追踪标点与空格的精致工具。这些工具在两个层面工作。\secref{aut:pct:new} 节讨论的高层(high-level)命令处理由著录样式在一个参考文献条目的不同部分插入的标点和空格。而\secref{aut:pct:chk, aut:pct:pct, aut:pct:spc} 节中的命令在更低一层工作。它们以一种健壮高效的方式使用\tex 的\gls{间距因子} 并间距因子修改代码来追踪标点。采用这种方法，不仅可以检测在域间显式插入的标点符号，也可以检测在域内末尾的标点符号。相同的技术也用在本地化字符串的自动大写处理过程中，详见\secref{aut:pct:cfg} 节的\cmd{DeclareCapitalPunctuation} 命令以及\secref{aut:str} 节。注意: 这些工具仅在标注和文献著录表内局部使用。它们不会影响正文中其他任何部分。
%The \biblatex package provides elaborate facilities designed to manage and track punctuation and spacing in the bibliography and in citations. These facilities work on two levels. The high"=level commands discussed in \secref{aut:pct:new} deal with punctuation and whitespace inserted by the bibliography style between the individual segments of a bibliography entry. The commands in \secref{aut:pct:chk, aut:pct:pct, aut:pct:spc} work at a lower level. They use \tex's space factor and modified space factor codes to track punctuation in a robust and efficient way. This way it is possible to detect trailing punctuation marks within fields, not only those explicitly inserted between fields. The same technique is also used for automatic capitalization of localisation strings, see \cmd{DeclareCapitalPunctuation} in \secref{aut:pct:cfg} as well as \secref{aut:str} for details. Note that these facilities are only made available locally in citations and bibliographies. They will not affect any other part of a document.

\subsubsection{块和单元的标点}%Block and Unit Punctuation
\label{aut:pct:new}

参考文献条目的主要组成部分是块(<blocks>)和单元(<units>)。其中块更大，单元相对较小，至多长度上与块相等。例如，诸如\bibfield{title} 或\bibfield{note} 等域的值常构成一个单元，并且用一个句号或逗号与后面的数据分隔开来。一个块可以由多个域构成，这些域被认为是独立的单元，例如\bibfield{publisher}, \bibfield{location} 和\bibfield{year}。一个条目如何划分成块和单元完全是由著录样式决定的。条目内容的划分通过在合适位置插入\cmd{newblock} 和\cmd{newunit} 命令，在末尾插入\cmd{finentry} 命令(见\secref{aut:bbx:drv} 的示例)来实现。一些实用提示见\secref{aut:cav:pct} 节。
%The major segments of a bibliography entry are <blocks> and <units>. A block is the larger segment of the two, a unit is shorter or at most equal in length. For example, the values of fields such as \bibfield{title} or \bibfield{note} usually form a unit which is separated from subsequent data by a period or a comma. A block may comprise several fields which are treated as separate units, for example \bibfield{publisher}, \bibfield{location}, and \bibfield{year}. The segmentation of an entry into blocks and units is at the discretion of the bibliography style. An entry is segmented by inserting \cmd{newblock} and \cmd{newunit} commands at suitable places and \cmd{finentry} at the very end (see \secref{aut:bbx:drv} for an example). See also \secref{aut:cav:pct} for some practical hints.

\begin{ltxsyntax}

\csitem{newblock}

标记一个块的终点。该命令不打印任何内容，仅标记块的结束。块的分隔符\cmd{newblockpunct} 将由后面跟着的\cmd{printtext}, \cmd{printfield}, \cmd{printlist}, \cmd{printnames},或\cmd{bibstring} 命令插入。可以在合适的位置使用 \cmd{newblock} 而不需要担心产生多余的块。一个新的块仅在其后是\cmd{printfield}(或类似)命令且打印一些内容的情况下开始。详见\secref{aut:cav:pct}。
%Records the end of a block. This command does not print anything, it merely marks the end of the block. The block delimiter \cmd{newblockpunct} will be inserted by a subsequent \cmd{printtext}, \cmd{printfield}, \cmd{printlist}, \cmd{printnames}, or \cmd{bibstring} command. You may use \cmd{newblock} at suitable places without having to worry about spurious blocks. A new block will only be started by the next \cmd{printfield} (or similar) command if this command prints anything. See \secref{aut:cav:pct} for further details.

\csitem{newunit}

记录一个单元的终点，并将默认分隔符 \cmd{newunitpunct} 放入标点缓存中。该命令不打印任何内容，仅标记单元的结束。标点缓存将由接下来的\cmd{printtext}, \cmd{printfield}, \cmd{printlist}, \cmd{printnames}, 或\cmd{bibstring} 命令插入。可以在类似\cmd{printfield} 的命令后面使用\cmd{newunit}，而不需要担心带来多余的标点和空格。标点缓存只能由后面的\cmd{printfield} 或者类似命令且打印的域非空时插入。这一方式也应用于\cmd{printtext}, \cmd{printlist}, \cmd{printnames} 和\cmd{bibstring} 命令。详见\secref{aut:cav:pct} 节。
%Records the end of a unit and puts the default delimiter \cmd{newunitpunct} in the punctuation buffer. This command does not print anything, it merely marks the end of the unit. The punctuation buffer will be inserted by the next \cmd{printtext}, \cmd{printfield}, \cmd{printlist}, \cmd{printnames}, or \cmd{bibstring} command. You may use \cmd{newunit} after commands like \cmd{printfield} without having to worry about spurious punctuation and whitespace. The buffer will only be inserted by the next \cmd{printfield} or similar command if \emph{both} fields are non"=empty. This also applies to \cmd{printtext}, \cmd{printlist}, \cmd{printnames}, and \cmd{bibstring}. See \secref{aut:cav:pct} for further details.

\csitem{finentry}

插入 \cmd{finentrypunct}。该命令应在每个参考文献条目的最末尾使用。
%Inserts \cmd{finentrypunct}. This command should be used at the very end of every bibliography entry.

\cmditem{setunit}{punctuation}
\cmditem*{setunit*}{punctuation}

\cmd{setunit} 类似于\cmd{newunit}，除了它使用\prm{punctuation} 代替\cmd{newunitpunct}。带星号命令与不带星号命令的差别在于它检查前面最近的\cmd{printtext}, \cmd{printfield}, \cmd{printlist}, \cmd{printnames} 或 \cmd{bibstring} 命令是否实际打印内容。如果没有打印，该命令不做任何处理。
%The \cmd{setunit} command is similar to \cmd{newunit} except that it uses \prm{punctuation} instead of \cmd{newunitpunct}. The starred variant differs from the regular version in that it checks if the last \cmd{printtext}, \cmd{printfield}, \cmd{printlist}, \cmd{printnames}, or \cmd{bibstring} command did actually print anything. If not, it does nothing.

\cmditem{printunit}{punctuation}
\cmditem*{printunit*}{punctuation}

\cmd{printunit} 命令类似于\cmd{setunit}，但\prm{punctuation} 继续存留在缓存中。这能确保\prm{punctuation} 能在由\cmd{printtext}, \cmd{printfield}, \cmd{printlist}, \cmd{printnames}, or \cmd{bibstring} 命令打印下一个非空域前插入---不管任何立即调用的\cmd{newunit} 或\cmd{setunit} 命令。(译者: 即该命令设置的标点只要后面还有非空域需要打印都会插入。)
%The \cmd{printunit} command is similar to \cmd{setunit} except that \prm{punctuation} persists in the buffer. This ensures that \prm{punctuation} is inserted before the next non"=empty field printed by the \cmd{printtext}, \cmd{printfield}, \cmd{printlist}, \cmd{printnames}, or \cmd{bibstring} commands---regardless of any intermediate calls to \cmd{newunit} or \cmd{setunit}.

\cmditem{setpunctfont}{command}

该命令用于域格式化指令中，提供了处理打印为另一种字体(比如斜体打印的标题)的域后面的单元标点的替换方式。标准的\latex 处理方式是在后面添加一个小的空格，称为斜体修正。该命令允许将标点调整为之前的域采用的字体。\prm{command} 应是带一个参数的text字体命令，比如\cmd{emph} 或\cmd{textbf}。该命令仅影响由\secref{aut:pct:pct} 节的命令插入的标点符号。字体调整仅应用于接下来的标点符号，处理之后将自动重设。如果希望在它生效之前手动重设，使用\cmd{resetpunctfont}。如果\opt{punctfont} 选项关闭，该命令不做任何处理。注意\secref{aut:fmt:ich} 节的\cmd{mkbibemph}, \cmd{mkbibitalic} 和\cmd{mkbibbold} 封套命令自动包含该功能。
%This command, which is intended for use in field formatting directives, provides an alternative way of dealing with unit punctuation after a field printed in a different font (for example, a title printed in italics). The standard \latex way of dealing with this is adding a small amount of space, the so-called italic correction. This command allows adapting the punctuation to the font of the preceding field. The \prm{command} should be a text font command which takes one argument, such as \cmd{emph} or \cmd{textbf}. This command will only affect punctuation marks inserted by one of the commands from \secref{aut:pct:pct}. The font adaption is applied to the next punctuation mark only and will be reset automatically thereafter. If you want to reset it manually before it takes effect, issue \cmd{resetpunctfont}. If the \opt{punctfont} package option is disabled, this command does nothing. Note that the \cmd{mkbibemph}, \cmd{mkbibitalic} and \cmd{mkbibbold}  wrappers from \secref{aut:fmt:ich} incorporate this feature by default.

\csitem{resetpunctfont}

该命令在其生效之前重设由\cmd{setpunctfont} 定义的单元标点字体。如果\opt{punctfont} 选项关闭，该命令不做任何处理。
%This command resets the unit punctuation font defined with \cmd{setpunctfont} before it takes effect. If the \opt{punctfont} package option is disabled, this command does nothing.

\end{ltxsyntax}

\subsubsection{标点判断}%Punctuation Tests
\label{aut:pct:chk}

下面的命令可以用来在标注和文献表的任意位置判断前面的标点符号。
%The following commands may be used to test for preceding punctuation marks at any point in citations and the bibliography.

\begin{ltxsyntax}

\cmditem{ifpunct}{true}{false}

如果前面的是除缩略点外的标点符号，执行\prm{true}，否则执行\prm{false}。
%Executes \prm{true} if preceded by any punctuation mark except for an abbreviation dot, and \prm{false} otherwise.

\cmditem{ifterm}{true}{false}

如果前面的是一个终结标点(terminal punctuation mark)，执行\prm{true}，否则执行\prm{false}。终结标点是设置用来自动大写的任意标点符号，可以使用默认符号或者用\cmd{DeclareCapitalPunctuation} 设定，详见 \secref{aut:pct:cfg}。默认情况下，用句号，叹号和问号。
%Executes \prm{true} if preceded by a terminal punctuation mark, and \prm{false} otherwise. A terminal punctuation mark is any punctuation mark which has been registered for automatic capitalization, either with \cmd{DeclareCapitalPunctuation} or by default, see \secref{aut:pct:cfg} for details. By default, this applies to periods, exclamation marks, and question marks.

\cmditem{ifpunctmark}{character}{true}{false}

如果前面的是一个\prm{character} 标点符，执行\prm{true}，否则执行\prm{false}。\prm{character} 可以是逗号，分号，冒号，句号，叹号，问号或星号。注意，一个句号代表一个结束句子的句号。使用星号用来判断缩略词后的点号。如果该命令用于姓名列表的格式化指令，即在\cmd{DeclareNameFormat} 的参数中，\prm{character} 也可以是撇号。
%Executes \prm{true} if preceded by the punctuation mark \prm{character}, and \prm{false} otherwise. The \prm{character} may be a comma, a semicolon, a colon, a period, an exclamation mark, a question mark, or an asterisk. Note that a period denotes an end-of"=sentence period. Use the asterisk to test for the dot after an abbreviation. If this command is used in a formatting directive for name lists, \ie in the argument to \cmd{DeclareNameFormat}, the \prm{character} may also be an apostrophe.

\cmditem{ifprefchar}{true}{false}

如果前面的是一个由\cmd{DeclarePrefChars} 声明的前缀符，执行\prm{true}，否则执行\prm{false}。
%Executes \prm{true} if preceded by any prefix character declared by \cmd{DeclarePrefChars}.

\end{ltxsyntax}

\subsubsection{添加标点}%Adding Punctuation
\label{aut:pct:pct}
下面的命令设计用来防止重复标点。参考文献著录和标注样式总需要使用这些命令来代替原样输出的标点符号。本节中所有的\cmd{add...} 命令自动利用\cmd{unspace} 命令移除前面的空白(见\secref{aut:pct:spc})。注意:下面讨论的所有的\cmd{add...} 命令的作用是宏包默认的，无论\biblatex 换哪种语言都会重新恢复。其作用可以通过\cmd{DeclarePunctuationPairs} 命令进行调整，见\secref{aut:pct:cfg} 节。
%The following commands are designed to prevent double punctuation marks. Bibliography and citation styles should always use these commands instead of literal punctuation marks. All \cmd{add...} commands in this section automatically remove preceding whitespace with \cmd{unspace} (see \secref{aut:pct:spc}). Note that the behavior of all \cmd{add...} commands discussed below is the package default, which is restored whenever \biblatex switches languages. This behavior may be adjusted with \cmd{DeclarePunctuationPairs} from \secref{aut:pct:cfg}.

\begin{ltxsyntax}

\csitem{adddot}

除非前面输出的是任何一种标点符号，否则添加一个句点(period)。该命令的目的是在一个缩写后面插入点(dot)。以这种方式插入的点被认为与其它标点命令插入的标点性质相同。该命令也用来将前面插入的文本句点(原样输出的句点，literal period) 转换成一个缩写的点。
%Adds a period unless it is preceded by any punctuation mark. The purpose of this command is inserting the dot after an abbreviation. Any dot inserted this way is recognized as such by the other punctuation commands. This command may also be used to turn a previously inserted literal period into an abbreviation dot.

\csitem{addcomma}

除非前面输出的是一个逗号(comma)、分号(semicolon)、冒号(colon)和句点(period)，否则添加一个逗号。
%Adds a comma unless it is preceded by another comma, a semicolon, a colon, or a period.

\csitem{addsemicolon}

除非前面输出的是一个逗号，另一个分号，冒号和句号，否则添加一个分号。
%Adds a semicolon unless it is preceded by a comma, another semicolon, a colon, or a period.

\csitem{addcolon}

除非前面输出的是一个逗号，分号，另一个冒号，或句号，否则添加一个冒号。
%Adds a colon unless it is preceded by a comma, a semicolon, another colon, or a period.

\csitem{addperiod}

除非前面输出的是一个缩写点或其它任意标点符号，否则添加一个句号。该命令也可以用来将前面插入的缩写点转换为句号，比如在句子的末尾(译者:这种转换应该是经过某种判断的，比如在末尾就转换，不再末尾的话缩写点则不转换)。
%Adds a period unless it is preceded by an abbreviation dot or any other punctuation mark. This command may also be used to turn a previously inserted abbreviation dot into a period, for example at the end of a sentence.

\csitem{addexclam}
除非前面输出的是缩写点之外的任意标点，否则添加一个叹号。
%Adds an exclamation mark unless it is preceded by any punctuation mark except for an abbreviation dot.

\csitem{addquestion}

除非前面输出的是缩写点之外的任意标点，否则添加一个问号。
%Adds a question mark unless it is preceded by any punctuation mark except for an abbreviation dot.

\csitem{isdot}

将前面输出的是句号转换为缩写点。与\cmd{adddot} 相反，如果前面不是一个句号，则不添加任何符号。
%Turns a previously inserted literal period into an abbreviation dot. In contrast to \cmd{adddot}, nothing is inserted if this command is not preceded by a period.

\csitem{nopunct}

添加一个内部标记，将导致接下来的标点命令不打印任何标点。
%Adds an internal marker which will cause the next punctuation command to print nothing.

\end{ltxsyntax}

\subsubsection{添加空格}%Adding Whitespace
\label{aut:pct:spc}

下面的命令设计用来防止多余的空格。参考文献著录和标注样式总需要使用这些命令来代替原样输出的空格。与\secref{aut:pct:chk, aut:pct:pct} 节的命令不同，这些命令不仅限在标注和著录样式中使用，而是可以全局使用的。
%The following commands are designed to prevent spurious whitespace. Bibliography and citation styles should always use these commands instead of literal whitespace. In contrast to the commands in \secref{aut:pct:chk, aut:pct:pct}, they are not restricted to citations and the bibliography but available globally.

\begin{ltxsyntax}

\csitem{unspace}

移除前面的空格，即消除来自当前水平列末尾的所有间距(skip)和阀值。下面的所有命令都隐含执行该命令。
%Removes preceding whitespace, \ie removes all skips and penalties from the end of the current horizontal list. This command is implicitly executed by all of the following commands.

\csitem{addspace}

添加一个可断行的词内空格。
%Adds a breakable interword space.

\csitem{addnbspace}

添加一个不可断行(non-breakable)的词内空格。
%Adds a non"=breakable interword space.

\csitem{addthinspace}

添加一个\emph{可断行} 的短空格(thin space)。
%Adds a \emph{breakable} thin space.

\csitem{addnbthinspace}

添加一个\emph{不可断行} 的短空格(thin space)，类似于命令\cmd{,} 和\cmd{thinspace}。
%Adds a non"=breakable thin space. This is similar to \cmd{,} and \cmd{thinspace}.

\csitem{addlowpenspace}

添加一个由\cnt{lownamepenalty} 计数器值作为阀值控制的空格，详见\secref{use:fmt:len, aut:fmt:len}。
%Adds a space penalized by the value of the \cnt{lownamepenalty} counter, see \secref{use:fmt:len, aut:fmt:len} for details.

\csitem{addhighpenspace}

添加一个由\cnt{highnamepenalty} 计数器值作为阀值控制的空格，详见\secref{use:fmt:len, aut:fmt:len}。
%Adds a space penalized by the value of the \cnt{highnamepenalty} counter, see \secref{use:fmt:len, aut:fmt:len} for details.

\csitem{addlpthinspace}

类似于\cmd{addlowpenspace}，但添加的是可断行的短空格。
%Similar to \cmd{addlowpenspace} but adds a breakable thin space.

\csitem{addhpthinspace}

类似于\cmd{addhighpenspace}，但添加的是可断行的短空格。
%Similar to \cmd{addhighpenspace} but adds a breakable thin space.

\csitem{addabbrvspace}

添加一个由\cnt{abbrvpenalty} 计数器值作为阀值控制的空格，详见\secref{use:fmt:len, aut:fmt:len}。
%Adds a space penalized by the value of the \cnt{abbrvpenalty} counter, see \secref{use:fmt:len, aut:fmt:len} for details.

\csitem{addabthinspace}

类似于\cmd{addabbrvspace}，但添加一个短空格。
%Similar to \cmd{addabbrvspace} but using a thin space.

\csitem{adddotspace}

执行\cmd{adddot} 并且添加一个由\cnt{abbrvpenalty} 计数器值作为阀值控制的空格，详见\secref{use:fmt:len, aut:fmt:len}。
%Executes \cmd{adddot} and adds a space penalized by the value of the \cnt{abbrvpenalty} counter, see \secref{use:fmt:len, aut:fmt:len} for details.

\csitem{addslash}

添加一个可断行的斜杠，该命令与latex内核提供的\cmd{slash} 命令不同，因为\cmd{slash} 之后的断行完全没有阀值控制。
%Adds a breakable slash. This command differs from the \cmd{slash} command in the \latex kernel in that a linebreak after the slash is not penalized at all.

\end{ltxsyntax}

注意:本节的命令隐式地执行\cmd{unspace} 来去除多余的空格，因此它们可以互相覆盖。比如，可以使用\cmd{addnbspace} 将前面插入的词内空格转换为一个不可断行的空格，而\cmd{addspace} 可以将一个不可断行空格转换为可断行空格。\footnote{译者: 注意有的时候\cmd{unspace} 看似能够起到作用，但其实并不能随意使用的。在beamer中printtext老是有些问题，可能是实现printtext命令的依赖命令，在beamer中重定义了，跟aritcle文档类中的情况差别很大。}
%Note that the commands in this section implicitly execute \cmd{unspace} to remove spurious whitespace, hence they may be used to override each other. For example, you may use \cmd{addnbspace} to transform a previously inserted interword space into a non"=breakable one and \cmd{addspace} to turn a non"=breakable space into a breakable one.


\subsubsection{配置标点和大写}%Configuring Punctuation and Capitalization
\label{aut:pct:cfg}
下面的命令配置与标点和自动大写相关的各种功能。
%The following commands configure various features related to punctuation and automatic capitalization.


\begin{ltxsyntax}

\cmditem{DeclarePrefChars}{characters}
\cmditem*{DeclarePrefChars*}{characters}

该命令声明，测试是否将在姓名前缀和姓之间插入\cmd{bibnamedelimc} 时，需做特殊处理的字符。如果一个字符在\prm{characters} 中，那么\cmd{bibnamedelimc} 不会插入。它用于一些前缀特殊的缩写名中比如<d'Argent>，其中撇号之后没有空格，默认设置为:
%This command declares characters that are to be treated specially when testing to see if \cmd{bibnamedelimc} is to be inserted between a name prefix and a family name. If a character is in the list of \prm{characters}, \cmd{bibnamedelimc} is not inserted. It is used to allow abbreviated name prefices like <d'Argent> where no space should be inserted after the apostrophe. The starred version appends its argument to the list of prefix characters, the unstarred version replaces current setting. The default setting is:

\begin{ltxexample}
\DeclarePrefChars{'-}
\end{ltxexample}

For engines that fully support Unicode these defaults are extended with
\begin{ltxexample}[escapeinside={(*@}{@*)}]
\DeclarePrefChars*{(*@’@*)}
\end{ltxexample}
\cmditem{DeclareAutoPunctuation}{characters}

该命令定义当标注命令扫描标点时需要考虑的标点符号。注意，\prm{characters} 是一个不分隔字符列表。有效的\prm{characters} 包括句号、逗号、分号、冒号、叹号和问号。默认设置为:
%This command defines the punctuation marks to be considered by the citation commands as they scan ahead for punctuation. Note that \prm{characters} is an undelimited list of characters. Valid \prm{characters} are period, comma, semicolon, colon, exclamation and question mark. The default setting is:

\begin{ltxexample}
\DeclareAutoPunctuation{.,;:!?}
\end{ltxexample}
%
当\opt{autopunct} 包选项设置为\texttt{true} 时，该定义将自动恢复。执行|\DeclareAutoPunctuation{}|等价于设置\kvopt{autopunct}{false}，即它会关闭该功能。
%This definition is restored automatically whenever the \opt{autopunct} package option is set to \texttt{true}. Executing |\DeclareAutoPunctuation{}| is equivalent to setting \kvopt{autopunct}{false}, \ie it disables this feature.

\cmditem{DeclareCapitalPunctuation}{characters}

当\biblatex 插入本地化字符串时，即关键项如 <edition>或<volume>等，该命令将把终结标点后的字符自动大写。该命令定义的一些标点符号将导致一些本地化字符串大写，如果某个标点符号在一个字符串之前。注意\prm{characters} 是一个不分隔字符列表，有效的\prm{characters} 包括句号、逗号、分号、冒号、叹号和问号。默认设置为:
%When \biblatex inserts localisation strings, \ie key terms such as <edition> or <volume>, it automatically capitalizes them after terminal punctuation marks. This command defines the punctuation marks which will cause localisation strings to be capitalized if one of them precedes a string. Note that \prm{characters} is an undelimited list of characters. Valid \prm{characters} are period, comma, semicolon, colon, exclamation and question mark. The package default is:

\begin{ltxexample}
\DeclareCapitalPunctuation{.!?}
\end{ltxexample}
%
使用参数为空的\cmd{DeclareCapitalPunctuation} 命令等价于关闭自动大写功能。因为该功能与语言相关，所以该命令必须用在\cmd{DefineBibliographyExtras} 命令(当用在导言区时)或者\cmd{DeclareBibliographyExtras}(当用在本地化模型中)的参数中。详见\secref{use:lng, aut:lng}。默认情况下，在句号、叹号和问号后面的本地化字符串将大写。所有段落开头的字符串一般都需要大写(事实上无论\tex 是否在垂直模式中)。
%Using \cmd{DeclareCapitalPunctuation} with an empty argument is equivalent to disabling automatic capitalization. Since this feature is language specific, this command must be used in the argument to \cmd{DefineBibliographyExtras} (when used in the preamble) or \cmd{DeclareBibliographyExtras} (when used in a localisation module). See \secref{use:lng, aut:lng} for details. By default, strings are capitalized after periods, exclamation marks, and question marks. All strings are generally capitalized at the beginning of a paragraph (in fact whenever \tex is in vertical mode).

\cmditem{DeclarePunctuationPairs}{identifier}{characters}

使用该命令来声明有效的标点符号对。这将影响\secref{aut:pct:pct} 节讨论的标点命令。例如，\cmd{addcomma} 命令的解释是: 该命令添加一个逗号，除非前面的字符是另一个逗号，分号，冒号或句号。换句话说，在缩写点，叹号，问号之后加入逗号是允许的。这些标点有效对声明如下:
%Use this command to declare valid pairs of punctuation marks. This will affect the punctuation commands discussed in \secref{aut:pct:pct}. For example, the description of \cmd{addcomma} states that this command adds a comma unless it is preceded by another comma, a semicolon, a colon, or a period. In other words, commas after abbreviation dots, exclamation marks, and question marks are permitted. These valid pairs are declared as follows:

\begin{ltxexample}
\DeclarePunctuationPairs{comma}{*!?}
\end{ltxexample}
%
\prm{identifier} 选择需要配置的命令。标识对应于\secref{aut:pct:pct} 节标点命令的标点名称(即去除\cmd{add} 前缀后的命令名)，即有效的\prm{identifier} 字符串包括\texttt{dot}, \texttt{comma}, \texttt{semicolon}, \texttt{colon}, \texttt{period}, \texttt{exclam}, \texttt{question}。\prm{characters} 是标点符号的不分隔列表。有效的\prm{characters} 是逗号，分号，冒号，句号，叹号，问号和星号。\prm{characters} 中的句号代表一个句末点号，星号代表缩写后的点号。下面是默认的设置，当\biblatex 切换语言时总是自动回复默认设置，并且与\secref{aut:pct:pct} 描述的行为对应:
%The \prm{identifier} selects the command to be configured. The identifiers correspond to the names of the punctuation commands from \secref{aut:pct:pct} without the \cmd{add} prefix, \ie valid \prm{identifier} strings are \texttt{dot}, \texttt{comma}, \texttt{semicolon}, \texttt{colon}, \texttt{period}, \texttt{exclam}, \texttt{question}. The \prm{characters} argument is an undelimited list of punctuation marks. Valid \prm{characters} are comma, semicolon, colon, period, exclamation mark, question mark, and asterisk. A period in the \prm{characters} argument denotes an end-of"=sentence period, an asterisk the dot after an abbreviation. This is the default setup, which is automatically restored whenever \biblatex switches languages and corresponds to the behavior described in \secref{aut:pct:pct}:

\begin{ltxexample}
\DeclarePunctuationPairs{dot}{}
\DeclarePunctuationPairs{comma}{*!?}
\DeclarePunctuationPairs{semicolon}{*!?}
\DeclarePunctuationPairs{colon}{*!?}
\DeclarePunctuationPairs{period}{}
\DeclarePunctuationPairs{exclam}{*}
\DeclarePunctuationPairs{question}{*}
\end{ltxexample}
%
因为该功能与语言相关，\cmd{DeclarePunctuationPairs} 必须用在\cmd{DefineBibliographyExtras}(当在导言区使用)或\cmd{DeclareBibliographyExtras}(当在本地化模块中使用)的参数中。详见\secref{use:lng, aut:lng}。注意: 一些本地化模块可能使用不同于宏包默认的设置。\footnote{到本文档写作时，\texttt{american} 模块针对美语样式(<American-style>)标点使用不同的设置。}
%Since this feature is language specific, \cmd{DeclarePunctuationPairs} must be used in the argument to \cmd{DefineBibliographyExtras} (when used in the preamble) or \cmd{DeclareBibliographyExtras} (when used in a localisation module). See \secref{use:lng, aut:lng} for details. Note that some localisation modules may use a setup which is different from the package default.\footnote{As of this writing, the \texttt{american} module uses different settings for <American-style> punctuation.}

\cmditem{DeclareQuotePunctuation}{characters}

该命令控制<American-style>标点。\secref{aut:fmt:ich} 节的\cmd{mkbibquote} 封套可以与\secref{aut:pct:new, aut:pct:pct, aut:pct:spc} 节讨论的标点工具交互。\cmd{mkbibquote} 之后的标点将移动到引号内，如果它们已在\cmd{DeclareQuotePunctuation} 声明过。注意\prm{characters} 是一个字符的不分隔列表。有效的\prm{characters} 包括: 句号，逗号，分号，冒号，叹号和问号。下面是一个示例:
%This command controls <American-style> punctuation. The \cmd{mkbibquote} wrapper from \secref{aut:fmt:ich} can interact with the punctuation facilities discussed in \secref{aut:pct:new, aut:pct:pct, aut:pct:spc}. Punctuation marks after \cmd{mkbibquote} will be moved inside the quotes if they have been registered with \cmd{DeclareQuotePunctuation}. Note that \prm{characters} is an undelimited list of characters. Valid \prm{characters} are period, comma, semicolon, colon, exclamation and question mark. Here is an example:

\begin{ltxexample}
\DeclareQuotePunctuation{.,}
\end{ltxexample}
%
执行|\DeclareQuotePunctuation{}|等价于关闭该功能。这是包的默认情形。因为该功能与语言相关，该命令必须用在\cmd{DefineBibliographyExtras}(当在导言区使用)或\cmd{DeclareBibliographyExtras}(当在本地化模块中使用)的参数中。详见\secref{use:lng, aut:lng}。另可参见\secref{use:loc:us}。
%Executing |\DeclareQuotePunctuation{}| is equivalent to disabling this feature. This is the package default. Since this feature is language specific, this command must be used in the argument to \cmd{DefineBibliographyExtras} (when used in the preamble) or \cmd{DeclareBibliographyExtras} (when used in a localisation module). See \secref{use:lng, aut:lng} for details. See also \secref{use:loc:us}.

\csitem{uspunctuation}

使用底层命令\cmd{DeclareQuotePunctuation} 和\cmd{DeclarePunctuationPairs} 激活美语样式标点的缩略命令。详见\secref{use:loc:us}。提供该缩略命令是为了使用方便。有效的设置由底层命令应用。
%A shorthand using the lower-level commands \cmd{DeclareQuotePunctuation} and \cmd{DeclarePunctuationPairs} to activate <American-style> punctuation. See \secref{use:loc:us} for details. This shorthand is provided for convenience only. The effective settings are applied by the lower-level commands.

\csitem{stdpunctuation}

取消由\cmd{uspunctuation} 命令产生的设置，恢复到标准的标点样式。因为标准标点样式是默认设置，仅需要使用该命令来覆盖前面执行的\cmd{uspunctuation} 命令即可。详见\secref{use:loc:us}。
%Undoes the settings applied by \cmd{uspunctuation}, restoring standard punctuation. As standard punctuation is the default setting, you only need this command to override a previously executed \cmd{uspunctuation} command. See \secref{use:loc:us} for details.

\end{ltxsyntax}

\subsubsection{修正标点追踪}%Correcting Punctuation Tracking
\label{aut:pct:ctr}

在一般情况下标点追踪和自动大写的工具是很可靠的，但总是存在一些少量情况可能需要手动干预。典型的问题包括当本地化字符串作为脚注(就大写而言脚注常被认为是在一个段落的开始，但\tex 在此时并不处于垂直模式中)的第一个单词打印时，或者句号(不是真正的句末点号，例如在一个像«[\dots\unkern]»的省略号之后诸如\cmd{addperiod} 等命令将不会进行任何操作，因为圆括号和方括号对于标点追踪器来说是透明的)之后的标点。\footnote{译者:重点注意括号对于标点追踪器是透明的，这个问题在样式设计时经常会碰到。} 在这些情况中，如果有需要，可在著录和标注样式中使用如下命令来标记句子的开头或者中间位置:
%The facilities for punctuation tracking and automatic capitalization are very reliable under normal circumstances, but there are always marginal cases which may require manual intervention. Typical cases are localisation strings printed as the first word in a footnote (which is usually treated as the beginning of a paragraph as far as capitalization is concerned, but \tex is not in vertical mode at this point) or punctuation after periods which are not really end"=of"=sentence periods (for example, after an ellipsis like «[\dots\unkern]» a command such as \cmd{addperiod} would do nothing since parentheses and brackets are transparent to the punctuation tracker). In such cases, use the following commands in bibliography and citation styles to mark the beginning or middle of a sentence if and where required:

\begin{ltxsyntax}

\csitem{bibsentence}

该命令标记句子的开头。紧跟在其后面的一个本地化字符串将会大写并且标点追踪器也会重设，即该命令对标点追踪器隐藏前面所有的标点并且强制大写。
%This command marks the beginning of a sentence. A localisation string immediately after this command will be capitalized and the punctuation tracker is reset, \ie this command hides all preceding punctuation marks from the punctuation tracker and enforces capitalization.

\csitem{midsentence}

该命令标记句子的中间位置。紧跟在其后面的一个本地化字符串将不会大写并且标点追踪器也会重设，即该命令对标点追踪器隐藏前面所有的标点并且抑制大写。
%This command marks the middle of a sentence. A localisation string immediately after this command will not be capitalized and the punctuation tracker is reset, \ie this command hides all preceding punctuation marks from the punctuation tracker and suppresses capitalization.

\csitem*{midsentence*}

\cmd{midsentence} 命令的带星号版本，差别在于，对于该命令前面的缩写点不会隐藏，即\cmd{midsentence*} 之后的任何代码都能看见前面的缩写点。而所有其他标点将对标点追踪器隐藏，大写也将被抑制。
%The starred variant of \cmd{midsentence} differs from the regular one in that a preceding abbreviation dot is not hidden from the the punctuation tracker, \ie any code after \cmd{midsentence*} will see a preceding abbreviation dot. All other punctuation marks are hidden from the punctuation tracker and capitalization is suppressed.

\end{ltxsyntax}

\subsection{本地化字符串}%Localization Strings
\label{aut:str}

本地化字符串如<edition>或<volume>之类的关键词项将由\biblatex 本地化模块自动转换。本地化字符串概述见\secref{aut:lng}，所有默认支持的字符串列表见\secref{aut:lng:key} 节。本节的命令用于打印本地化的项。
%Localization strings are key terms such as <edition> or <volume> which are automatically translated by \biblatex's localisation modules. See \secref{aut:lng} for an overview and \secref{aut:lng:key} for a list of all strings supported by default. The commands in this section are used to print the localised term.

\begin{ltxsyntax}

\cmditem{bibstring}[wrapper]{key}

打印本地化字符串\prm{key}，其中\prm{key} 是一个以小写字母书写的标识(见\secref{aut:lng:key})。需要时字符串会大写，详见\secref{aut:pct:cfg} 节。根据\secref{use:opt:pre:gen} 节的\opt{abbreviate} 包选项，\cmd{bibstring} 打印短字符串或长字符串。如果本地化字符串处于嵌套中，即\cmd{bibstring} 用在另一个字符串中，它的作用类似于\cmd{bibxstring}。如果给出\prm{wrapper} 参数，字符串将传递给\prm{wrapper} 用于格式化。这常用于字体命令比如\cmd{emph} 等。
%Prints the localisation string \prm{key}, where \prm{key} is an identifier in lowercase letters (see \secref{aut:lng:key}). The string will be capitalized as required, see \secref{aut:pct:cfg} for details.
%Depending on the \opt{abbreviate} package option from \secref{use:opt:pre:gen}, \cmd{bibstring} prints the short or the long version of the string. If localisation strings are nested, \ie if \cmd{bibstring} is used in another string, it will behave like \cmd{bibxstring}.
%If the \prm{wrapper} argument is given, the string is passed to the \prm{wrapper} for formatting. This is intended for font commands such as \cmd{emph}.

\cmditem{biblstring}[wrapper]{key}

类似于\cmd{bibstring}，但总是打印长字符串，忽略\opt{abbreviate} 选项。
%Similar to \cmd{bibstring} but always prints the long string, ignoring the \opt{abbreviate} option.

\cmditem{bibsstring}[wrapper]{key}

类似于\cmd{bibstring}，但总是打印短字符串，忽略\opt{abbreviate} 选项。
%Similar to \cmd{bibstring} but always prints the short string, ignoring the \opt{abbreviate} option.

\cmditem{bibncpstring}[wrapper]{key}

Similar to \cmd{bibstring} but the term is never capitalized.

\cmditem{bibncplstring}[wrapper]{key}

Similar to \cmd{biblstring} but the term is never capitalized.

\cmditem{bibncpsstring}[wrapper]{key}

Similar to \cmd{bibsstring} but the term is never capitalized.
\cmditem{bibcpstring}[wrapper]{key}

类似于\cmd{bibstring}，但字符串总是首字母大写
%Similar to \cmd{bibstring} but the term is always capitalized.

\cmditem{bibcplstring}[wrapper]{key}

类似于\cmd{biblstring}，但字符串总是首字母大写
%Similar to \cmd{biblstring} but the term is always capitalized.

\cmditem{bibcpsstring}[wrapper]{key}

类似于\cmd{bibsstring}，但字符串总是首字母大写
%Similar to \cmd{bibsstring} but the term is always capitalized.

\cmditem{bibucstring}[wrapper]{key}

类似于\cmd{bibstring}，但字符串总是大写
%Similar to \cmd{bibstring} but the whole term is uppercased.

\cmditem{bibuclstring}[wrapper]{key}

类似于\cmd{biblstring}，但字符串总是大写
%Similar to \cmd{biblstring} but the whole term is uppercased.

\cmditem{bibucsstring}[wrapper]{key}

类似于\cmd{bibsstring}，但字符串总是大写
%Similar to \cmd{bibsstring} but the whole term is uppercased.

\cmditem{biblcstring}[wrapper]{key}

类似于\cmd{bibstring}，但字符串总是小写
%Similar to \cmd{bibstring} but the whole term is lowercased.

\cmditem{biblclstring}[wrapper]{key}

类似于\cmd{biblstring}，但字符串总是小写
%Similar to \cmd{biblstring} but the whole term is lowercased.

\cmditem{biblcsstring}[wrapper]{key}

类似于\cmd{bibsstring}，但字符串总是小写
%Similar to \cmd{bibsstring} but the whole term is lowercased.

\cmditem{bibxstring}{key}

\cmd{bibstring} 命令一个简化的但可展开的版本。注意，这一命令不自动首字母大写，也不与标点追踪器交互。用于当字符串嵌套或者一个判断中需要一个可展开的本地化字符串等特殊情况。
%A simplified but expandable version of \cmd{bibstring}. Note that this variant does not capitalize automatically, nor does it hook into the punctuation tracker. It is intended for special cases in which strings are nested or an expanded localisation string is required in a test.

\cmditem{bibxlstring}[wrapper]{key}

类似于\cmd{bibxstring}，但总是打印长字符串，忽略\opt{abbreviate} 选项。
%Similar to \cmd{bibxstring} but always uses the long string, ignoring the \opt{abbreviate} option.

\cmditem{bibxsstring}[wrapper]{key}

类似于\cmd{bibxstring}，但总是打印短字符串，忽略\opt{abbreviate} 选项。
%Similar to \cmd{bibxstring} but always uses the short string, ignoring the \opt{abbreviate} option.

\cmditem{mainlang}

从当前语言转换到主文档语言。可以用在上述本地化字符串命令的\prm{wrapper} 参数中。
%Switches from the current language to the main document language. This can be used the \prm{wrapper} argument in the localisation string commands above.
Switches from the current language to the main document language. This command is deprecated. Use the text-macro \cmd{textmainlang} instead. With \sty{babel} this command will need to be wrapped into \emph{two} groups to have purely local effect.

\cmditem{textmainlang}{text}

Locally switches from the current language to the main document language to typeset \prm{text}. This can be used the \prm{wrapper} argument in the localisation string commands above.

\end{ltxsyntax}

\subsection{本地化模块}%Localization Modules
\label{aut:lng}

本地化模块提供了诸如<edition>或<volume>等关键项，或者一些具体语言相关功能定义比如日期格式和序数等的转换(翻译)。这些定义在后缀为\file{lbx} 的文件中给出。文件的基本名称必须是\sty{babel}/\sty{polyglossia} 包已定义的语言名称。\file{lbx} 文件也用于将\sty{babel}/\sty{polyglossia} 语言名映射为\biblatex 包的后端模块。所有的本地化模型根据需要在正文中加载。注意文件的内容在一个编组内处理，\texttt{@} 字符的类别码临时设置为<letter>。
%A localisation module provides translations for key terms such as <edition> or <volume> as well as definitions for language specific features such as the date format and ordinals. These definitions are provided in files with the suffix \file{lbx}. The base name of the file must be a language name known to the \sty{babel}/\sty{polyglossia} packages. The \file{lbx} files may also be used to map \sty{babel}/\sty{polyglossia} language names to the backend modules of the \biblatex package. All localisation modules are loaded on demand in the document body. Note that the contents of the file are processed in a group and that the category code of the character \texttt{@} is temporarily set to <letter>.

\subsubsection{本地化命令}%Localization Commands
\label{aut:lng:cmd}

用户层(user-level)的本地化命令已经在\secref{use:lng} 节介绍过了。然而，用在\file{lbx} 文件中的本地化命令的语法与用在导言区和配置文件中的语法略有不同。当在本地化文件中使用，不需要指定\prm{language}，因为字符串要映射的语言已经由\file{lbx} 文件名给出。
%The user"=level versions of the localisation commands were already introduced in \secref{use:lng}. When used in \file{lbx} files, however, the syntax of localisation commands is different from the user syntax in the preamble and the configuration file. When used in localisation files, there is no need to specify the \prm{language} because the mapping of strings to a language is already provided by the name of the \file{lbx} file.

\begin{ltxsyntax}

\cmditem{DeclareBibliographyStrings}{definitions}

该命令仅在\file{lbx} 文件中提供。用于定义本地化字符串。\prm{definitions} 由\keyval 对构成，用于给一个标识赋予一个表达式。默认支持的完整关键词(键)列表在\secref{aut:lng:key} 节给出。注意:\file{lbx} 文件中值的语法是不同的。\footnote{译者: 重点注意定义本地化字符串的语法在lbx文件和样式文件中是不同的，这在设计样式文件是会碰到。} 赋予的键值由两个短语构成，每个部分都包含在一个括号中。下面是一个示例:
%This command is only available in \file{lbx} files. It is used to define localisation strings. The \prm{definitions} consist of \keyval pairs which assign an expression to an identifier. A complete list of all keys supported by default is given is \secref{aut:lng:key}. Note that the syntax of the value is different in \file{lbx} files. The value assigned to a key consists of two expressions, each of which is wrapped in an additional pair of brackets. This is best shown by example:

\begin{ltxexample}
\DeclareBibliographyStrings{%
  bibliography  = {{Bibliography}{Bibliography}},
  shorthands    = {{List of Abbreviations}{Abbreviations}},
  editor        = {{editor}{ed.}},
  editors       = {{editors}{eds.}},
}
\end{ltxexample}
%
第一个值是用于写出的长短语，第二个是缩写或简易形式。两个字符串都必须给出即便它们是相同的，比如当一个短语总是要(或不要)缩写时。根据\opt{abbreviate} 包选项设置(见\secref{use:opt:pre:gen})，当加载\opt{abbreviate} 时\biblatex 选择一个短语。也存在一个名为\texttt{inherit} 特殊键，从另一种语言中拷贝字符串。这用于仅有部分短语不同的语言间，比如德国和奥地利，或者美国和英国英语。例如，下面给出的奥地利语完整定义:
%The first value is the long, written out expression, the second one is an abbreviated or short form. Both strings must always be given even though they may be identical if an expression is always (or never) abbreviated. Depending on the setting of the \opt{abbreviate} package option (see \secref{use:opt:pre:gen}), \biblatex selects one expression when loading the \file{lbx} file. There is also a special key named \texttt{inherit} which copies the strings from a different language. This is intended for languages which only differ in a few expressions, such as German and Austrian or American and British English. For example, here are the complete definitions for Austrian:

\begin{ltxexample}
\DeclareBibliographyStrings{%
  inherit       = {german},
  january       = {{J\"anner}{J\"an.}},
}
\end{ltxexample}

这里示例略微简化了。真实的本地化文件应该使用\secref{aut:pct:pct, use:fmt} 节讨论的标点和格式化命令而不是文本标点(literal punctuation)\footnote{译者: 在样式文件中使用文本标点时可能会遇到一些不可预料的问题，应尽可能的使用biblatex提供的标点命令}。下面的内容摘录自一个真实的本地化文件:
%The above examples are slightly simplified. Real localisation files should use the punctuation and formatting commands discussed in \secref{aut:pct:pct, use:fmt} instead of literal punctuation. Here is an excerpt from a real localisation file:

\begin{ltxexample}
  bibliography     = {{Bibliography}{Bibliography}},
  shorthands       = {{List of Abbreviations}{Abbreviations}},
  editor           = {{editor}{ed\adddot}},
  editors          = {{editors}{eds\adddot}},
  byeditor         = {{edited by}{ed\adddotspace by}},
  mathesis         = {{Master's thesis}{MA\addabbrvspace thesis}},
\end{ltxexample}
%
注意上例中缩略点的处理，缩略短语中的空格以及首字母大写等。所有的短语在一个句子中使用时，都是首字母大写的。\biblatex 包将自动将句首的第一个单词的首字母大写，详见\secref{aut:pct:cfg} 节的\cmd{DeclareCapitalPunctuation}。用作标题的短语是特殊的。它们常使用一种适合标题的方式并且不应使用缩略形式(但它们可能具有简易形式)。
%Note the handling of abbreviation dots, the spacing in abbreviated expressions, and the capitalization in the example above. All expressions should be capitalized as they usually are when used in the middle of a sentence. The \biblatex package will automatically capitalize the first word when required at the beginning of a sentence, see \cmd{DeclareCapitalPunctuation} in \secref{aut:pct:cfg} for details. Expressions intended for use in headings are special. They should be capitalized in a way that is suitable for titling and should not be abbreviated (but they may have a short form).

\cmditem{InheritBibliographyStrings}{language}

该命令仅在\file{lbx} 文件中提供。它将\prm{language} 语言的本地化字符串复制到\file{lbx} 文件名指出的当前语言中。
%This command is only available in \file{lbx} files. It copies the localisation strings for \prm{language} to the current language, as specified by the name of the \file{lbx} file.

\cmditem{DeclareBibliographyExtras}{code}

该命令仅在\file{lbx} 文件中提供。用于调整语言相关的功能比如日期格式和序号。任意的\latex 代码\prm{code}，常由\secref{aut:fmt:lng} 节的格式化命令的重定义构成。
%This command is only available in \file{lbx} files. It is used to adapt language specific features such as the date format and ordinals. The \prm{code}, which may be arbitrary \latex code, will usually consist of redefinitions of the formatting commands from \secref{aut:fmt:lng}.

\cmditem{UndeclareBibliographyExtras}{code}

该命令仅在\file{lbx} 文件中提供。用于恢复由\cmd{DeclareBibliographyExtras} 命令修改的格式化命令。如果一个重定义命令包含在\secref{aut:fmt:lng} 中，则没有必要恢复前一定义，因为这些命令总是会根据所有语言模块进行本地化。
%This command is only available in \file{lbx} files. It is used to restore any formatting commands modified with \cmd{DeclareBibliographyExtras}. If a redefined command is included in \secref{aut:fmt:lng}, there is no need to restore its previous definition since these commands are localised by all language modules anyway.

\cmditem{InheritBibliographyExtras}{language}

该命令仅在\file{lbx} 文件中提供。它将\prm{language} 语言的参考文献附加规则复制到\file{lbx} 文件名指出的当前语言中。
%This command is only available in \file{lbx} files. It copies the bibliography extras for \prm{language} to the current language, as specified by the name of the \file{lbx} file.

\cmditem{DeclareHyphenationExceptions}{text}

该命令对应于\secref{use:lng} 节的\cmd{DefineHyphenationExceptions}。差别在于它仅在\file{lbx} 文件中提供，并且没有\prm{language} 参数。连字符例外规则将影响正在处理的\file{lbx} 文件的语言。
%This command corresponds to \cmd{DefineHyphenationExceptions} from \secref{use:lng}. The difference is that it is only available in \file{lbx} files and that the \prm{language} argument is omitted. The hyphenation exceptions will affect the language of the \file{lbx} file currently being processed.

\cmditem{DeclareRedundantLanguages}{language, language, ...}{langid, langid, ...}

该命令提供了\secref{use:opt:pre:gen} 节\opt{clearlang} 语言选项要求的语言映射。\prm{language} 是\bibfield{language} 域给出的字符串(不需要可选的\texttt{lang} 前缀)，\prm{langid} 是\sty{babel}/\sty{polyglossia} 的语言标识，在加载\sty{babel} 包的\cmd{usepackage} 命令可选参数或者使用\sty{polyglossia} 包的\cmd{setdefaultlanguage} 或\cmd{setotherlanguages} 命令中给出。这一命令可以用于\file{lbx} 文件中或者文档导言区中。下面是一些示例:
%This command provides the language mappings required by the \opt{clearlang} option from \secref{use:opt:pre:gen}.
%The \prm{language} is the string given in the \bibfield{language} field (without the optional \texttt{lang} prefix); \prm{langid} is \sty{babel}/\sty{polyglossia}'s language identifier, as given in the optional argument of \cmd{usepackage} when loading \sty{babel} or the argument of \cmd{setdefaultlanguage} or \cmd{setotherlanguages} when using \sty{polyglossia}. This command may be used in \file{lbx} files or in the document preamble. Here are some examples:

\begin{ltxexample}
\DeclareRedundantLanguages{french}{french}
\DeclareRedundantLanguages{german}{german,ngerman,austrian,naustrian,
        nswissgerman,swissgerman}
\DeclareRedundantLanguages{english,american}{english,american,british,
	canadian,australian,newzealand,USenglish,UKenglish}
\end{ltxexample}
%
注意这一功能需要全局地启用\secref{use:opt:pre:gen} 节的\opt{clearlang} 选项。如果关闭该选项，所有的映射将被忽略。如果\prm{langid} 参数为空，\biblatex 将清除相应语言的映射，即仅关闭该\prm{language} 的功能。
%Note that this feature needs to be enabled globally with the \opt{clearlang} option from \secref{use:opt:pre:gen}. If it is disabled, all mappings will be ignored. If the \prm{langid} parameter is blank, \biblatex will clear the mappings for the corresponding \prm{language}, \ie the feature will be disabled for this \prm{language} only.

\cmditem{DeclareLanguageMapping}{language}{file}

该命令将\sty{babel}/\sty{polyglossia} 语言标识映射到一个 \file{lbx} 文件中。\prm{language} 必须是一个\sty{babel}/\sty{polyglossia} 已经定义的语言，即表\ref{bib:fld:tab1} 中列出的标识之一。\prm{file} 参数是选择的\file{lbx} 文件的出\texttt{.lbx} 后缀外的文件名。可以多次声明相同的映射。后面的声明将覆盖前面的声明。该命令只能用在导言中。详见\secref{aut:cav:lng}。
%This command maps a \sty{babel}/\sty{polyglossia} language identifier to an \file{lbx} file. The \prm{language} must be a language name known to the \sty{babel}/\sty{polyglossia} package, \ie one of the identifiers listed in \tabref{bib:fld:tab1}. The \prm{file} argument is the name of an alternative \file{lbx} file without the \texttt{.lbx} suffix. Declaring the same mapping more than once is possible. Subsequent declarations will simply overwrite any previous ones. This command may only be used in the preamble. See \secref{aut:cav:lng} for further details.

\cmditem{DeclareLanguageMappingSuffix}{suffix}

%This command defines a language file suffix which will be added when looking for \file{.lbx} language string definition files. This is intended for styles which provide their own \file{.lbx} files so that they will be used automatically. For example, the APA style defines:
该命令定义了语言文件的后缀，将在搜索\file{.lbx}语言字符串定义文件时加入。用于一些样式提供了自身的\file{.lbx}文件的情况，使其可以自动加载使用，
例如APA样式定义了:

\begin{ltxexample}
\DeclareLanguageMappingSuffix{-apa}
\end{ltxexample}
%
%When the document language is <german>, \biblatex will look for the file \file{german-apa.lbx} which defines some APA specific strings and in turn loads \file{german.lbx}. If \cmd{DeclareLanguageMapping} is defined for a language, this overrides \cmd{DeclareLanguageMappingSuffix}.

当文档语言是<german>，\biblatex 会搜索 \file{german-apa.lbx}文件，该文件定义了一些特殊的字符串，然后再加载\file{german.lbx}。
如果\cmd{DeclareLanguageMapping}是未某种语言定义的，那么将会覆盖\cmd{DeclareLanguageMappingSuffix}的定义。


%The suffix will be applied to other language files loaded recursively by the loading of a language file. For example, given the suffix defined above, when loading <ngerman>, \biblatex will look for the file \file{ngerman-apa.lbx} and if this recursively loads <german>, then biblatex will look for \file{german-apa.lbx}. Infinite recursion is of course avoided.
后缀将会应用到语言文件中调用的其它语言文件中。对于上面的例子，当加载<ngerman>，也会搜索\file{ngerman-apa.lbx} ，
如果该文件还调用了<german>，那么biblatex还会搜索\file{german-apa.lbx}，当然会避免无限循环的情况。


\cmditem{NewBibliographyString}{key}

该命令可以用在导言区(包括\file{cbx} 和\file{bbx} 文件)或者\file{lbx} 文件中，用于声明新的本地化字符串，即它初始化一个关键词(键)可以用于 \cmd{DefineBibliographyStrings} 或 \cmd{DeclareBibliographyStrings} 命令的 \prm{definitions} 中。\prm{key} 选项可以是一个逗号分隔的列表。当在\file{lbx} 中使用时，\prm{key} 只完成\file{lbx} 文件名指定的语言的初始化。默认的键在\secref{aut:lng:key} 节列出。
%This command, which may be used in the preamble (including \file{cbx} and \file{bbx} files) as well as in \file{lbx} files, declares new localisation strings, \ie it initializes a new \prm{key} to be used in the \prm{definitions} of \cmd{DefineBibliographyStrings} or \cmd{DeclareBibliographyStrings}. The \prm{key} argument may also be a comma"=separated list of key names. When used in an \file{lbx}, the \prm{key} is initialized only for the language specified by the name of the \file{lbx} file. The keys listed in \secref{aut:lng:key} are defined by default.

\end{ltxsyntax}

\subsubsection{本地化关键词(键)}%Localization Keys
\label{aut:lng:key}

本节中的本地化关键词是默认定义的，由\biblatex 附带的本地化文件提供。注意这些字符串仅在标注、著录表和文献列表中使用。所有的短语当在句中使用时常需要首字母大写。而\biblatex 会自动将句首的字符串首字母大写。唯一的例外规则是三个用于标题中的字符串。
%The localisation keys in this section are defined by default and covered by the localisation files which come with \biblatex. Note that these strings are only available in citations, the bibliography and bibliography lists. All expressions should be capitalized as they usually are when used in the middle of a sentence. \biblatex will capitalize them automatically at the beginning of a sentence. The only exceptions to these rules are the three strings intended for use in headings.

\paragraph{标题}%Headings
\label{aut:lng:key:bhd}

下面的字符串比较特殊是因为他们用在标题中，并通过宏可以全局使用。因此，通常他们在标题中使用时需要首字母大写，并且不能包含任何作为\biblatex 作者接口的本地命令。
%The following strings are special because they are intended for use in headings and made available globally via macros. For this reason, they should be capitalized for use in headings and they must not include any local commands which are part of \biblatex's author interface.

\begin{keymarglist}
\item[bibliography] 词(术语)<bibliography>，也作\cmd{bibname} 使用。
%The term <bibliography>, also available as \cmd{bibname}.
\item[references] 词<references>，也作\cmd{refname} 使用。
%The term <references>, also available as \cmd{refname}.
\item[shorthands] 词<list of shorthands>或<list of abbreviations>，也作\cmd{biblistname} 使用。
%The term <list of shorthands> or <list of abbreviations>, also available as \cmd{biblistname}.
\end{keymarglist}

\paragraph{角色，解释为职业}%Roles, Expressed as Functions
\label{aut:lng:key:efn}

下面的关键词指出的角色，可以解释为职业(<editor>, <translator>)而不是行动(<edited by>, <translated by>)。
%The following keys refer to roles which are expressed as a function (<editor>, <translator>) rather than as an action (<edited by>, <translated by>).

\begin{keymarglist}
\item[editor] The term <editor>, referring to the main editor. This is the most generic editorial role.
\item[editors] The plural form of \texttt{editor}.
\item[compiler] The term <compiler>, referring to an editor whose task is to compile a work.
\item[compilers] The plural form of \texttt{compiler}.
\item[founder] The term <founder>, referring to a founding editor.
\item[founders] The plural form of \texttt{founder}.
\item[continuator] An expression like <continuator>, <continuation>, or <continued>, referring to a past editor who continued the work of the founding editor but was subsequently replaced by the current editor.
\item[continuators] The plural form of \texttt{continuator}.
\item[redactor] The term <redactor>, referring to a secondary editor.
\item[redactors] The plural form of \texttt{redactor}.
\item[reviser] The term <reviser>, referring to a secondary editor.
\item[revisers] The plural form of \texttt{reviser}.
\item[collaborator] A term like <collaborator>, <collaboration>, <cooperator>, or <cooperation>, referring to a secondary editor.
\item[collaborators] The plural form of \texttt{collaborator}.
\item[translator] The term <translator>.
\item[translators] The plural form of \texttt{translator}.
\item[commentator] The term <commentator>, referring to the author of a commentary to a work.
\item[commentators] The plural form of \texttt{commentators}.
\item[annotator] The term <annotator>, referring to the author of annotations to a work.
\item[annotators] The plural form of \texttt{annotators}.
\item[organizer] The term <organizer>, referring to the organizer of an
  event or work.
\item[organizers] The plural form of \texttt{organizer}.
\end{keymarglist}

\paragraph{合并的编辑角色，解释为职业}%Concatenated Editor Roles, Expressed as Functions
\label{aut:lng:key:cef}

下面的这些关键词类似于\texttt{editor}, \texttt{translator} 等的作用。它们常用来说明编辑的附加角色，比如<editor and translator>, <editor and foreword>。
%The following keys are similar in function to \texttt{editor}, \texttt{translator}, etc. They are used to indicate additional roles of the editor, \eg\ <editor and translator>, <editor and foreword>.

\begin{keymarglist}
\item[editortr] Used if \bibfield{editor}\slash \bibfield{translator} are identical.
\item[editorstr] The plural form of \texttt{editortr}.
\item[editorco] Used if \bibfield{editor}\slash \bibfield{commentator} are identical.
\item[editorsco] The plural form of \texttt{editorco}.
\item[editoran] Used if \bibfield{editor}\slash \bibfield{annotator} are identical.
\item[editorsan] The plural form of \texttt{editoran}.
\item[editorin] Used if \bibfield{editor}\slash \bibfield{introduction} are identical.
\item[editorsin] The plural form of \texttt{editorin}.
\item[editorfo] Used if \bibfield{editor}\slash \bibfield{foreword} are identical.
\item[editorsfo] The plural form of \texttt{editorfo}.
\item[editoraf] Used if \bibfield{editor}\slash \bibfield{aftword} are identical.
\item[editorsaf] The plural form of \texttt{editoraf}.
\end{keymarglist}
%
Keys for \bibfield{editor}\slash \bibfield{translator}\slash \prm{role} combinations:

\begin{keymarglist}
\item[editortrco] Used if \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{commentator} are identical.
\item[editorstrco] The plural form of \texttt{editortrco}.
\item[editortran] Used if \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{annotator} are identical.
\item[editorstran] The plural form of \texttt{editortran}.
\item[editortrin] Used if \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{introduction} are identical.
\item[editorstrin] The plural form of \texttt{editortrin}.
\item[editortrfo] Used if \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{foreword} are identical.
\item[editorstrfo] The plural form of \texttt{editortrfo}.
\item[editortraf] Used if \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{aftword} are identical.
\item[editorstraf] The plural form of \texttt{editortraf}.
\end{keymarglist}
%
Keys for \bibfield{editor}\slash \bibfield{commentator}\slash \prm{role} combinations:

\begin{keymarglist}
\item[editorcoin] Used if \bibfield{editor}\slash \bibfield{commentator}\slash \bibfield{introduction} are identical.
\item[editorscoin] The plural form of \texttt{editorcoin}.
\item[editorcofo] Used if \bibfield{editor}\slash \bibfield{commentator}\slash \bibfield{foreword} are identical.
\item[editorscofo] The plural form of \texttt{editorcofo}.
\item[editorcoaf] Used if \bibfield{editor}\slash \bibfield{commentator}\slash \bibfield{aftword} are identical.
\item[editorscoaf] The plural form of \texttt{editorcoaf}.
\end{keymarglist}
%
Keys for \bibfield{editor}\slash \bibfield{annotator}\slash \prm{role} combinations:

\begin{keymarglist}
\item[editoranin] Used if \bibfield{editor}\slash \bibfield{annotator}\slash \bibfield{introduction} are identical.
\item[editorsanin] The plural form of \texttt{editoranin}.
\item[editoranfo] Used if \bibfield{editor}\slash \bibfield{annotator}\slash \bibfield{foreword} are identical.
\item[editorsanfo] The plural form of \texttt{editoranfo}.
\item[editoranaf] Used if \bibfield{editor}\slash \bibfield{annotator}\slash \bibfield{aftword} are identical.
\item[editorsanaf] The plural form of \texttt{editoranaf}.
\end{keymarglist}
%
Keys for \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{commentator}\slash \prm{role} combinations:

\begin{keymarglist}
\item[editortrcoin] Used if \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{commentator}\slash \bibfield{introduction} are identical.
\item[editorstrcoin] The plural form of \texttt{editortrcoin}.
\item[editortrcofo] Used if \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{commentator}\slash \bibfield{foreword} are identical.
\item[editorstrcofo] The plural form of \texttt{editortrcofo}.
\item[editortrcoaf] Used if \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{commentator}\slash \bibfield{aftword} are identical.
\item[editorstrcoaf] The plural form of \texttt{editortrcoaf}.
\end{keymarglist}
%
Keys for \bibfield{editor}\slash \bibfield{annotator}\slash \bibfield{commentator}\slash \prm{role} combinations:

\begin{keymarglist}
\item[editortranin] Used if \bibfield{editor}\slash \bibfield{annotator}\slash \bibfield{commentator}\slash \bibfield{introduction} are identical.
\item[editorstranin] The plural form of \texttt{editortranin}.
\item[editortranfo] Used if \bibfield{editor}\slash \bibfield{annotator}\slash \bibfield{commentator}\slash \bibfield{foreword} are identical.
\item[editorstranfo] The plural form of \texttt{editortranfo}.
\item[editortranaf] Used if \bibfield{editor}\slash \bibfield{annotator}\slash \bibfield{commentator}\slash \bibfield{aftword} are identical.
\item[editorstranaf] The plural form of \texttt{editortranaf}.
\end{keymarglist}

\paragraph{合并的译者角色，解释为职业}%Concatenated Translator Roles, Expressed as Functions
\label{aut:lng:key:ctf}

下面的这些关键词类似于\texttt{translator} 的作用。它们常用来说明编辑的附加角色，比如<translator and commentator>, <translator and introduction>。
%The following keys are similar in function to \texttt{translator}. They are used to indicate additional roles of the translator, \eg\ <translator and commentator>, <translator and introduction>.

\begin{keymarglist}
\item[translatorco] Used if \bibfield{translator}\slash \bibfield{commentator} are identical.
\item[translatorsco] The plural form of \texttt{translatorco}.
\item[translatoran] Used if \bibfield{translator}\slash \bibfield{annotator} are identical.
\item[translatorsan] The plural form of \texttt{translatoran}.
\item[translatorin] Used if \bibfield{translator}\slash \bibfield{introduction} are identical.
\item[translatorsin] The plural form of \texttt{translatorin}.
\item[translatorfo] Used if \bibfield{translator}\slash \bibfield{foreword} are identical.
\item[translatorsfo] The plural form of \texttt{translatorfo}.
\item[translatoraf] Used if \bibfield{translator}\slash \bibfield{aftword} are identical.
\item[translatorsaf] The plural form of \texttt{translatoraf}.
\end{keymarglist}
%
Keys for \bibfield{translator}\slash \bibfield{commentator}\slash \prm{role} combinations:

\begin{keymarglist}
\item[translatorcoin] Used if \bibfield{translator}\slash \bibfield{commentator}\slash \bibfield{introduction} are identical.
\item[translatorscoin] The plural form of \texttt{translatorcoin}.
\item[translatorcofo] Used if \bibfield{translator}\slash \bibfield{commentator}\slash \bibfield{foreword} are identical.
\item[translatorscofo] The plural form of \texttt{translatorcofo}.
\item[translatorcoaf] Used if \bibfield{translator}\slash \bibfield{commentator}\slash \bibfield{aftword} are identical.
\item[translatorscoaf] The plural form of \texttt{translatorcoaf}.
\end{keymarglist}
%
Keys for \bibfield{translator}\slash \bibfield{annotator}\slash \prm{role} combinations:

\begin{keymarglist}
\item[translatoranin] Used if \bibfield{translator}\slash \bibfield{annotator}\slash \bibfield{introduction} are identical.
\item[translatorsanin] The plural form of \texttt{translatoranin}.
\item[translatoranfo] Used if \bibfield{translator}\slash \bibfield{annotator}\slash \bibfield{foreword} are identical.
\item[translatorsanfo] The plural form of \texttt{translatoranfo}.
\item[translatoranaf] Used if \bibfield{translator}\slash \bibfield{annotator}\slash \bibfield{aftword} are identical.
\item[translatorsanaf] The plural form of \texttt{translatoranaf}.
\end{keymarglist}

\paragraph{角色，解释为行为}%Roles, Expressed as Actions
\label{aut:lng:key:eac}
下面的关键词指的角色解释为行为(<edited by>, <translated by>)而不是职业(<editor>, <translator>)。
%The following keys refer to roles which are expressed as an action (<edited by>, <translated by>) rather than as a function (<editor>, <translator>).

\begin{keymarglist}
\item[byauthor] The expression <[created] by \prm{name}>.
\item[byeditor] The expression <edited by \prm{name}>.
\item[bycompiler] The expression <compiled by \prm{name}>.
\item[byfounder] The expression <founded by \prm{name}>.
\item[bycontinuator] The expression <continued by \prm{name}>.
\item[byredactor] The expression <redacted by \prm{name}>.
\item[byreviser] The expression <revised by \prm{name}>.
\item[byreviewer] The expression <reviewed by \prm{name}>.
\item[bycollaborator] An expression like <in collaboration with \prm{name}> or <in cooperation with \prm{name}>.
\item[bytranslator] The expression <translated by \prm{name}> or <translated from \prm{language} by \prm{name}>.
\item[bycommentator] The expression <commented by \prm{name}>.
\item[byannotator] The expression <annotated by \prm{name}>.
\item[byorganizer] The expression <[organized] by \prm{name}>.
\end{keymarglist}

\paragraph{合并的编者角色，解释为行为}%Concatenated Editor Roles, Expressed as Actions
\label{aut:lng:key:cea}

下面的这些关键词类似于\texttt{byeditor}, \texttt{bytranslator} 等的作用。它们常用来说明编辑的附加角色，比如<edited and translated by>, <edited and furnished with an introduction by>, <edited, with a foreword, by>。
%The following keys are similar in function to \texttt{byeditor}, \texttt{bytranslator}, etc. They are used to indicate additional roles of the editor, \eg\ <edited and translated by>, <edited and furnished with an introduction by>, <edited, with a foreword, by>.

\begin{keymarglist}
\item[byeditortr] Used if \bibfield{editor}\slash \bibfield{translator} are identical.
\item[byeditorco] Used if \bibfield{editor}\slash \bibfield{commentator} are identical.
\item[byeditoran] Used if \bibfield{editor}\slash \bibfield{annotator} are identical.
\item[byeditorin] Used if \bibfield{editor}\slash \bibfield{introduction} are identical.
\item[byeditorfo] Used if \bibfield{editor}\slash \bibfield{foreword} are identical.
\item[byeditoraf] Used if \bibfield{editor}\slash \bibfield{aftword} are identical.
\end{keymarglist}
%
Keys for \bibfield{editor}\slash \bibfield{translator}\slash \prm{role} combinations:

\begin{keymarglist}
\item[byeditortrco] Used if \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{commentator} are identical.
\item[byeditortran] Used if \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{annotator} are identical.
\item[byeditortrin] Used if \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{introduction} are identical.
\item[byeditortrfo] Used if \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{foreword} are identical.
\item[byeditortraf] Used if \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{aftword} are identical.
\end{keymarglist}
%
Keys for \bibfield{editor}\slash \bibfield{commentator}\slash \prm{role} combinations:

\begin{keymarglist}
\item[byeditorcoin] Used if \bibfield{editor}\slash \bibfield{commentator}\slash \bibfield{introduction} are identical.
\item[byeditorcofo] Used if \bibfield{editor}\slash \bibfield{commentator}\slash \bibfield{foreword} are identical.
\item[byeditorcoaf] Used if \bibfield{editor}\slash \bibfield{commentator}\slash \bibfield{aftword} are identical.
\end{keymarglist}
%
Keys for \bibfield{editor}\slash \bibfield{annotator}\slash \prm{role} combinations:

\begin{keymarglist}
\item[byeditoranin] Used if \bibfield{editor}\slash \bibfield{annotator}\slash \bibfield{introduction} are identical.
\item[byeditoranfo] Used if \bibfield{editor}\slash \bibfield{annotator}\slash \bibfield{foreword} are identical.
\item[byeditoranaf] Used if \bibfield{editor}\slash \bibfield{annotator}\slash \bibfield{aftword} are identical.
\end{keymarglist}
%
Keys for \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{commentator}\slash \prm{role} combinations:

\begin{keymarglist}
\item[byeditortrcoin] Used if \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{commentator}\slash \bibfield{introduction} are identical.
\item[byeditortrcofo] Used if \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{commentator}\slash \bibfield{foreword} are identical.
\item[byeditortrcoaf] Used if \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{commentator}\slash \bibfield{aftword} are identical.
\end{keymarglist}
%
Keys for \bibfield{editor}\slash \bibfield{translator}\slash \bibfield{annotator}\slash \prm{role} combinations:

\begin{keymarglist}
\item[byeditortranin] Used if \bibfield{editor}\slash \bibfield{annotator}\slash \bibfield{commentator}\slash \bibfield{introduction} are identical.
\item[byeditortranfo] Used if \bibfield{editor}\slash \bibfield{annotator}\slash \bibfield{commentator}\slash \bibfield{foreword} are identical.
\item[byeditortranaf] Used if \bibfield{editor}\slash \bibfield{annotator}\slash \bibfield{commentator}\slash \bibfield{aftword} are identical.
\end{keymarglist}

\paragraph{合并的译者角色，解释为行为}%Concatenated Translator Roles, Expressed as Actions
\label{aut:lng:key:cta}

下面的这些关键词类似于\texttt{bytranslator} 的作用。它们常用来说明译者的附加角色，比如<translated and commented by>, <translated and furnished with an introduction by>, <translated, with a foreword, by>。

%The following keys are similar in function to \texttt{bytranslator}. They are used to indicate additional roles of the translator, \eg\ <translated and commented by>, <translated and furnished with an introduction by>, <translated, with a foreword, by>.

\begin{keymarglist}
\item[bytranslatorco] Used if \bibfield{translator}\slash \bibfield{commentator} are identical.
\item[bytranslatoran] Used if \bibfield{translator}\slash \bibfield{annotator} are identical.
\item[bytranslatorin] Used if \bibfield{translator}\slash \bibfield{introduction} are identical.
\item[bytranslatorfo] Used if \bibfield{translator}\slash \bibfield{foreword} are identical.
\item[bytranslatoraf] Used if \bibfield{translator}\slash \bibfield{aftword} are identical.
\end{keymarglist}
%
Keys for \bibfield{translator}\slash \bibfield{commentator}\slash \prm{role} combinations:

\begin{keymarglist}
\item[bytranslatorcoin] Used if \bibfield{translator}\slash \bibfield{commentator}\slash \bibfield{introduction} are identical.
\item[bytranslatorcofo] Used if \bibfield{translator}\slash \bibfield{commentator}\slash \bibfield{foreword} are identical.
\item[bytranslatorcoaf] Used if \bibfield{translator}\slash \bibfield{commentator}\slash \bibfield{aftword} are identical.
\end{keymarglist}
%
Keys for \bibfield{translator}\slash \bibfield{annotator}\slash \prm{role} combinations:

\begin{keymarglist}
\item[bytranslatoranin] Used if \bibfield{translator}\slash \bibfield{annotator}\slash \bibfield{introduction} are identical.
\item[bytranslatoranfo] Used if \bibfield{translator}\slash \bibfield{annotator}\slash \bibfield{foreword} are identical.
\item[bytranslatoranaf] Used if \bibfield{translator}\slash \bibfield{annotator}\slash \bibfield{aftword} are identical.
\end{keymarglist}

\paragraph{角色，解释为对象}%Roles, Expressed as Objects
\label{aut:lng:key:rob}
与补充材料相关的角色可以解释为对象(<with a commentary by>)而不是职业(<commentator>)或行为(<commented by>)。
%Roles which are related to supplementary material may also be expressed as objects (<with a commentary by>) rather than as functions (<commentator>) or as actions (<commented by>).

\begin{keymarglist}
\item[withcommentator] The expression <with a commentary by \prm{name}>.
\item[withannotator] The expression <with annotations by \prm{name}>.
\item[withintroduction] The expression <with an introduction by \prm{name}>.
\item[withforeword] The expression <with a foreword by \prm{name}>.
\item[withafterword] The expression <with an afterword by \prm{name}>.
\end{keymarglist}

\paragraph{补充材料}%Supplementary Material
\label{aut:lng:key:mat}

\begin{keymarglist}
\item[commentary] The term <commentary>.
\item[annotations] The term <annotations>.
\item[introduction] The term <introduction>.
\item[foreword] The term <foreword>.
\item[afterword] The term <afterword>.
\end{keymarglist}

\paragraph{出版信息细节}%Publication Details
\label{aut:lng:key:pdt}

\begin{keymarglist}
\item[volume] The term <volume>, referring to a book.
\item[volumes] The plural form of \texttt{volume}.
\item[involumes] The term <in>, as used in expressions like <in \prm{number of volumes} volumes>.
\item[jourvol] The term <volume>, referring to a journal.
\item[jourser] The term <series>, referring to a journal.
\item[book] The term <book>, referring to a document division.
\item[part] The term <part>, referring to a part of a book or a periodical.
\item[issue] The term <issue>, referring to a periodical.
\item[newseries] The expression <new series>, referring to a journal.
\item[oldseries] The expression <old series>, referring to a journal.
\item[edition] The term <edition>.
\item[in] The term <in>, referring to the title of a work published as part of another one, \eg\ <\prm{title of article} in \prm{title of journal}>.
\item[inseries] The term <in>, as used in expressions like <volume \prm{number} in \prm{name of series}>.
\item[ofseries] The term <of>, as used in expressions like <volume \prm{number} of \prm{name of series}>.
\item[number] The term <number>, referring to an issue of a journal.
\item[chapter] The term <chapter>, referring to a chapter in a book.
\item[version] The term <version>, referring to a revision number.
\item[reprint] The term <reprint>.
\item[reprintof] The expression <reprint of \prm{title}>.
\item[reprintas] The expression <reprinted as \prm{title}>.
\item[reprintfrom] The expression <reprinted from \prm{title}>.
\item[translationof] The expression <translation of \prm{title}>.
\item[translationas] The expression <translated as \prm{title}>.
\item[translationfrom] The expression <translated from [the] \prm{language}>.
\item[reviewof] The expression <review of \prm{title}>.
\item[origpubas] The expression <originally published as \prm{title}>.
\item[origpubin] The expression <originally published in \prm{year}>.
\item[astitle] The term <as>, as used in expressions like <published by \prm{publisher} as \prm{title}>.
\item[bypublisher] The term <by>, as used in expressions like <published by \prm{publisher}>.
\end{keymarglist}

\paragraph{出版状态}%Publication State
\label{aut:lng:key:pst}

\begin{keymarglist}
\item[inpreparation] The expression <in preparation> (the manuscript is being prepared for publication).
\item[submitted] The expression <submitted> (the manuscript has been submitted to a journal or conference).
\item[forthcoming] The expression <forthcoming> (the manuscript has been accepted by a press or journal).
\item[inpress] The expression <in press> (the manuscript is fully copyedited and out of the author's hands; it is in the final stages of the production process).
\item[prepublished] The expression <pre-published> (the manuscript is published in a preliminary form or location, such as online version in advance of print publication).
\end{keymarglist}

\paragraph{页码}%Pagination
\label{aut:lng:key:pag}

\begin{keymarglist}
\item[page] The term <page>.
\item[pages] The plural form of \texttt{page}.
\item[column] The term <column>, referring to a column on a page.
\item[columns] The plural form of \texttt{column}.
\item[section] The term <section>, referring to a document division (usually abbreviated as \S).
\item[sections] The plural form of \texttt{section} (usually abbreviated as \S\S).
\item[paragraph] The term <paragraph> (\ie a block of text, not to be confused with \texttt{section}).
\item[paragraphs] The plural form of \texttt{paragraph}.
\item[verse] The term <verse> as used when referring to a work which is cited by verse numbers.
\item[verses] The plural form of \texttt{verse}.
\item[line] The term <line> as used when referring to a work which is cited by line numbers.
\item[lines] The plural form of \texttt{line}.
\item[pagetotal] The term <page> as used in \cmd{mkpageprefix}.
\item[pagetotals] The plural form of \texttt{pagetotal}.
\item[columntotal] The term <column>, referring to a column on a page, as used in \cmd{mkpageprefix}.
\item[columntotals] The plural form of \texttt{columntotal}.
\item[sectiontotal] The term <section>, referring to a document division (usually abbreviated as \S),  as used in \cmd{mkpageprefix}.
\item[sectiontotals] The plural form of \texttt{sectiontotal} (usually abbreviated as \S\S).
\item[paragraphtotal] The term <paragraph> (\ie a block of text, not to be confused with \texttt{section}) as used in \cmd{mkpageprefix}.
\item[paragraphtotals] The plural form of \texttt{paragraphtotal}.
\item[versetotal] The term <verse> as used when referring to a work which is cited by verse numbers when used in \cmd{mkpageprefix}.
\item[versetotals] The plural form of \texttt{versetotal}.
\item[linetotal] The term <line> as used when referring to a work which is cited by line numbers when used in \cmd{mkpageprefix}.
\item[linetotals] The plural form of \texttt{linetotal}.
\end{keymarglist}

\paragraph{类型}%Types
\label{aut:lng:key:typ}

下面的关键词常用于\bibtype{thesis}，\bibtype{report}, \bibtype{misc} 和其它一些条目的\bibfield{type} 域中:
%The following keys are typically used in the \bibfield{type} field of \bibtype{thesis}, \bibtype{report}, \bibtype{misc}, and other entries:

\begin{keymarglist}
\item[bathesis] An expression equivalent to the term <Bachelor's thesis>.
\item[mathesis] An expression equivalent to the term <Master's thesis>.
\item[phdthesis] The term <PhD thesis>, <PhD dissertation>, <doctoral thesis>, etc.
\item[candthesis] An expression equivalent to the term <Candidate thesis>. Used for <Candidate> degrees that have no clear equivalent to the Master's or doctoral level.
\item[techreport] The term <technical report>.
\item[resreport] The term <research report>.
\item[software] The term <computer software>.
\item[datacd] The term <data \textsc{cd}> or <\textsc{cd-rom}>.
\item[audiocd] The term <audio \textsc{cd}>.
\end{keymarglist}

\paragraph{杂项}%Miscellaneous
\label{aut:lng:key:msc}

\begin{keymarglist}
\item[nodate] The term to use in place of a date when there is no date for an entry \eg\ <n.d.>
\item[and] The term <and>, as used in a list of authors or editors, for example.
\item[andothers] The expression <and others> or <et alii>, used to mark the truncation of a name list.
\item[andmore] Like \texttt{andothers} but used to mark the truncation of a literal list.
\end{keymarglist}

\paragraph{标签}%Labels
\label{aut:lng:key:lab}

下面的字符串用于形成标签，比如<Address: \prm{url}>或者<Abstract: \prm{abstract}>等。
%The following strings are intended for use as labels, \eg\ <Address: \prm{url}> or <Abstract: \prm{abstract}>.

\begin{keymarglist}
\item[url] The term <address> in the sense of an internet address.
\item[urlfrom] An expression like <available from \prm{url}> or <available at \prm{url}>.
\item[urlseen] An expression like <accessed on \prm{date}>, <retrieved on \prm{date}>, <visited on \prm{date}>, referring to the access date of an online resource.
\item[file] The term <file>.
\item[library] The term <library>.
\item[abstract] The term <abstract>.
\item[annotation] The term <annotations>.
\end{keymarglist}

\paragraph{标注}%Citations
\label{aut:lng:key:cit}

标注中使用的传统学术短语:
%Traditional scholarly expressions used in citations:

\begin{keymarglist}
\item[idem] The term equivalent to the Latin <idem> (<the same [person]>).
\item[idemsf] The feminine singular form of \texttt{idem}.
\item[idemsm] The masculine singular form of \texttt{idem}.
\item[idemsn] The neuter singular form of \texttt{idem}.
\item[idempf] The feminine plural form of \texttt{idem}.
\item[idempm] The masculine plural form of \texttt{idem}.
\item[idempn] The neuter plural form of \texttt{idem}.
\item[idempp] The plural form of \texttt{idem} suitable for a mixed gender list of names.
\item[ibidem] The term equivalent to the Latin <ibidem> (<in the same place>).
\item[opcit] The term equivalent to the Latin term <opere citato> (<[in] the work [already] cited>).
\item[loccit] The term equivalent to the Latin term <loco citato> (<[at] the place [already] cited>).
\item[confer] The term equivalent to the Latin <confer> (<compare>).
\item[sequens] The term equivalent to the Latin <sequens> (<[and] the following [page]>), as used to indicate a range of two pages when only the starting page is provided (\eg\ <25\,sq.> or <25\,f.> instead of <25--26>).
\item[sequentes] The term equivalent to the Latin <sequentes> (<[and] the following [pages]>), as used to indicate an open"=ended range of pages when only the starting page is provided (\eg\ <25\,sqq.> or <25\,ff.>).
\item[passim] The term equivalent to the Latin <passim> (<throughout>, <here and there>, <scatteredly>).
\end{keymarglist}
%
其他在标注中常用的短语:
%Other expressions frequently used in citations:

\begin{keymarglist}
\item[see] The term <see>.
\item[seealso] The expression <see also>.
\item[seenote] An expression like <see note \prm{footnote}> or <as in \prm{footnote}>, used to refer to a previous footnote in a citation.
\item[backrefpage] An expression like <see page \prm{page}> or <cited on page \prm{page}>, used to introduce back references in the bibliography.
\item[backrefpages] The plural form of \texttt{backrefpage}, \eg\ <see pages \prm{pages}> or <cited on pages \prm{pages}>.
\item[quotedin] An expression like <quoted in \prm{citation}>, used when quoting a passage which was already a quotation in the cited work.
\item[citedas] An expression like <henceforth cited as \prm{shorthand}>, used to introduce a shorthand in a citation.
\item[thiscite] The expression used in some verbose citation styles to differentiate between the page range of the cited item (typically an article in a journal, collection, or conference proceedings) and the page number the citation refers to. For example: \enquote{Author, Title, in: Book, pp. 45--61, \texttt{thiscite} p. 52.}
\end{keymarglist}

\paragraph{月份名}%Month Names
\label{aut:lng:key:mon}

\begin{keymarglist}
\item[january] The name <January>.
\item[february] The name <February>.
\item[march] The name <March>.
\item[april] The name <April>.
\item[may] The name <May>.
\item[june] The name <June>.
\item[july] The name <July>.
\item[august] The name <August>.
\item[september] The name <September>.
\item[october] The name <October>.
\item[november] The name <November>.
\item[december] The name <December>.
\end{keymarglist}

\paragraph{语言名}%Language Names
\label{aut:lng:key:lng}

\begin{keymarglist}
\item[langamerican] The language <American> or <American English>.
\item[langbasque] The language <Basque>.
\item[langbrazilian] The language <Brazilian> or <Brazilian Portuguese>.
\item[langbulgarian] The language <Bulgarian>.
\item[langcatalan] The language <Catalan>.
\item[langcroatian] The language <Croatian>.
\item[langczech] The language <Czech>.
\item[langdanish] The language <Danish>.
\item[langdutch] The language <Dutch>.
\item[langenglish] The language <English>.
\item[langestonian] The language <Estonian>.
\item[langfinnish] The language <Finnish>.
\item[langfrench] The language <French>.
\item[langgerman] The language <German>.
\item[langgreek] The language <Greek>.
\item[langhungarian] The language <Hungarian>.
\item[langitalian] The language <Italian>.
\item[langjapanese] The language <Japanese>.
\item[langlatin] The language <Latin>.
\item[langlatvian] The language <Latvian>.
\item[langlithuanian] The language <Lithuanian>.
\item[langnorwegian] The language <Norwegian>.
\item[langpolish] The language <Polish>.
\item[langportuguese] The language <Portuguese>.
\item[langrussian] The language <Russian>.
\item[langserbian] The language <Serbian>.
\item[langslovak] The language <Slovak>.
\item[langslovene] The language <Slovene>.
\item[langspanish] The language <Spanish>.
\item[langswedish] The language <Swedish>.
\item[langturkish] The language <Turkish>.
\item[langukrainian] The language <Ukrainian>.
\end{keymarglist}
%
下面的字符串用于像<translated from [the] English by \prm{translator}>之类的短语中:
%The following strings are intended for use in phrases like <translated from [the] English by \prm{translator}>:

\begin{keymarglist}
\item[fromamerican] The expression <from [the] American> or <from [the] American English>.
\item[frombasque] The expression <from [the] Basque>.
\item[frombrazilian] The expression <from [the] Brazilian> or <from [the] Brazilian Portuguese>.
\item[frombulgarian] The expression <from [the] Bulgarian>.
\item[fromcatalan] The expression <from [the] Catalan>.
\item[fromcroatian] The expression <from [the] Croatian>.
\item[fromczech] The expression <from [the] Czech>.
\item[fromdanish] The expression <from [the] Danish>.
\item[fromdutch] The expression <from [the] Dutch>.
\item[fromenglish] The expression <from [the] English>.
\item[fromestonian] The expression <from [the] Estonian>.
\item[fromfinnish] The expression <from [the] Finnish>.
\item[fromfrench] The expression <from [the] French>.
\item[fromgerman] The expression <from [the] German>.
\item[fromgreek] The expression <from [the] Greek>.
\item[fromhungarian] The language <from [the] Hungarian>.
\item[fromitalian] The expression <from [the] Italian>.
\item[fromjapanese] The expression <from [the] Japanese>.
\item[fromlatin] The expression <from [the] Latin>.
\item[fromlatvian] The expression <from [the] Latvian>.
\item[fromlithuanian] The language <from [the] Lithuanian>.
\item[fromnorwegian] The expression <from [the] Norwegian>.
\item[frompolish] The expression <from [the] Polish>.
\item[fromportuguese] The expression <from [the] Portuguese>.
\item[fromrussian] The expression <from [the] Russian>.
\item[fromserbian] The expression <from [the] Serbian>.
\item[fromslovak] The expression <from [the] Slovak>.
\item[fromslovene] The expression <from [the] Slovene>.
\item[fromspanish] The expression <from [the] Spanish>.
\item[fromswedish] The expression <from [the] Swedish>.
\item[fromturkish] The expression <from [the] Turkish>.
\item[fromukrainian] The expression <from [the] Ukrainian>.
\end{keymarglist}

\paragraph{国名}%Country Names
\label{aut:lng:key:cnt}

国名利用\texttt{country} 加\acr{ISO}-3166国家代码实现本地化。不同语言的译文的简易版本应是\acr{ISO}-3166国家代码。注意:仅默认定义了少量国名关键词，用来说明这一方法。这些关键词用在\bibtype{patent} 条目的\bibfield{location} 域中，但也可以用于其他地方。
%Country names are localised by using the string \texttt{country} plus the \acr{ISO}-3166 country code as the key. The short version of the translation should be the \acr{ISO}-3166 country code. Note that only a small number of country names is defined by default, mainly to illustrate this scheme. These keys are used in the \bibfield{location} list of \bibtype{patent} entries but they may be useful for other purposes as well.

\begin{keymarglist}
\item[countryde] 名称<Germany>，缩写为\texttt{DE}
%The name <Germany>, abbreviated as \texttt{DE}.
\item[countryeu] 名称<European Union>，缩写为\texttt{EU}
%The name <European Union>, abbreviated as \texttt{EU}.
\item[countryep] 类似于\opt{countryeu}，但缩写为\texttt{EP}。用于\bibfield{patent} 条目。
%Similar to \opt{countryeu} but abbreviated as \texttt{EP}. This is intended for \bibfield{patent} entries.
\item[countryfr] 名称<France>，缩写为\texttt{FR}
%The name <France>, abbreviated as \texttt{FR}.
\item[countryuk] 名称<United Kingdom>，缩写为\texttt{GB}(根据\acr{ISO}-3166)
%The name <United Kingdom>, abbreviated (according to \acr{ISO}-3166) as \texttt{GB}.
\item[countryus] 名称<United States of America>，缩写为\texttt{US}
%The name <United States of America>, abbreviated as \texttt{US}.
\end{keymarglist}

\paragraph{专利和专利申请}%Patents and Patent Requests
\label{aut:lng:key:pat}

与专利相关的字符串通过使用术语\texttt{patent} 加\acr{ISO}-3166国家代码作为关键词实现本地化。注意:仅默认定义了少量专利关键词，用来说明这一方法。这些关键词用在\bibtype{patent} 的\bibfield{type} 域中。
%Strings related to patents are localised by using the term \texttt{patent} plus the \acr{ISO}-3166 country code as the key. Note that only a small number of patent keys is defined by default, mainly to illustrate this scheme. These keys are used in the \bibfield{type} field of \bibtype{patent} entries.

\begin{keymarglist}
\item[patent] 通用术语<patent>
%The generic term <patent>.
\item[patentde] 短语<German patent>
%The expression <German patent>.
\item[patenteu] 短语<European patent>
%The expression <European patent>.
\item[patentfr] 短语<French patent>
%The expression <French patent>.
\item[patentuk] 短语<British patent>
%The expression <British patent>.
\item[patentus] 短语<U.S. patent>
%The expression <U.S. patent>.
\end{keymarglist}
%
专利申请以类似方式处理，使用字符串\texttt{patreq} 作为关键词的基本名称:
%Patent requests are handled in a similar way, using the string \texttt{patreq} as the base name of the key:

\begin{keymarglist}
\item[patreq] 通用术语<patent request>
%The generic term <patent request>.
\item[patreqde] 短语<German patent request>
%The expression <German patent request>.
\item[patreqeu] 短语<European patent request>
%The expression <European patent request>.
\item[patreqfr] 短语<French patent request>
%The expression <French patent request>.
\item[patrequk] 短语<British patent request>
%The expression <British patent request>.
\item[patrequs] 短语<U.S. patent request>
%The expression <U.S. patent request>.
\end{keymarglist}

\paragraph{日期和时间}%Dates and Times
\label{aut:lng:key:dt}
标准纪元的缩略词。支持世俗的或基督教两种版本。
%Abbreviation strings for standard eras. Both secular and Christian variants are supported.

\begin{keymarglist}
\item[commonera] 纪元<CE>(表示:公元)
%The era <CE>
\item[beforecommonera] 纪元<BCE>(表示:公元前)
%The era <BCE>
\item[annodomini] 纪元<AD>(表示:公元)
%The era <AD>
\item[beforechrist] 纪元<BC>(表示:公元前)
%The era <BC>
\end{keymarglist}

<circa>日期的缩略词:
%Abbreviation strings for <circa> dates:

\begin{keymarglist}
\item[circa] 词<circa>(表示:大约在)
%The string <circa>
\end{keymarglist}

从\acr{EDTF} 日期解析的季节的缩略词:
%Abbreviation strings for seasons parsed from \acr{ISO8601-2} Extended Format dates:

\begin{keymarglist}
\item[spring] 词<spring>(表示:春)
\item[summer] 词<summer>(表示:夏)
\item[autumn] 词<autumn>(表示:秋)
\item[winter] 词<winter>(表示:冬)
\end{keymarglist}

AM/PM的缩略词:
%Abbreviation strings for AM/PM:

\begin{keymarglist}
\item[am] 词<AM>(表示:上午)
\item[pm] 词<PM>(表示:下午)
\end{keymarglist}

\subsection{格式化命令}%Formatting Commands
\label{aut:fmt}

本节对应于用户指南部分的\secref{use:fmt} 节。著录和标注样式需要一些本节讨论的命令和工具来提供一定程度的高层可配置性。用户不需要非得写一个新的样式，如果仅要求修改文献表中的空格以及标注中的标点的话。
%This section corresponds to \secref{use:fmt} in the user part of this manual. Bibliography and citation styles should incorporate the commands and facilities discussed in this section in order to provide a certain degree of high"=level configurability. Users should not be forced to write new styles if all they want to do is modify the spacing in the bibliography or the punctuation used in citations.

\subsubsection{用户可定义的命令和钩子}%User-definable Commands and Hooks
\label{aut:fmt:fmt}

本节对应用户指南部分的\secref{use:fmt:fmt} 节。这里讨论的命令和钩子可以由用户重定义，但著录和标注样式可能会提供一个不同于宏包定义的默认定义。这些命令在\path{biblatex.def} 中定义。注意所有的这些命令以\cmd{mk\dots} 开头具有一个必选参数。
%This section corresponds to \secref{use:fmt:fmt} in the user part of the manual. The commands and hooks discussed here are meant to be redefined by users, but bibliography and citation styles may provide a default definition which is different from the package default. These commands are defined in \path{biblatex.def}. Note that all commands starting with \cmd{mk\dots} take one mandatory argument.

\begin{ltxsyntax}
\csitem{bibsetup}
Arbitrary code to be executed at the beginning of the bibliography, intended for commands which affect the layout of the bibliography.

\csitem{bibfont}
Arbitrary code setting the font used in the bibliography. This is very similar to \cmd{bibsetup} but intended for switching fonts.

\csitem{citesetup}
Arbitrary code to be executed at the beginning of each citation command.

\csitem{newblockpunct}
The separator inserted between <blocks> in the sense explained in \secref{aut:pct:new}. The default definition is controlled by the package option \opt{block} (see \secref{use:opt:pre:gen}).

\csitem{newunitpunct}
The separator inserted between <units> in the sense explained in \secref{aut:pct:new}. This will usually be a period or a comma plus an interword space. The default definition is a period and a space.

\csitem{finentrypunct}
The punctuation printed at the very end of every bibliography entry, usually a period. The default definition is a period.

\csitem{entrysetpunct}
The punctuation printed between bibliography subentries of an entry set. The default definition is a semicolon and a space.

\csitem{bibnamedelima}
这一分隔符控制构成姓名成分的元素间的间距。它由后端自动添加，位于第一个元素后面如果该元素少于三个字符长度和最后一个元素之前。默认的定义为\cmd{addhighpenspace}，即一个由\cnt{highnamepenalty} 计数器(\secref{use:fmt:len} 节)值控制的空间，更多细节见\secref{use:cav:nam}。
%This delimiter controls the spacing between the elements which make up a name part. It is inserted automatically by the backend after the first name element if the element is less than three characters long and before the last element. The default definition is \cmd{addhighpenspace}, \ie a space penalized by the value of the \cnt{highnamepenalty} counter (\secref{use:fmt:len}). Please refer to \secref{use:cav:nam} for further details.

\csitem{bibnamedelimb}
这一分隔符控制构成姓名成分的元素间的间距。它由后端自动添加，位于所有元素之间，但存在\cmd{bibnamedelima} 时不添加。默认的定义为\cmd{addlowpenspace}，即一个由\cnt{lownamepenalty} 计数器(\secref{use:fmt:len} 节)值控制的空间，更多细节见\secref{use:cav:nam}。
%This delimiter controls the spacing between the elements which make up a name part. It is inserted automatically by the backend between all name elements where \cmd{bibnamedelima} does not apply. The default definition is \cmd{addlowpenspace}, \ie a space penalized by the value of the \cnt{lownamepenalty} counter (\secref{use:fmt:len}). Please refer to \secref{use:cav:nam} for further details.

\csitem{bibnamedelimc}
这一分隔符控制构成姓名成分的元素间的间距。它由后端自动添加，位于前缀和姓之间，当\kvopt{useprefix}{true} 时。默认的定义为\cmd{addhighpenspace}，即一个由\cnt{highnamepenalty} 计数器(\secref{use:fmt:len} 节)值控制的空间，更多细节见\secref{use:cav:nam}。
%This delimiter controls the spacing between name parts. The default name formats use it between the name prefix and the last name if \kvopt{useprefix}{true}. The default definition is \cmd{addhighpenspace}, \ie a space penalized by the value of the \cnt{highnamepenalty} counter (\secref{use:fmt:len}). Please refer to \secref{use:cav:nam} for further details.

\csitem{bibnamedelimd}
这一分隔符控制构成姓名成分的元素间的间距。它由后端自动添加，位于所有元素之间，但存在\cmd{bibnamedelimc} 时不添加。默认的定义为\cmd{addlowpenspace}，即一个由\cnt{lownamepenalty} 计数器(\secref{use:fmt:len} 节)值控制的空间，更多细节见\secref{use:cav:nam}。
%This delimiter controls the spacing between name parts. The default name formats use it between all name parts where \cmd{bibnamedelimc} does not apply. The default definition is \cmd{addlowpenspace}, \ie a space penalized by the value of the \cnt{lownamepenalty} counter (\secref{use:fmt:len}). Please refer to \secref{use:cav:nam} for further details.

\csitem{bibnamedelimi}
这一分隔符代替首字母后的\cmd{bibnamedelima/b}。注意: 这仅应用于在\file{bib} 文件中给出的首字母后，而不是由\biblatex 自动生成的首字母后，因为它使用自己的分隔符。
%This delimiter replaces \cmd{bibnamedelima/b} after initials. Note that this only applies to initials given as such in the \file{bib} file, not to the initials automatically generated by \biblatex which use their own set of delimiters.

\csitem{bibinitperiod}

当不应用\cmd{bibinithyphendelim} 时由后端自动在所有缩写首字母后插入的标点。默认的定义是句点(\cmd{adddot})。更多细节见\secref{use:cav:nam}。
%The punctuation inserted automatically by the backend after all initials unless \cmd{bibinithyphendelim} applies. The default definition is a period (\cmd{adddot}). Please refer to \secref{use:cav:nam} for further details.

\csitem{bibinitdelim}
当不应用\cmd{bibinithyphendelim} 时由后端自动在多个缩写首字母见插入空间。默认的定义是不可断行的词内空格。更多细节见\secref{use:cav:nam}。
%The spacing inserted automatically by the backend between multiple initials unless \cmd{bibinithyphendelim} applies. The default definition is an unbreakable interword space. Please refer to \secref{use:cav:nam} for further details.

\csitem{bibinithyphendelim}
由后端自动在连字符连接的姓名成分的缩写首字母间插入的标点，代替\cmd{bibinitperiod} 和\cmd{bibinitdelim}。默认的定义时句点加一个不可断行连字符。更多细节见\secref{use:cav:nam}。
%The punctuation inserted automatically by the backend between the initials of hyphenated name parts, replacing \cmd{bibinitperiod} and \cmd{bibinitdelim}. The default definition is a period followed by an unbreakable hyphen. Please refer to \secref{use:cav:nam} for further details.

\csitem{bibindexnamedelima}
用于在索引中取代\cmd{bibnamedelima}。
%Replaces \cmd{bibnamedelima} in the index.

\csitem{bibindexnamedelimb}
用于在索引中取代\cmd{bibnamedelimb}。
%Replaces \cmd{bibnamedelimb} in the index.

\csitem{bibindexnamedelimc}
用于在索引中取代\cmd{bibnamedelimc}。
%Replaces \cmd{bibnamedelimc} in the index.

\csitem{bibindexnamedelimd}
用于在索引中取代\cmd{bibnamedelimd}。
%Replaces \cmd{bibnamedelimd} in the index.

\csitem{bibindexnamedelimi}
用于在索引中取代\cmd{bibnamedelimi}。
%Replaces \cmd{bibnamedelimi} in the index.

\csitem{bibindexinitperiod}
用于在索引中取代\cmd{bibinitperiod}。
%Replaces \cmd{bibinitperiod} in the index.

\csitem{bibindexinitdelim}
用于在索引中取代\cmd{bibinitdelim}。
%Replaces \cmd{bibinitdelim} in the index.

\csitem{bibindexinithyphendelim}
用于在索引中取代\cmd{bibinithyphendelim}。
%Replaces \cmd{bibinithyphendelim} in the index.

\csitem{revsdnamepunct}
当姓和名顺序相反时两者之间插入的标点。默认是逗号。该命令应在姓名列表的格式化指令中使用。更多细节见\secref{use:cav:nam}。
%The punctuation to be printed between the given and family name parts when a name is reversed. The default is a comma. This command should be incorporated in formatting directives for name lists.  Please refer to \secref{use:cav:nam} for further details.

\csitem{bibnamedash}
用于代替参考文献表中接连再出现的责任者的破折号。默认是一个<em>或<en>破折号，根据文献表的缩进选取。
%The dash to be used as a replacement for recurrent authors or editors in the bibliography. The default is an <em> or an <en> dash, depending on the indentation of the list of references.

\csitem{labelnamepunct}\DeprecatedMark

%A separator to be printed after the name used for alphabetizing in the bibliography (\bibfield{author} or \bibfield{editor}, if the \bibfield{author} field is undefined) instead of \cmd{newunitpunct}. The default is \cmd{newunitpunct}, \ie it is not handled differently from regular unit punctuation but permits convenient reconfiguration. This punctuation command is deprecated and has been superseded by the context-sensitive \cmd{nametitledelim} (see \secref{use:fmt:csd}). For backwards compatibility reasons, however, \cmd{nametitledelim} still defaults to \cmd{labelnamepunct} in the \texttt{bib} and \texttt{biblist} contexts. Style authors may want to consider replacing \cmd{labelnampunct} with \texttt{\textbackslash printdelim\{nametitledelim\}} and users may want to prefer modifying the context-sensitive \texttt{nametitledelim} with \cmd{DeclareDelimFormat} over redefining \cmd{labelnamepunct}.


该分隔符在文献表中用来按字母顺序排列的责任者(\bibfield{author} 或\bibfield{editor},如果\bibfield{author} 域未定义)之后打印。使用该分隔符代替该位置的\cmd{newunitpunct}。默认是\cmd{newunitpunct}，即它与一般的单元标点并无不同，但允许方便地重设。


\csitem{subtitlepunct}
该分隔符在\bibfield{title} 和\bibfield{subtitle} 域，\bibfield{booktitle} 和\bibfield{booksubtitle}，以及\bibfield{maintitle} 和 \bibfield{mainsubtitle} 之间打印。替代该位置处的\cmd{newunitpunct}。默认是\cmd{newunitpunct}，即它与一般的单元标点并无不同，但允许方便地重设。
%The separator to be printed between the fields \bibfield{title} and \bibfield{subtitle}, \bibfield{booktitle} and \bibfield{booksubtitle}, as well as \bibfield{maintitle} and \bibfield{mainsubtitle}. Use this separator instead of \cmd{newunitpunct} at this location. The default is \cmd{newunitpunct}, \ie it is not handled differently from regular unit punctuation but permits convenient reconfiguration.

\csitem{intitlepunct}
该分隔符在«in»与其后面的一些条目类型的标题之间打印。替代该位置处的\cmd{newunitpunct}。默认是一个冒号加词内空格。
%The separator to be printed between the word «in» and the following title in entry types such as \bibtype{article}, \bibtype{inbook}, \bibtype{incollection}, etc. Use this separator instead of \cmd{newunitpunct} at this location. The default definition is a colon plus an interword space.

\csitem{bibpagespunct}
该分隔符在\bibfield{pages} 域前打印。替代该位置处的\cmd{newunitpunct}。默认是一个逗号加词内空格。
%The separator to be printed before the \bibfield{pages} field. Use this separator instead of \cmd{newunitpunct} at this location. The default is a comma plus an interword space.

\csitem{bibpagerefpunct}
该分隔符在\bibfield{pageref} 域前打印。替代该位置处的\cmd{newunitpunct}。默认是一个词内空格。
%The separator to be printed before the \bibfield{pageref} field. Use this separator instead of \cmd{newunitpunct} at this location. The default is an interword space.

\csitem{bibeidpunct}
The separator printed before the \bibfield{eid} field (similar to \cmd{bibpagespunct}). The default is a comma plus an interword space.

\csitem{multinamedelim}
该分隔符在\bibfield{author} 或\bibfield{editor} 之类的姓名列表的各项之间打印，如果列表中存在超过2个姓名的话。如果列表中仅有两个姓名，则使用\cmd{finalnamedelim}。该命令应在姓名列表的所有格式化指令中使用。
%The delimiter to be printed between multiple items in a name list like \bibfield{author} or \bibfield{editor} if there are more than two names in the list. If there are only two names in the list, use the \cmd{finalnamedelim} instead. This command should be incorporated in all formatting directives for name lists.

\csitem{finalnamedelim}
用于替代姓名列表中最后一个名字前的\cmd{multinamedelim}。
%Use this command instead of \cmd{multinamedelim} before the final name in a name list.

The default is the localised term <and>, separated by interword spaces.

\csitem{revsdnamedelim}

在由两个姓名构成的姓名列表中第一个姓名之后打印的额外分隔符(加在\cmd{finalnamedelim} 后面)，如果第一个姓名的姓和名顺序相反的话。该命令应在姓名列表的所有格式化指令中使用。
%The extra delimiter to be printed after the first name in a name list consisting of two names (in addition to \cmd{finalnamedelim}) if the first name is reversed. This command should be incorporated in all formatting directives for name lists.

\csitem{andothersdelim}

一个\bibfield{author} 或\bibfield{editor} 之类的姓名列表被截短后在本地化字符串<\texttt{andothers}>前打印的分隔符。该命令应在姓名列表的所有格式化指令中配合使用。
%The delimiter to be printed before the localisation string <\texttt{andothers}> if a name list like \bibfield{author} or \bibfield{editor} is truncated. This command should be incorporated in all formatting directives for name lists.

\csitem{multilistdelim}
该分隔符在\bibfield{publisher} 或\bibfield{location} 之类的文本列表的各项之间打印，如果列表中存在超过2个文本项的话。如果列表中仅有两项，则使用\cmd{finallistdelim}。该命令应在文本列表的所有格式化指令中使用。
%The delimiter to be printed between multiple items in a literal list like \bibfield{publisher} or \bibfield{location} if there are more than two names in the list. If there are only two items in the list, use the \cmd{finallistdelim} instead. This command should be incorporated in all formatting directives for literal lists.
%这里原文有笔误。

\csitem{finallistdelim}
用于替代文本列表中最后一个项前的\cmd{multilistdelim}。
%Use this command instead of \cmd{multilistdelim} before the final item in a literal list.

\csitem{andmoredelim}
一个\bibfield{publisher} 或\bibfield{location} 之类的文本列表被截短后在本地化字符串<\texttt{andmore}>前打印的分隔符。该命令应在文本列表的所有格式化指令中使用。
%The delimiter to be printed before the localisation string <\texttt{andmore}> if a literal list like \bibfield{publisher} or \bibfield{location} is truncated. This command should be incorporated in all formatting directives for literal lists.

\csitem{multicitedelim}
该分隔符在传递给当个标注命令的多个条目关键词之间打印。该命令应在标注命令定义中使用，例如在传递给\cmd{DeclareCiteCommand} 的\prm{sepcode} 参数中。详见\secref{aut:cbx:cbx}。
%The delimiter printed between citations if multiple entry keys are passed to a single citation command. This command should be incorporated in the definition of all citation commands, for example in the \prm{sepcode} argument passed to \cmd{DeclareCiteCommand}. See \secref{aut:cbx:cbx} for details.The default is a semicolon plus an interword space.

\csitem{multiciterangedelim}
The delimiter printed between two citations if they are compressed to a range. The default is \cmd{bibrangedash}.

\csitem{multicitesubentrydelim}
The delimiter printed between subentry citations of the same set. This delimiter is only used in citation styles that reduce citations of the same set to a more compact form (\opt{subentry} of \texttt{numeric-comp}). The default is a comma.

\csitem{multicitesubentryrangedelim}
The delimiter printed between two citations of the same set if they are compressed to a range. The default is \cmd{multiciterangedelim}.

\csitem{supercitedelim}
类似于\cmd{multicitedelim}，但仅用于\cmd{supercite} 命令中。
%Similar to \cmd{multinamedelim}, but intended for the \cmd{supercite} command only.
%这里原文有笔误。
The default is a comma.

\csitem{superciterangedelim}
Analogue of \cmd{multiciterangedelim} for \cmd{supercite}. The default is \cmd{bibrangedash}.

\csitem{supercitesubentrydelim}
Analogue of \cmd{multicitesubentrydelim} for \cmd{supercite}. The default is \cmd{supercitedelim}.

\csitem{supercitesubentryrangedelim}
Analogue of \cmd{multicitesubentryrangedelim} for \cmd{supercite}. The default is \cmd{superciterangedelim}.

\csitem{compcitedelim}
类似于\cmd{multicitedelim}，但仅用于压缩(<compress>)多个引用的标注样式中，即打印作者一次，如果后面接着的引用文献的作者相同的话。
%Similar to \cmd{multicitedelim}, but intended for citation styles that <compress> multiple citations, \ie print the author only once if subsequent citations share the same author etc.

\csitem{textcitedelim}
类似于\cmd{multicitedelim}，但仅用于\cmd{textcite} 和相关命令(\secref{use:cit:cbx})中。
%Similar to \cmd{multicitedelim}, but intended for \cmd{textcite} and related commands (\secref{use:cit:cbx}).

The default is a comma plus an interword space. The standard styles modify this provisional definition to ensure that the delimiter before the final citation is the localised term <and>, separated by interword spaces.

\csitem{nametitledelim}
在责任者和标题之间打印的分隔符。该命令应在作者标题制和一些长标注样式的所有标注命令定义中使用。
%The delimiter to be printed between the author\slash editor and the title. This command should be incorporated in the definition of all citation commands of author-title and some verbose citation styles.
The delimiter to be printed between the author\slash editor and the title. This command should be incorporated in the definition of all citation commands of author-title and some verbose citation styles and in the bibliography drivers---in author-year bibliographies \cs{nametitledelim} may be printed between the author\slash editor-year block and the title. The default definition inside bibliographies is the now deprecated \cmd{labelnamepunct} (for backwrds compatibility reasons) and is a comma plus an interword space otherwise.

\csitem{nameyeardelim}
在责任者和年份之间打印的分隔符。该命令应在作者年制标注样式的所有标注命令定义中使用。
%The delimiter to be printed between the author\slash editor and the year. This command should be incorporated in the definition of all citation commands of author-year citation styles.

\csitem{namelabeldelim}
在name\slash title和标签之间打印的分隔符。该命令应在字母顺序编码和数字顺序编码标注样式的所有标注命令定义中使用。
%The delimiter printed between the name\slash title and the label. This command should be incorporated in the definition of all citation commands of alphabetic and numeric citation styles.

\csitem{nonameyeardelim}
作者年制标注样式中labelname的替代者(当labelname不存在时)与年份之间打印的分隔符。仅用于无labelname的情况，因为当其存在时使用的是\cmd{nameyeardelim}。
%The delimiter printed between the substitute for the labelname when it does not exist (usually the label or title in standard styles) and the year in author-year citation styles. This is only used when there is no labelname since when the labelname exists, \cmd{nameyeardelim} is used.

This command should be incorporated in the definition of all citation commands of author-year citation styles and in the bibliography drivers. The default definition is an interword space.


\csitem{authortypedelim}
The delimiter printed between the author and the \texttt{authortype}.

\csitem{editortypedelim}
The delimiter printed between the editor and the \texttt{editor} or \texttt{editortype} string.

\csitem{translatortypedelim}
The delimiter printed between the translator and the \texttt{translator} string.
The delimiter printed between the translator and the \texttt{translator} string. The default is a comma followed by a space.


\csitem{labelalphaothers}
A string to be appended to the non"=numeric portion of the \bibfield{labelalpha} field (\ie the field holding the citation label used by alphabetic citation styles) if the number of authors\slash editors exceeds the \opt{maxalphanames} threshold or the \bibfield{author}\slash \bibfield{editor} list was truncated in the \file{bib} file with the keyword <\texttt{and others}>. This will typically be a single character such as a plus sign or an asterisk. The default is a plus sign. This command may also be redefined to an empty string to disable this feature. In any case, it must be redefined in the preamble.

\csitem{sortalphaothers}
Similar to \cmd{labelalphaothers} but used in the sorting process. Setting it to a different value is advisable if the latter contains formatting commands. If \cmd{sortalphaothers} is not redefined, it defaults to \cmd{labelalphaothers}.
\csitem{volcitedelim}
在\cmd{volcite} 和相关命令的卷部分和页码/文本部分之间打印的分隔符(见\secref{use:cit:spc})。
%The delimiter to be printed between the volume portion and the page/text portion of \cmd{volcite} and related commands (\secref{use:cit:spc}).

\csitem{prenotedelim}
在标注命令的\prm{prenote} 参数后面打印的分隔符。
%The delimiter to be printed after the \prm{prenote} argument of a citation command.

\csitem{postnotedelim}
在标注命令的\prm{postnote} 参数前面打印的分隔符。
%The delimiter to be printed before the \prm{postnote} argument of a citation command.

\csitem{extpostnotedelim}
当postnote出现在标注括号外时，标注命令中在标注和插入的\prm{postnote} 参数之间打印的分隔符。在标准样式中，这仅发生在标注使用条目的缩略域时。
%The delimiter printed between the citation and the parenthetical \prm{postnote} argument of a citation command when the postnote occurs outside of the citation parentheses. In the standard styles, this occurs when the citation uses the shorthand field of the entry.

\csitem{multiprenotedelim}\CSdelimMark
The delimiter to be printed after the \prm{multiprenote} argument of a citation command.

\csitem{multipostnotedelim}\CSdelimMark
The delimiter to be printed before the \prm{multipostnote} argument of a citation command.
\cmditem{mkbibnamefamily}{text}
姓的格式化钩子，用于姓名列表的所有格式化指令中。
%Formatting hook for the family name, to be used in all formatting directives for name lists.

\cmditem{mkbibnamegiven}{text}
类似于\cmd{mkbibnamefamily}，当用于名。
%Similar to \cmd{mkbibnamefamily}, but intended for the given name.

\cmditem{mkbibnameprefix}{text}
类似于\cmd{mkbibnamefamily}，当用于姓名前缀。
%Similar to \cmd{mkbibnamefamily}, but intended for the name prefix.

\cmditem{mkbibnamesuffix}{text}
类似于\cmd{mkbibnamefamily}，当用于姓名后缀。
%Similar to \cmd{mkbibnamefamily}, but intended for the name suffix.


\cmditem{mkbibname<namepart>}{text}
Formatting hook for the name part <namepart>, to be used in all formatting directives for name lists. The default datamodel defines the name parts <family>, <given>, <prefix> and <suffix> and therefore the following macros are automatically defined:

\begin{ltxexample}
\mkbibnamefamily
\mkbibnamegiven
\mkbibnameprefix
\mkbibnamesuffix
\end{ltxexample}

\cmditem{mkbibcompletename<formatorder>}{text}
Formatting hook for the complete name in format order <formatorder>. The default styles use the name format orders <family>, <family-given> and <given-family>, therefore the following macros are automatically defined:

\begin{ltxexample}
\mkbibcompletenamefamily
\mkbibcompletenamefamilygiven
\mkbibcompletenamegivenfamily
\end{ltxexample}
%
These formatting hooks should enclose the complete name in the bibliography macro \cmd{name:<formatorder>}. Initially all hooks expand to \cmd{mkbibcompletename}.

\cmditem{mkbibcompletename}{text}
The initial value of all default formatting hooks \cmd{mkbibcompletename<formatorder>}.

\csitem{datecircadelim}\CSdelimMark
When formatting dates with the global option \opt{datecirca} enabled, the delimiter printed after any localised <circa> term. Defaults to interword space.

\csitem{dateeradelim}\CSdelimMark
When formatting dates with the global option \opt{dateera} set, the delimiter printed before the localisation era term. Defaults to interword space.

\csitem{dateuncertainprint}
Prints date uncertainty information when the global option \opt{dateuncertain} is enabled and the \cmd{ifdateuncertain} test is true. By default, prints the language specific \cmd{bibdateuncertain} string (\secref{use:fmt:lng}).

\csitem{enddateuncertainprint}
Prints date uncertainty information when the global option \opt{dateuncertain} is enabled and the \cmd{ifenddateuncertain} test is true. By default, prints the language specific \cmd{bibdateuncertain} string (\secref{use:fmt:lng}).

\csitem{datecircaprint}
Prints date circa information when the global option \opt{datecirca} is enabled and the \cmd{ifdatecirca} test is true. By default, prints the <circa> localised term (\secref{aut:lng:key:dt}) and the \opt{datecircadelim} delimiter.

\csitem{enddatecircaprint}
Prints date circa information when the global option \opt{datecirca} is enabled and the \cmd{ifenddatecirca} test is true. By default, prints the <circa> localised term (\secref{aut:lng:key:dt}) and the \opt{datecircadelim} delimiter.

\csitem{datecircaprintiso}
Prints \acr{ISO8601-2} format date circa information when the global option \opt{datecirca} is enabled and the \cmd{ifdatecirca} test is true. Prints \cmd{textasciitilde}.

\csitem{enddatecircaprintiso}
Prints \acr{ISO8601-2} format date circa information when the global option \opt{datecirca} is enabled and the \cmd{ifenddatecirca} test is true. Prints \cmd{textasciitilde}.

\csitem{dateeraprint}{yearfield}
Prints date era information when the global option \opt{dateera} is set to <secular> or <christian>. By default, prints the \opt{dateeradelim} delimiter and the appropriate localised era term (\secref{aut:lng:key:dt}). If the \opt{dateeraauto} option is set, then the passed \prm{yearfield} (which is the name of a year field such as <year>, <origyear>, <endeventyear> etc.) is tested to see if its value is earlier than the \opt{dateeraauto} threshold and if so, then the BCE/CE localisation will be output too. The default setting for \opt{dateeraauto} is 0 and so only BCE/BC localisation strings are candidates for output. Detects whether the start or end year era information is to be printed by looking at the \prm{yearfield} name passed to it.

\csitem{dateeraprintpre}
Prints date era information when the global option \opt{dateera} is set to <astronomical>. By default, prints \opt{bibdataeraprefix}. Detects whether the start or end year era information is to be printed by looking at the \prm{yearfield} name passed to it.
\csitem{relatedpunct}
在相关类型参考文献本地化字符串和第一个关联条目数据之间的分隔符。
%The separator between the relatedtype bibliography localisation string and the data from the first related entry.

\csitem{relateddelim}
在多个关联条目数据之间打印的分隔符。默认是断行。
%The separator between the data of multiple related entries. The default definition is a linebreak.

\csitem{relateddelim$<$relatedtype$>$}
在<relatedtype>类型的关联条目中的多个关联条目数据之间打印的分隔符。没有默认设置，如果不指定具体类型的分隔符，则使用\cmd{relateddelim}。
%The separator between the data of multiple related entries inside related entries of type <relatedtype>. There is no default, if such a type-specific delimiter does not exist, \cmd{relateddelim} is used.

\csitem{begrelateddelim}
%The generic separator before the block of related entries. The default definition is \cmd{newunitpunct}.
在关联条目块前面的一般分隔符。默认定义是\cmd{newunitpunct}.

\csitem{begrelateddelim$<$relatedtype$>$}
%The separator between the block of related entries of type <relatedtype>. There is no default, if such a type-specific delimiter does not exist, \cmd{relateddelim} is used.
在<relatedtype>类型关联条目块前面的一般分隔符。无默认定义，当具体类型的定义不存在，则使用\cmd{relateddelim} 。



\end{ltxsyntax}

\subsubsection{具体语言的命令}%Language-specific Commands
\label{aut:fmt:lng}

本节对应用户指南部分的\secref{use:fmt:lng} 节。下面讨论的命令常在本地化模型中处理，但用户可能根据具体的语言重定义。注意，所有的命令以\cmd{mk\dots} 开头，具有一个或更多的必选参数。
%This section corresponds to \secref{use:fmt:lng} in the user part of the manual. The commands discussed here are usually handled by the localisation modules, but may also be redefined by users on a per"=language basis. Note that all commands starting with \cmd{mk\dots} take one or more mandatory arguments.

\begin{ltxsyntax}

\csitem{bibrangedash}

具体语言的范围破折号，默认是\cmd{textendash}。
%The language specific range dash. Defaults to \cmd{textendash}.

\csitem{bibrangessep}

用于多个范围间的具体语言的分隔符。默认是逗号加一个空格。
%The language specific separator to be used between multiple ranges. Defaults to a comma followed by a space.

\csitem{bibdatesep}

简洁日期格式中各日期成分之间使用的具体语言的分隔符。默认是连字符(\cmd{hyphen})。
%The language specific separator used between date components in terse date formats. Defaults to \cmd{hyphen}.

\csitem{bibdaterangesep}

用于日期范围之间的具体语言的分隔符。除了\opt{ymd} 格式默认是\cmd{slash} 外，其它所有日期格式中默认是\cmd{textendash}。\opt{edtf} 选项的日期格式是硬编码(不轻易改变的)为\cmd{slash}，因为这是一种需符合标准的格式。
%The language specific separator to be used for date ranges. Defaults to \cmd{textendash} for all date formats apart from \opt{ymd} which defaults to a \cmd{slash}. The date format option \opt{edtf} is hard-coded to \cmd{slash} since this is a standards compliant format.

\csitem{mkbibdatelong}

取三个域的名作为参数，对应三个日期成分(以year\slash month\slash day的顺序)，并使用这些域的值以具体语言的长日期格式打印日期。
%Takes the names of three field as arguments which correspond to three date components (in the order year\slash month\slash day) and uses their values to print the date in the language specific long date format.

\csitem{mkbibdateshort}

类似于\cmd{mkbibdatelong}，但使用具体语言的短日期格式。
%Similar to \cmd{mkbibdatelong} but using the language specific short date format.

\csitem{mkbibtimezone}

修改作为唯一参数传递进来的时区。默认情况下，修改<Z>为\cmd{bibtimezone} 的值。
%Modifies a timezone string passed in as the only argument. By default this changes <Z> to the value of \cmd{bibtimezone}.

\csitem{bibdateuncertain}

当全局选项\opt{dateuncertain} 启用时，在不确定日期后用的具体语言的标记。默认是一个空格加一个问号。
%The language specific marker to be used after uncertain dates when the global option \opt{dateuncertain} is enabled. Defaults to a space followed by a question mark.


\csitem{bibdateeraprefix}

当\opt{dateera} 设为<astronomical>时，在日期范围中作为起始BCE/BC日期前缀打印的具体语言标记。有定义的话，默认是\cmd{textminus}，否则是\cmd{textendash}。
%The language specific marker which is printed as a prefix to beginning BCE/BC dates in a date range when the option \opt{dateera} is set to <astronomical>. Defaults to \cmd{textminus}, if defined and \cmd{textendash} otherwise.

\csitem{bibdateeraendprefix}

当\opt{dateera} 设为<astronomical>时，在日期范围中作为终点BCE/BC日期前缀打印的具体语言标记。当\cmd{bibdaterangesep} 设置为破折号(dash)时默认是短空格(thin space)，否则是\cmd{bibdateeraprefix}。这是一个独立宏，所以可以在一个负日期标记(比如跟在一个破折号日期范围标记之后的)前添加额外的空格，因为它看起来有点奇特。
%The language specific marker which is printed as a prefix to end BCE/BC dates in a date range when the option \opt{dateera} is set to <astronomical>. Defaults to a thin space followed by \cmd{bibdateeraprefix} when \cmd{bibdaterangesep} is set to a dash and to \cmd{bibdateeraprefix} otherwise.  This is a separate macro so that you may add extra space before a negative date marker which, for example follows a dash date range marker as this can look a little odd.

\csitem{bibtimesep}

分隔时间成分的具体语言标记，默认是分号。
%The language specific marker which separates time components. Default to a colon.

\csitem{bibutctimezone}

UTC时区的具体语言的打印字符串，默认是<Z>。
%The language specific string printed for the UTC timezone. Defaults to <Z>.

\csitem{bibtimezonesep}

分隔时间的可选时区成分的具体语言的标记，默认为空。
%The language specific marker which separates an optional time zone component from a time. Empty by default.

\csitem{bibtzminsep}

The language specific marker which separates hour and minute component of offset timezones. Defaults to a \cmd{bibtimesep}.
\csitem{bibdatetimesep}

当时间和日期同时打印时分隔时间成分和日期成分的具体语言的分隔符。(见\secref{use:opt:pre:gen} 节的\opt{$<$datetype$>$dateusetime} 选项)。默认是一个空格对于non-EDTF输出格式，对于EDTF输出格式则是'T'。
The language specific separator printed between date and time components when printing time components along with date components (see the \opt{$<$datetype$>$dateusetime} option in \secref{use:opt:pre:gen}). Defaults to a space for non-\acr{ISO8601-2} output formats, and 'T' for \acr{ISO8601-2} output format.

\csitem{finalandcomma}

在枚举中最后的<and>前插入的逗号，如果可以用于具体的语言。
%Prints the comma to be inserted before the final <and> in an enumeration, if applicable in the respective language.

\csitem{finalandsemicolon}

在枚举中最后的<and>前插入的分号，如果可以用于具体的语言。
%Prints the semicolon to be inserted before the final <and> in an enumeration, if applicable in the respective language.

\cmditem{mkbibordinal}{integer}

取一个整数参数并打印成一般数字。
%Takes an integer argument and prints it as an ordinal number.

\cmditem{mkbibmascord}{integer}

类似于\cmd{mkbibordinal}，但打印一个男性用的序号，如果可以用于具体的语言。
%Similar to \cmd{mkbibordinal}, but prints a masculine ordinal, if applicable in the respective language.

\cmditem{mkbibfemord}{integer}

类似于\cmd{mkbibordinal}，但打印一个女性用的序号，如果可以用于具体的语言。
%Similar to \cmd{mkbibordinal}, but prints a feminine ordinal, if applicable in the respective language.

\cmditem{mkbibneutord}{integer}

类似于\cmd{mkbibordinal}，但打印一个中性用的序号，如果可以用于具体的语言。
%Similar to \cmd{mkbibordinal}, but prints a neuter ordinal, if applicable in the respective language.

\cmditem{mkbibordedition}{integer}

类似于\cmd{mkbibordinal}，但与术语<edition>连用。
%Similar to \cmd{mkbibordinal}, but intended for use with the term <edition>.

\cmditem{mkbibordseries}{integer}

类似于\cmd{mkbibordinal}，但与术语<series>连用。
%Similar to \cmd{mkbibordinal}, but intended for use with the term <series>.

\end{ltxsyntax}

\subsubsection{用户可定义的长度和计数器}%User-definable Lengths and Counters
\label{aut:fmt:len}

本节对应用户指南部分的\secref{use:fmt:len} 节。下面讨论的长度和计数器用户可以修改。著录和标注样式需要的时候应该使用它们，也可以提供不同于biblatex包提供的默认设置
%This section corresponds to \secref{use:fmt:len} in the user part of the manual. The length registers and counters discussed here are meant to be altered by users. Bibliography and citation styles should incorporate them where applicable and may also provide a default setting which is different from the package default.

\begin{ltxsyntax}

\lenitem{bibhang}

如果用的话，是参考文献表的悬挂缩进。该长度在加载时初始化为\cmd{parindent}。如果\cmd{parindent} 因为某些原因设置为0，\cmd{bibhang} 将默认为\texttt{1em}。
%The hanging indentation of the bibliography, if applicable. This length is initialized to \cmd{parindent} at load-time. If \cmd{parindent} is zero length for some reason, \cmd{bibhang} will default to \texttt{1em}.

\lenitem{biblabelsep}

条目和对应标签之间的水平间距。使用\env{list} 环境并打印标签的参考文献样式应在环境定义中设置\len{labelsep} 为\len{biblabelsep}。
%The horizontal space between entries and their corresponding labels. Bibliography styles which use \env{list} environments and print a label should set \len{labelsep} to \len{biblabelsep} in the definition of the respective environment.

\lenitem{bibitemsep}

文献表中各条目间的垂直间距。使用\env{list} 环境的参考文献样式应在环境定义中设置\len{itemsep} 为\len{bibitemsep}。
%The vertical space between the individual entries in the bibliography. Bibliography styles using \env{list} environments should set \len{itemsep} to \len{bibitemsep} in the definition of the respective environment.

This length is initialized to \cmd{itemsep} at load-time.

\lenitem{bibnamesep}

Vertical space to be inserted between two entries in the bibliography whenever an entry starts with a name which is different from the initial name of the previous entry. The default value is zero. Setting this length to a positive value greater than \len{bibitemsep} will group the bibliography by author\slash editor name. Note that \len{bibitemsep}, \len{bibnamesep}, and \len{bibinitsep} obey the rules for \cmd{addvspace}, that is, when vertical space introduced by any of these commands immediately follows on from space introduced by another of them, the resulting total space is equal to the largest of them.

\lenitem{bibinitsep}

Vertical space to be inserted between two entries in the bibliography whenever an entry starts with a letter which is different from the initial letter of the previous entry. The default value is zero. Setting this length to a positive value greater than \len{bibitemsep} will group the bibliography alphabetically. Note that \len{bibitemsep}, \len{bibnamesep}, and \len{bibinitsep} obey the rules for \cmd{addvspace}, that is, when vertical space introduced by any of these commands immediately follows on from space introduced by another of them, the resulting total space is equal to the largest of them.
\lenitem{bibparsep}

文献表中条目内段落间的垂直间距。使用\env{list} 环境的参考文献样式应在环境定义中设置\len{parsep} 为\len{bibparsep}。
%The vertical space between paragraphs within an entry in the bibliography. Bibliography styles using \env{list} environments should set \len{parsep} to \len{bibparsep} in the definition of the respective environment.

\cntitem{abbrvpenalty}

用于\cmd{addabbrvspace}, \cmd{addabthinspace} 和\cmd{adddotspace} 的阀值，详见\secref{aut:pct:spc} 节。
%The penalty used by \cmd{addabbrvspace}, \cmd{addabthinspace}, and \cmd{adddotspace}, see \secref{aut:pct:spc} for details.

\cntitem{highnamepenalty}

用于\cmd{addhighpenspace} 和\cmd{addhpthinspace} 的阀值，详见\secref{aut:pct:spc} 节。
%The penalty used by \cmd{addhighpenspace} and \cmd{addhpthinspace}, see \secref{aut:pct:spc} for details.


\cntitem{lownamepenalty}

用于\cmd{addlowpenspace} 和\cmd{addlpthinspace} 的阀值，详见\secref{aut:pct:spc} 节。
%The penalty used by \cmd{addlowpenspace} and \cmd{addlpthinspace}, see \secref{aut:pct:spc} for details.



\cntitem{biburlbigbreakpenalty}

The \sty{biblatex} version of \sty{url}'s \len{UrlBigBreakPenalty}. The default value is \texttt{100}.

\cntitem{biburlbreakpenalty}

The \sty{biblatex} version of \sty{url}'s \len{UrlBreakPenalty}. The default value is \texttt{200}.

\cntitem{biburlnumpenalty}

如果该计数器设置为大于0的值，\biblatex 将允许在以\sty{url} 包的\cmd{url} 命令格式化的所有字符串中允许数字后面的断行。这将影响文献表中的\acr{url}s和\acr{doi}s。断行点阀值将由该计数器的值确定。如果文献表中的\acr{url}s and/or \acr{doi}s超出到页边中，尽可能设置该计数器值大于0但小于10000(通常需要使用一个大值如9000)。设置该计数器为0将关闭该功能。这是默认设置。\footnote{译者: url、doi超出页边时往往需要用到。}
%If this counter is set to a value greater than zero, \biblatex will permit linebreaks after numbers in all strings formatted with the \cmd{url} command from the \sty{url} package. This will affect \acr{url}s and \acr{doi}s in the bibliography. The breakpoints will be penalized by the value of this counter. If \acr{url}s and/or \acr{doi}s in the bibliography run into the margin, try setting this counter to a value greater than zero but less than 10000 (you normally want to use a high value like 9000). Setting the counter to zero disables this feature. This is the default setting.

\cntitem{biburlucpenalty}

类似于\cnt{biburlnumpenalty}，差别在于它将会在所有大写字母后面添加断点。
%Similar to \cnt{biburlnumpenalty}, except that it will add a breakpoint after all uppercase letters.

\cntitem{biburllcpenalty}

类似于\cnt{biburlnumpenalty}，差别在于它将会在所有小写字母后面添加断点。
%Similar to \cnt{biburlnumpenalty}, except that it will add a breakpoint after all lowercase letters.

\lenitem{biburlbigskip}

The \sty{biblatex} version of \len{Urlmuskip}. This length holds the additional (stretchable) space inserted around breakable characters in the \cmd{url} command from the \sty{url} package. The default value is \texttt{0mu plus 3mu}.

\lenitem{biburlnumskip}

The additional space inserted after numbers in strings formatted with the \cmd{url} command from the \sty{url} package. This will affect \acr{url}s and \acr{doi}s in the bibliography. If \acr{url}s and/or \acr{doi}s in the bibliography run into the margin, it may help to set this length to add some small stretchable space, for example \texttt{0mu plus 1mu}. The default setting is \texttt{0mu}. This value is only used if \cnt{biburlnumpenalty} is set to a value different from zero.

\lenitem{biburlucskip}

Similar to \cnt{biburlnumskip}, except that it will add space after all uppercase letters.

\lenitem{biburllcskip}

Similar to \cnt{biburlnumskip}, except that it will add space after all uppercase letters.
\end{ltxsyntax}

\subsubsection{辅助命令和钩子}%Auxiliary Commands and Hooks
\label{aut:fmt:ich}

本节的辅助命令和钩子具有特殊用途。从某种意义上说，其中一些用于\biblatex 与著录和标注样式之间的通信。
%The auxiliary commands and facilities in this section serve a special purpose. Some of them are used by \biblatex to communicate with bibliography and citation styles in some way or other.

\begin{ltxsyntax}

\cmditem{mkbibemph}{text}

通用命令将其参数打印为强调的文本内容。这是一个包围标准\cmd{emph} 命令的简单封套。除此之外，它使用\secref{aut:pct:new} 节的\cmd{setpunctfont} 来调整紧接在设为斜体的文本后的标点符号的字体。如果\opt{punctfont} 包选项未启用，该命令作用同\cmd{emph}。
%A generic command which prints its argument as emphasized text. This is a simple wrapper around the standard \cmd{emph} command. Apart from that, it uses \cmd{setpunctfont} from \secref{aut:pct:new} to adapt the font of the next punctuation mark following the text set in italics. If the \opt{punctfont} package option is disabled, this command behaves like \cmd{emph}.

\cmditem{mkbibitalic}{text}

类似于\cmd{mkbibemph} 的概念，但打印斜体文本。这是在一个标准\cmd{textit} 命令的简单封套，其中包含\cmd{setpunctfont} 命令。如果\opt{punctfont} 包选项未启用，该命令作用同\cmd{textit}。
%Similar in concept to \cmd{mkbibemph} but prints italicized text. This is a simple wrapper around the standard \cmd{textit} command which incorporates \cmd{setpunctfont}. If the \opt{punctfont} package option is disabled, this command behaves like \cmd{textit}.

\cmditem{mkbibbold}{text}

类似于\cmd{mkbibemph} 的概念，但打印斜体文本。这是在一个标准\cmd{textbf} 命令的简单封装，其中包含\cmd{setpunctfont} 命令。如果\opt{punctfont} 包选项未启用，该命令作用同\cmd{textbf}。
%Similar in concept to \cmd{mkbibemph} but prints bold text. This is a simple wrapper around the standard \cmd{textbf} command which incorporates \cmd{setpunctfont}. If the \opt{punctfont} package option is disabled, this command behaves like \cmd{textbf}.

\cmditem{mkbibquote}{text}

将其参数用引号包围起来的通用命令。如果加载了\sty{csquotes} 包，该命令使用该包提供的具体语言的引号。\cmd{mkbibquote} 也支持<American-style>的标点，详见\secref{aut:pct:cfg} 节的\cmd{DeclareQuotePunctuation} 命令。
%A generic command which wraps its argument in quotation marks. If the \sty{csquotes} package is loaded, this command uses the language sensitive quotation marks provided by that package. \cmd{mkbibquote} also supports <American-style> punctuation, see \cmd{DeclareQuotePunctuation} in \secref{aut:pct:cfg} for details.

\cmditem{mkbibparens}{text}

将其参数用圆括号包围起来的通用命令。该命令可以嵌套。当嵌套时，它将根据嵌套的层级交替使用圆括号和方括号。
%A generic command which wraps its argument in parentheses. This command is nestable. When nested, it will alternate between parentheses and brackets, depending on the nesting level.

\cmditem{mkbibbrackets}{text}

将其参数用方括号包围起来的通用命令。该命令可以嵌套。当嵌套时，它将根据嵌套的层级交替使用圆括号和方括号。
%A generic command which wraps its argument in square brackets. This command is nestable. When nested, it will alternate between brackets and parentheses, depending on the nesting level.

\cmditem{bibopenparen}<text>|{\ltxsyntaxlabelfont\cmd{bibcloseparen}}|

\cmd{mkbibparens} 命令的替代语法。这能跨编组使用。注意 \cmd{bibopenparen} 和 \cmd{bibcloseparen} 必须配套使用。
%Alternative syntax for \cmd{mkbibparens}. This will also work across groups. Note that \cmd{bibopenparen} and \cmd{bibcloseparen} must always be balanced.

\cmditem{bibopenbracket}<text>|{\ltxsyntaxlabelfont\cmd{bibclosebracket}}|

\cmd{mkbibbrackets} 命令的替代语法。这能跨编组使用。注意 \cmd{bibopenbracket} 和 \cmd{bibclosebracket} 必须配套使用。
%Alternative syntax for \cmd{mkbibbrackets}. This will also work across groups. Note that \cmd{bibopenbracket} and \cmd{bibclosebracket} must always be balanced.

\cmditem{mkbibfootnote}{text}

将其参数作为脚注的通用命令。它是标准\latex \cmd{footnote} 命令的封套，并能消除脚注标记前的多余空格，阻止嵌套脚注。默认情况下，\cmd{mkbibfootnote} 需要在脚注内容开始时大写并在结束时自动添加一个句号。可以重定义下面介绍的\cmd{bibfootnotewrapper} 宏来修改其作用。
%A generic command which prints its argument as a footnote. This is a wrapper around the standard \latex \cmd{footnote} command which removes spurious whitespace preceding the footnote mark and prevents nested footnotes. By default, \cmd{mkbibfootnote} requests capitalization at the beginning of the note and automatically adds a period at the end. You may change this behavior by redefining the \cmd{bibfootnotewrapper} macro introduced below.

\cmditem{mkbibfootnotetext}{text}

类似于\cmd{mkbibfootnote}，但使用\cmd{footnotetext} 命令。
%Similar to \cmd{mkbibfootnote} but uses the \cmd{footnotetext} command.

\cmditem{mkbibendnote}{text}

类似于\cmd{mkbibfootnote} 的概念，但将其参数打印为尾注。\cmd{mkbibendnote} 能消除尾注标记前的多余空格，并阻止嵌套。它支持由\sty{endnotes} 包提供的\cmd{endnote} 命令和\sty{pagenote} 包和\sty{memoir} 类提供的\cmd{pagenote} 命令。如果两个命令都可用，
\cmd{endnote} 优先。如果没有可用的尾注命令，\cmd{mkbibendnote} 将报错并回退为\cmd{footnote}。默认情况下，\cmd{mkbibendnote} 需要在尾注内容开始时大写并在结束时自动添加一个句号。可以重定义下面介绍的\cmd{bibfootnotewrapper} 宏来修改其作用。
%Similar in concept to \cmd{mkbibfootnote} except that it prints its argument as an endnote. \cmd{mkbibendnote} removes spurious whitespace preceding the endnote mark and prevents nested notes. It supports the \cmd{endnote} command provided by the \sty{endnotes} package as well as the \cmd{pagenote} command provided by the \sty{pagenote} package and the \sty{memoir} class. If both commands are available, \cmd{endnote} takes precedence. If no endnote support is available, \cmd{mkbibendnote} issues an error and falls back to \cmd{footnote}. By default, \cmd{mkbibendnote} requests capitalization at the beginning of the note and automatically adds a period at the end. You may change this behavior by redefining the \cmd{bibendnotewrapper} macro introduced below.

\cmditem{mkbibendnotetext}{text}

类似于\cmd{mkbibendnote}，但使用\cmd{endnotetext} 命令。请注意，对于这种写法，\sty{pagenote} 包和\sty{memoir} 都不提供相应的\cmd{pagenotetext} 命令。这种情况下，\cmd{mkbibendnote} 将报错并回退为\cmd{footnotetext}。
%Similar to \cmd{mkbibendnote} but uses the \cmd{endnotetext} command. Please note that as of this writing, neither the \sty{pagenote} package nor the \sty{memoir} class provide a corresponding \cmd{pagenotetext} command. In this case, \cmd{mkbibendnote} will issue an error and fall back to \cmd{footnotetext}.

\cmditem{bibfootnotewrapper}{text}

一个内部封套，将 \cmd{mkbibfootnote} 和 \cmd{mkbibfootnotetext} 命令的\prm{text} 参数包围起来。例如，\cmd{mkbibfootnote} 最终归结为:
%An inner wrapper which encloses the \prm{text} argument of \cmd{mkbibfootnote} and \cmd{mkbibfootnotetext}. For example, \cmd{mkbibfootnote} eventually boils down to this:

\begin{ltxexample}
\footnote{<<\bibfootnotewrapper{>>text<<}>>}
\end{ltxexample}
%
该封套确保注文内容开始时大写并在结束时自动添加一个句号，默认定义为:
%The wrapper ensures capitalization at the beginning of the note and adds a period at the end. The default definition is:

\begin{ltxexample}
\newcommand{\bibfootnotewrapper}[1]{<<\bibsentence>> #1<<\addperiod>>}
\end{ltxexample}
%
如果不想大写首字母或者在注文尾部添加句号，不修改\cmd{mkbibfootnote}，而要重定义\cmd{bibfootnotewrapper}。
%If you don't want capitalization at the beginning or a period at the end of the note, do not modify \cmd{mkbibfootnote} but redefine \cmd{bibfootnotewrapper} instead.

\cmditem{bibendnotewrapper}{text}

类似于\cmd{bibfootnotewrapper} 的概念，但对应于\cmd{mkbibendnote} 和\cmd{mkbibendnotetext} 命令。
%Similar in concept to \cmd{bibfootnotewrapper} but related to the \cmd{mkbibendnote} and \cmd{mkbibendnotetext} commands.

\cmditem{mkbibsuperscript}{text}

一个将参数转换成上标的通用命令。它是标准\latex \cmd{textsuperscript} 命令的封套，并能消除多余空格，允许前面的单词使用连字符。
%A generic command which prints its argument as superscripted text. This is a simple wrapper around the standard \latex \cmd{textsuperscript} command which removes spurious whitespace and allows hyphenation of the preceding word.

\cmditem{mkbibmonth}{integer}

该命令根据其整数参数打印月份名。尽管该命令的输出与具体语言相关，但它的定义不是，因此在本地化模型中通常不重定义。
%This command takes an integer argument and prints it as a month name. Even though the output of this command is language specific, its definition is not, hence it is normally not redefined in localisation modules.

\cmditem{mkbibseason}{string}

该命令根据季节本地化字符串打印与包选项\opt{dateabbrev} 对应版本的字符串。尽管该命令的输出与具体语言相关，但其定义并非如此，因此一般情况下不用在本地化模型中重定义。
%This command takes a season localisation string and prints the version of the string corresponding to the setting of the \opt{dateabbrev} package option. Even though the output of this command is language specific, its definition is not, hence it is normally not redefined in localisation modules.

\cmditem{mkyearzeros}{integer}

该命令根据\opt{datezeros} 包选项(\secref{use:opt:pre:gen})设置移除或增添年份的前导零串。用于在日期格式化宏的定义中。
%This command strips leading zeros from a year or enforces them, depending on the \opt{datezeros} package option (\secref{use:opt:pre:gen}). It is intended for use in the definition of date formatting macros.
If zeros are enforced, this command calls \cmd{forcezerosy} and thus expands its argument with \cmd{protected@edef}.
\cmditem{mkmonthzeros}{integer}

该命令根据\opt{datezeros} 包选项(\secref{use:opt:pre:gen})设置移除或增添月份的前导零串。用于在日期格式化宏的定义中。
%This command strips leading zeros from a month or enforces them, depending on the \opt{datezeros} package option (\secref{use:opt:pre:gen}). It is intended for use in the definition of date formatting macros.
 If zeros are enforced, this command calls \cmd{forcezerosmdt} and thus expands its argument with \cmd{protected@edef}.
\cmditem{mkdayzeros}{integer}

该命令根据\opt{datezeros} 包选项(\secref{use:opt:pre:gen})设置移除或增添日的前导零串。用于在日期格式化宏的定义中。
%This command strips leading zeros from a day or enforces them, depending on the \opt{datezeros} package option (\secref{use:opt:pre:gen}). It is intended for use in the definition of date formatting macros.
 If zeros are enforced, this command calls \cmd{forcezerosmdt} and thus expands its argument with \cmd{protected@edef}.
\cmditem{mktimezeros}{integer}

该命令根据\opt{timezeros} 包选项(\secref{use:opt:pre:gen})设置移除或增添时间的前导零串。用于在日期格式化宏的定义中。
%This command strips leading zeros from a number or preserves them, depending on the \opt{timezeros} package option (\secref{use:opt:pre:gen}). It is intended for use in the definition of time formatting macros.
 If zeros are enforced, this command calls \cmd{forcezerosmdt} and thus expands its argument with \cmd{protected@edef}.
\cmditem{forcezerosy}{integer}

该命令将零串添加到年份中(或者任何4位数的数字中)。用于日期格式化和序数中。
%This command adds zeros to a year (or any number supposed to be 4-digits). It is intended for date formatting and ordinals.
 If zeros are enforced, this command calls \cmd{forcezerosmdt} and thus expands its argument with \cmd{protected@edef}.
\cmditem{forcezerosmdt}{integer}

该命令将零串添加到月份、日或时间成分中(或者任何2位数的数字中)。用于日期/时间格式化和序数中。
%This command adds zeros to a month, day or time part (or any number supposed to be 2-digits). It is intended for date/time formatting and ordinals.
 If zeros are enforced, this command calls \cmd{forcezerosmdt} and thus expands its argument with \cmd{protected@edef}.
\cmditem{stripzeros}{integer}

该命令移除数字中的前导零串。用于日期格式化和序数中。
%This command strips leading zeros from a number. It is intended for date formatting and ordinals.

\optitem{$<$labelfield$>$width}

对于数据模型中任何标记为<Label field>的域，根据上述的\texttt{shorthandwidth} 自动创建一个格式化指令。因为默认的数据模型中\bibfield{shorthand} 就是如此标记的，所以该功能是\texttt{shorthandwidth} 功能的父集。
%For every field marked as a <Label field> in the data model, a formatting directive is created as per \texttt{shorthandwidth} above. Since \bibfield{shorthand} is so marked in the default data model, this functionality is a superset of that described for \texttt{shorthandwidth}.

\optitem{labelnumberwidth}

类似于\texttt{shorthandwidth}，但指的是\bibfield{labelnumber} 域和长度\cmd{labelnumberwidth}。顺序编码样式应该调整该指令以便与参考文献表中应用的格式一致。
%Similar to \texttt{shorthandwidth}, but referring to the \bibfield{labelnumber} field and the length register \cmd{labelnumberwidth}. Numeric styles should adjust this directive such that it corresponds to the format used in the bibliography.

\optitem{labelalphawidth}

类似于\texttt{shorthandwidth}，但指的是\bibfield{labelalpha} 域和长度\cmd{labelalphawidth}。字母顺序样式应该调整该指令以便与参考文献表中应用的格式一致。\footnote{译者:注意这个命令和上一个命令的差别，Alphabetic和Numeric样式的差别}
%Similar to \texttt{shorthandwidth}, but referring to the \bibfield{labelalpha} field and the length register \cmd{labelalphawidth}. Alphabetic styles should adjust this directive such that it corresponds to the format used in the bibliography.

\optitem{bibhyperref}

与\cmd{printfield} 和\cmd{printtext} 配合使用的一个特殊格式化指令。该指令将其参数包含在\cmd{bibhyperref} 命令中，详见\secref{aut:aux:msc}。
%A special formatting directive for use with \cmd{printfield} and \cmd{printtext}. This directive wraps its argument in a \cmd{bibhyperref} command, see \secref{aut:aux:msc} for details.

\optitem{bibhyperlink}

与\cmd{printfield} 和\cmd{printtext} 配合使用的一个特殊格式化指令。该指令将其参数包含在\cmd{bibhyperlink} 命令中，详见\secref{aut:aux:msc}。\prm{name} 传递给\cmd{bibhyperlink} 命令的是\bibfield{entrykey} 域的值。
%A special formatting directive for use with \cmd{printfield} and \cmd{printtext}. It wraps its argument in a \cmd{bibhyperlink} command, see \secref{aut:aux:msc} for details. The \prm{name} argument passed to \cmd{bibhyperlink} is the value of the \bibfield{entrykey} field.

\optitem{bibhypertarget}

与\cmd{printfield} 和\cmd{printtext} 配合使用的一个特殊格式化指令。该指令将其参数包含在\cmd{bibhypertarget} 命令中，详见\secref{aut:aux:msc}。\prm{name} 传递给\cmd{bibhypertarget} 命令的是\bibfield{entrykey} 域的值。
%A special formatting directive for use with \cmd{printfield} and \cmd{printtext}. It wraps its argument in a \cmd{bibhypertarget} command, see \secref{aut:aux:msc} for details. The \prm{name} argument passed to \cmd{bibhypertarget} is the value of the \bibfield{entrykey} field.

\optitem{volcitepages}

控制类似\cmd{volcite} 等标注命令参数中的页码或文本部分格式的一个特殊格式化指令。
%A special formatting directive which controls the format of the page\slash text portion in the argument of citation commands like \cmd{volcite}.

\optitem{volcitevolume}

控制类似\cmd{volcite} 等标注命令参数中的卷部分格式的一个特殊格式化指令。
%A special formatting directive which controls the format of the volume portion in the argument of citation commands like \cmd{volcite}.

\optitem{date}

控制\cmd{printdate} 格式的一个特殊格式化指令(\secref{aut:bib:dat})。注意，日期格式(long/short等) 由\secref{use:opt:pre:gen} 节的包选项\opt{date} 控制。该格式化指令仅控制如字体等额外的格式。
%A special formatting directive which controls the format of \cmd{printdate} (\secref{aut:bib:dat}). Note that the date format (long/short etc.) is controlled by the package option \opt{date} from \secref{use:opt:pre:gen}. This formatting directive only controls additional formatting such as fonts etc.

\optitem{labeldate}

类似于\texttt{date}，当控制\cmd{printlabeldate} 的格式。
%As \texttt{date} but controls the format of \cmd{printlabeldate}.

\optitem{$<$datetype$>$date}

类似于\texttt{date}，当控制\cmd{print$<$datetype$>$date} 的格式。
As \texttt{date} but controls the format of \cmd{print$<$datetype$>$date}.

\optitem{time}

控制\cmd{printtime} (\secref{aut:bib:dat})格式的一个特殊格式化指令。注意:时间格式(24h/12h 等)由\secref{use:opt:pre:gen} 节的包选项\opt{time} 控制。该格式化指令仅控制如字体等额外的格式。
%A special formatting directive which controls the format of \cmd{printtime} (\secref{aut:bib:dat}). Note that the time format (24h/12h etc.) is controlled by the package option \opt{time} from \secref{use:opt:pre:gen}. This formatting directive only controls additional formatting such as fonts etc.

\optitem{labeltime}

类似于\texttt{time}，但控制\cmd{printlabeltime} 的格式。
%As \texttt{time} but controls the format of \cmd{printlabeltime}.

\optitem{$<$datetype$>$time}

类似于\texttt{time}，但控制\cmd{print$<$datetype$>$time} 的格式。
As \texttt{time} but controls the format of \cmd{print$<$datetype$>$time}.

\end{ltxsyntax}

\subsubsection{辅助长度、计数器和其它功能}% Auxiliary Lengths, Counters, and Other Features
\label{aut:fmt:ilc}
这里讨论的长度和计数器用于在\biblatex 中项著录和标注样式传递信息。可以将它们认为是只读的(read"=only)。注意:所有的计数器都是\latex 计数器。使用|\value{counter}|来读取当前值。
%The length registers and counters discussed here are used by \biblatex to pass information to bibliography and citation styles. Think of them as read"=only registers. Note that all counters are \latex counters. Use |\value{counter}| to read out the current value.

\begin{ltxsyntax}

\lenitem{$<$labelfield$>$width}

对于数据模型中任何标记为<label>的域，根据上述的\texttt{shorthandwidth} 自动创建一个长度。因为\bibfield{shorthand} 在默认数据模型中就是如此标记的，所以该功能是\texttt{shorthandwidth} 描述功能的父集。
%For every field marked as a <label> field in the data model, a length register is created as per \texttt{shorthandwidth} above. Since \bibfield{shorthand} is so marked in the default data model, this functionality is a superset of that described for \texttt{shorthandwidth}.

\lenitem{labelnumberwidth}

表示最宽\bibfield{labelnumber} 的长度。顺序编码著录样式应在参考文献表环境的定义中考虑该长度。
%This length register indicates the width of the widest \bibfield{labelnumber}. Numeric bibliography styles
%should incorporate this length in the definition of the bibliography environment.

\lenitem{labelalphawidth}

表示最宽\bibfield{labelalpha} 的长度。字母顺序编码著录样式应在参考文献表环境的定义中考虑该长度。
%This length register indicates the width of the widest \bibfield{labelalpha}. Alphabetic bibliography styles should incorporate this length in the definition of the bibliography environment.

\cntitem{maxextraalpha}

该计数器保存在\bibfield{extraalpha} 域中能找到的最大数值。
%This counter holds the highest number found in any \bibfield{extraalpha} field.

\cntitem{maxextradate}

该计数器保存在\bibfield{extradate} 域中能找到的最大数值。
%This counter holds the highest number found in any \bibfield{extradate} field.

\cntitem{maxextraname}

%This counter holds the highest number found in any \bibfield{extraname} field.
该计数器保存任意\bibfield{extraname}域中保存的最大值。

\cntitem{maxextratitle}

%This counter holds the highest number found in any \bibfield{extratitle} field.
该计数器保存任意\bibfield{extratitle}域中保存的最大值。

\cntitem{maxextratitleyear}

%This counter holds the highest number found in any \bibfield{extratitleyear} field.
该计数器保存任意\bibfield{extratitleyear}域中保存的最大值。

\cntitem{refsection}

该计数器表示当前的\env{refsection} 环境。当在一个文献列表标题中请求时，该计数器返回传递给\cmd{printbibliography} 命令的\opt{refsection} 选项的值。
%This counter indicates the current \env{refsection} environment. When queried in a bibliography heading, the counter returns the value of the \opt{refsection} option passed to \cmd{printbibliography}.

\cntitem{refsegment}

该计数器表示当前的\env{refsegment} 环境。当在一个文献列表标题中请求时，该计数器返回传递给\cmd{printbibliography} 命令的\opt{refsegment} 选项的值。
%This counter indicates the current \env{refsegment} environment. When queried in a bibliography heading, this counter returns the value of the \opt{refsegment} option passed to \cmd{printbibliography}.

\cntitem{maxnames}

该计数器保存\opt{maxnames} 包选项的设置。
%This counter holds the setting of the \opt{maxnames} package option.

\cntitem{minnames}

该计数器保存\opt{minnames} 包选项的设置。
%This counter holds the setting of the \opt{minnames} package option.

\cntitem{maxitems}

该计数器保存\opt{maxitems} 包选项的设置。
%This counter holds the setting of the \opt{maxitems} package option.

\cntitem{minitems}

该计数器保存\opt{minitems} 包选项的设置。
%This counter holds the setting of the \opt{minitems} package option.

\cntitem{instcount}

该计数器由\biblatex 根据每个出现的引用自动增加，在文献列表中则根据出现的条目自动增加。该计数器的值唯一的确定文档中一篇文献对象。\footnote{译者:a single instance of a reference in the document}
%This counter is incremented by \biblatex for every citation as well as for every entry in the bibliography and bibliography lists. The value of this counter uniquely identifies a single instance of a reference in the document.

\cntitem{citetotal}

该计数器，仅在\cmd{DeclareCiteCommand} 定义的标注命令的\prm{loopcode} 中提供，用于保存传递给标注命令的有效条目关键词总数。
%This counter, which is only available in the \prm{loopcode} of a citation command defined with \cmd{DeclareCiteCommand}, holds the total number of valid entry keys passed to the citation command.

\cntitem{citecount}

该计数器，仅在\cmd{DeclareCiteCommand} 定义的标注命令的\prm{loopcode} 中提供，用于保存\prm{loopcode} 正在处理的条目的序号。
%This counter, which is only available in the \prm{loopcode} of a citation command defined with \cmd{DeclareCiteCommand}, holds the number of the entry key currently being processed by the \prm{loopcode}.

\cntitem{multicitetotal}

该命令类似于\cnt{citetotal}，但仅在multicite类命令中提供。它保存传递给multicite类命令的标注命令总数。注意，其包含的各个标注命令可能包含多于一个条目关键词。这一信息由\cnt{citetotal} 计数器提供。
%This counter is similar to \cnt{citetotal} but only available in multicite commands. It holds the total number of citations passed to the multicite command. Note that each of these citations may consist of more than one entry key. This information is provided by the \cnt{citetotal} counter.

\cntitem{multicitecount}

该命令类似于\cnt{citecount}，但仅在multicite类命令中提供。它保存正在处理的标注命令序号。注意，其包含的各个标注命令可能包含多于一个条目关键词。这一信息由\cnt{citetotal} 和\cnt{citecount} 计数器提供。
%This counter is similar to \cnt{citecount} but only available in multicite commands. It holds the number of the citation currently being processed. Note that this citation may consist of more than one entry key. This information is provided by the \cnt{citetotal} and \cnt{citecount} counters.

\cntitem{listtotal}

该计数器保存当前列表中项的总数。用于列表的格式化指令中，在其它任何地方使用时不保存一个有意义的数值。作为一个特例，它可能用在\cmd{printnames} 和\cmd{printlist} 命令的第二个参数中，详见\secref{aut:bib:dat}。对于每个列表，都有一个与其名称相同的计数器用于保存相应列表的项的总数。例如，\cnt{author} 计数器保存了\bibfield{author} 列表中的项的总数。无论姓名列表还是文本列表都是如此。这些计数器有点类似\cnt{listtotal}，差别在于他们可以用于列表格式化命令外独立使用。例如，一个参考文献著录样式可能会检查\cnt{editor} 计数器来决定是否在编者列表之后打印术语«editor»或者其复数形式«editors»
%This counter holds the total number of items in the current list. It is intended for use in list formatting directives and does not hold a meaningful value when used anywhere else. As an exception, it may also be used in the second optional argument to \cmd{printnames} and \cmd{printlist}, see \secref{aut:bib:dat} for details. For every list, there is also a counter by the same name which holds the total number of items in the corresponding list. For example, the \cnt{author} counter holds the total number of items in the \bibfield{author} list. This applies to both name lists and literal lists. These counters are similar to \cnt{listtotal} except that they may also be used independently of list formatting directives. For example, a bibliography style might check the \cnt{editor} counter to decide Whether or not to print the term «editor» or rather its plural form «editors» after the list of editors.

\cntitem{listcount}

该计数器保存列表当前正在处理的项的序号。用于列表格式化指令，在其它任何地方使用无意义。
%This counter holds the number of the list item currently being processed. It is intended for use in list formatting directives and does not hold a meaningful value when used anywhere else.

\cntitem{liststart}

该计数器保存传递给\cmd{printnames} 和\cmd{printlist} 命令的\prm{start} 参数。用于列表格式化指令，在其它任何地方使用无意义。
%This counter holds the \prm{start} argument passed to \cmd{printnames} or \cmd{printlist}. It is intended for use in list formatting directives and does not hold a meaningful value when used anywhere else.

\cntitem{liststop}

该计数器保存传递给\cmd{printnames} 和\cmd{printlist} 命令的\prm{stop} 参数。用于列表格式化指令，在其它任何地方使用无意义。
%This counter holds the \prm{stop} argument passed to \cmd{printnames} or \cmd{printlist}. It is intended for use in list formatting directives and does not hold a meaningful value when used anywhere else.

\csitem{currentlang}

\biblatex 中当前活动语言的名称。可以用于任何地方，默认为文档主体语言。它能在定义\bibfield{langid} 的条目内部自动转换，如果\opt{autolang} 和\opt{language} 选项设置合适的话。注意，它不能追踪文档中所有的语言改变，仅用于当前的\biblatex\ 设置。
%The name of the currently active language for \biblatex. Can be used anywhere and
%defaults to the main document language. This is automatically switched
%inside entries which define \bibfield{langid}, given suitable settings of the
%\opt{autolang} and \opt{language} options. Note that this does not track
%all document language changes, only the current \biblatex\ setting.

\csitem{currentfield}

\cmd{printfield} 命令正在处理的域的名称。这一信息仅在局部的域格式化指令中提供。
%The name of the field currently being processed by \cmd{printfield}. This information is only available locally in field formatting directives.

\csitem{currentlist}

\cmd{printlist} 命令正在处理的文本列表的名称。这一信息仅在局部的域格式化指令中提供。
%The name of the literal list currently being processed by \cmd{printlist}. This information is only available locally in list formatting directives.

\csitem{currentname}

\cmd{printnames} 命令正在处理的姓名列表的名称。这一信息仅在局部的域格式化指令中提供。
%The name of the name list currently being processed by \cmd{printnames}. This information is only available locally in name formatting directives.

\end{ltxsyntax}

\subsubsection{多用途钩子}% General Purpose Hooks
\label{aut:fmt:hok}

\begin{ltxsyntax}

\cmditem{AtBeginBibliography}{code}

向在打印文献表开始时执行的内部钩子添加\prm{code}。\prm{code} 在引文列表开始处执行，紧跟在\cmd{defbibenvironment} 环境的\prm{begin code} 后面。该命令只能在导言区中使用。
%Appends the \prm{code} to an internal hook executed at the beginning of the bibliography. The \prm{code} is executed at the beginning of the list of references, immediately after the \prm{begin code} of \cmd{defbibenvironment}. This command may only be used in the preamble.

\cmditem{AtBeginShorthands}{code}

向在缩略列表开始时执行的内部钩子添加\prm{code}。\prm{code} 在缩略列表开始处执行，紧跟在\cmd{defbibenvironment} 环境的\prm{begin code} 后面。该命令只能在导言区中使用。
%Appends the \prm{code} to an internal hook executed at the beginning of the list of shorthands. The \prm{code} is executed at the beginning of the list of shorthands, immediately after the \prm{begin code} of \cmd{defbibenvironment}. This command may only be used in the preamble.

该命令也等价于:
%This is just an alias for:

\begin{ltxexample}
\AtBeginBiblist{shorthand}{code}
\end{ltxexample}

\cmditem{AtBeginBiblist}{biblistname}{code}

向在打印\prm{biblistname} 开始时执行的内部钩子添加\prm{code}。\prm{code} 在引文列表开始处执行，紧跟在\cmd{defbibenvironment} 环境的\prm{begin code} 后面。该命令只能在导言区中使用。
%Appends the \prm{code} to an internal hook executed at the beginning of the bibliography list \prm{biblistname}. The \prm{code} is executed at the beginning of the bibliography list, immediately after the \prm{begin code} of \cmd{defbibenvironment}. This command may only be used in the preamble.

\cmditem{AtEveryBibitem}{code}

向在文献表中打印各条目开始时执行的内部钩子添加\prm{code}。\prm{code} 紧跟在\cmd{defbibenvironment} 环境的\prm{item code} 后面。各条目的数据此时已经提供。该命令只能在导言区中使用。
%Appends the \prm{code} to an internal hook executed at the beginning of every item in the bibliography. The \prm{code} is executed immediately after the \prm{item code} of \cmd{defbibenvironment}. The bibliographic data of the respective entry is available at this point. This command may only be used in the preamble.

\cmditem{AtEveryLositem}{code}

向在缩略表中打印各项开始时执行的内部钩子添加\prm{code}。\prm{code} 紧跟在\cmd{defbibenvironment} 环境的\prm{item code} 后面。各条目的数据此时已经提供。该命令只能在导言区中使用。
%Appends the \prm{code} to an internal hook executed at the beginning of every item in the list of shorthands. The \prm{code} is executed immediately after the \prm{item code} of \cmd{defbibenvironment}. The bibliographic data of the respective entry is available at this point. This command may only be used in the preamble.

该命令也等价于:
%This is just an alias for:

\begin{ltxexample}
\AtEveryBiblistitem{shorthand}{code}
\end{ltxexample}

\cmditem{AtEveryBiblistitem}{biblistname}{code}

向在列表\prm{biblistname} 中打印各项开始时执行的内部钩子添加\prm{code}。\prm{code} 紧跟在\cmd{defbibenvironment} 环境的\prm{item code} 后面。各条目的数据此时已经提供。该命令只能在导言区中使用。
%Appends the \prm{code} to an internal hook executed at the beginning of every item in the bibliography list named \prm{biblistname}. The \prm{code} is executed immediately after the \prm{item code} of \cmd{defbibenvironment}. The bibliographic data of the respective entry is available at this point. This command may only be used in the preamble.

\cmditem{AtNextBibliography}{code}

类似于\cmd{AtBeginBibliography}，但仅影响下一个\cmd{printbibliography}。一旦执行该命令，原内部钩子定义将被清除。该命令可以用于正文中。
%Similar to \cmd{AtBeginBibliography} but only affecting the next \cmd{printbibliography}. The internal hook is cleared after being executed once. This command may be used in the document body.

\cmditem{AtUsedriver}{code}
\cmditem*{AtUsedriver}*{code}

%Appends the \prm{code} to an internal hook executed when initializing \cmd{uisedriver}. The starred variant of the command clears the initialisation hook, so the defaults can be overwritten. This command may only be used in the preamble.
%The default setting is:
为初始化\cmd{uisedriver}时执行的一个内部钩子添加代码\prm{code}。带星号的命令会清除该钩子的初始化设置，所以它能覆盖默认的设置。该命令只能用于导言区中，默认的设置为：

\begin{ltxexample}
\AtUsedriver{%
  \let\finentry\blx@finentry@usedrv
  \let\newblock\relax
  \let\abx@macro@bibindex\@empty
  \let\abx@macro@pageref\@empty}
\end{ltxexample}

\cmditem{AtEveryCite}{code}

向在每个标注命令开始时执行的内部钩子添加\prm{code}。\prm{code} 在标注命令的\prm{precode} 前执行(见\secref{aut:cbx:cbx})。各条目的数据此时未提供。该命令只能在导言区中使用。
%Appends the \prm{code} to an internal hook executed at the beginning of every citation command. The \prm{code} is executed immediately before the \prm{precode} of the command (see \secref{aut:cbx:cbx}). No bibliographic data is available at this point. This command may only be used in the preamble.

\cmditem{AtEveryCitekey}{code}

向在把各条目关键词传递给一个标注命令时执行一次的内部钩子添加\prm{code}。\prm{code} 在标注命令的\prm{loopcode} 前执行(见\secref{aut:cbx:cbx})。各条目的数据此时已经提供。该命令只能在导言区中使用。
%Appends the \prm{code} to an internal hook executed once for every entry key passed to a citation command. The \prm{code} is executed immediately before the \prm{loopcode} of the command (see \secref{aut:cbx:cbx}). The bibliographic data of the respective entry is available at this point. This command may only be used in the preamble.

\cmditem{AtEveryMultiCite}{code}

向在每个multicite命令开始时执行的内部钩子添加\prm{code}。\prm{code} 在\bibfield{multiprenote} 域(见\secref{aut:cbx:fld})之前执行。各条目的数据此时未提供。该命令只能在导言区中使用。
%Appends the \prm{code} to an internal hook executed at the beginning of every multicite command. The \prm{code} is executed immediately before the \bibfield{multiprenote} field (\secref{aut:cbx:fld}) is printed. No bibliographic data is available at this point. This command may only be used in the preamble.

\cmditem{AtNextCite}{code}

类似于\cmd{AtEveryCite}，但仅影响下一个标注命令。一旦执行该命令，原内部钩子定义将被清除。该命令可以用于正文中。
%Similar to \cmd{AtEveryCite} but only affecting the next citation command. The internal hook is cleared after being executed once. This command may be used in the document body.

\cmditem{AtEachCitekey}{code}

类似于\cmd{AtEveryCitekey}，但仅影响当前标注命令。该命令可以用于正文中。当在一个标注中时，\prm{code} 添加到一个局部的内容部钩子中，可以用\cmd{ifcitation} 判断是否是在一个标注中。
%Similar to \cmd{AtEveryCitekey} but only affecting the current citation command. This command may be used in the document body. The \prm{code} is appended to the internal hook locally when located in a citation, as determined by \cmd{ifcitation}.

\cmditem{AtNextCitekey}{code}

类似于\cmd{AtEveryCitekey}，但仅影响下一个条目关键词。一旦执行该命令，原内部钩子定义将被清除。该命令可以用于正文中。
%Similar to \cmd{AtEveryCitekey} but only affecting the next entry key. The internal hook is cleared after being executed once. This command may be used in the document body.

\cmditem{AtNextMultiCite}{code}

类似于\cmd{AtEveryMultiCite}，但仅影响下一个multicite命令。一旦执行该命令，原内部钩子定义将被清除。该命令可以用于正文中。
%Similar to \cmd{AtEveryMultiCite} but only affecting the next multicite command. The internal hook is cleared after being executed once. This command may be used in the document body.

\cmditem{AtVolcite}{code}
\cmditem*{AtVolcite}*{code}

Appends the \prm{code} to an internal hook executed when initializing \cmd{volcite}. The starred variant of the command clears the initialisation hook, so the defaults can be overwritten. This command may only be used in the preamble.
The default setting is:

\begin{ltxexample}
\AtVolcite{%
  \DeclareFieldAlias{postnote}{volcitenote}}
\end{ltxexample}
\cmditem{AtDataInput}[entrytype]{code}

向参考文献数据从\file{bbl} 文件导入后每个条目执行一次的内部钩子添加\prm{code}。\prm{entrytype} 是\prm{code} 应用的条目类型。如果要应用于所有条目类型，则忽略该可选参数。\prm{code} 在条目导入后立即执行。该命令只能用于导言中。注意:\prm{code} 对于一个条目可能被执行多次，这发生在当一个相同条目在不同的\env{refsection} 环境中引用或者\opt{sorting} 选项设置包含多余一个的排序格式时。当数据导入时，\cnt{refsection} 计数器保存各参考文献节的序号。
%Appends the \prm{code} to an internal hook executed once for every entry as the bibliographic data is imported from the \file{bbl} file. The \prm{entrytype} is the entry type the \prm{code} applies to. If it applies to all entry types, omit the optional argument. The \prm{code} is executed immediately after the entry has been imported. This command may only be used in the preamble. Note that \prm{code} may be executed multiple times for an entry. This occurs when the same entry is cited in different \env{refsection} environments or the \opt{sorting} option settings incorporate more than one sorting scheme. The \cnt{refsection} counter holds the number of the respective reference section while the data is imported.

\cmditem{UseBibitemHook}

执行对应\cmd{AtEveryBibitem} 的内部钩子。
%Executes the internal hook corresponding to \cmd{AtEveryBibitem}.

\cmditem{UseUsedriverHook}

执行对应\cmd{AtUsedriver} 的内部钩子。
%Executes the internal hook corresponding to \cmd{AtUsedriver}.

\cmditem{UseEveryCiteHook}

执行对应\cmd{AtEveryCite} 的内部钩子。
%Executes the internal hook corresponding to \cmd{AtEveryCite}.

\cmditem{UseEveryCitekeyHook}

执行对应\cmd{AtEveryCitekey} 的内部钩子。
%Executes the internal hook corresponding to \cmd{AtEveryCitekey}.

\cmditem{UseEveryMultiCiteHook}

执行对应\cmd{AtMultiEveryCite} 的内部钩子。
%Executes the internal hook corresponding to \cmd{AtMultiEveryCite}.

\cmditem{UseNextCiteHook}

执行对应\cmd{AtNextCite} 的内部钩子。
%Executes and clears the internal hook corresponding to \cmd{AtNextCite}.

\cmditem{UseNextCitekeyHook}

执行对应\cmd{AtNextCitekey} 的内部钩子。
%Executes and clears the internal hook corresponding to \cmd{AtNextCitekey}.

\cmditem{UseNextMultiCiteHook}

执行对应\cmd{AtNextMultiCite} 的内部钩子。
%Executes and clears the internal hook corresponding to \cmd{AtNextMultiCite}.

\cmditem{UseVolciteHook}

Executes the internal hook corresponding to \cmd{AtVolcite}.

\cmditem{DeferNextCitekeyHook}

局部地取消由\cmd{AtNextCitekey} 设定的内部钩子。其本质是当钩子在\cmd{DeclareCiteCommand} (见\secref{aut:cbx:cbx})的\prm{precode} 参数中执行时，将该钩子延迟到标注列表中的下一个条目关键词。
%Locally un-defines the internal hook specified by \cmd{AtNextCitekey}. This essentially defers the hook to the next entry key in the citation list, when executed in the \prm{precode} argument of \cmd{DeclareCiteCommand} (\secref{aut:cbx:cbx}).

\cmditem{AtEveryEntrykey}{code}{success}{failure}

Appends \prm{code} to an internal hook executed every time an entrykey is processed for a citation command or \cmd{nocite}. The \prm{code} is passed one argument (\lstinline{#1}), which contains the entrykey. If the code can be appended to the hook \prm{success} is executed, otherwise \prm{failure} is executed. Unlike \cmd{AtEveryCitekey} the entry data of the current entrykey is not available when \prm{code} is processed, indeed it is not even known whether or not there is any entry data at all.

\end{ltxsyntax}

\subsubsection{File hooks}
\label{aut:fmt:hok:fil}
\biblatex has rudimentary support for injecting arbitrary code before and after a file is loaded via file hooks. For files that are loaded using \biblatex's file interface---that includes all bibliography and citation styles---the following three hooks are available

\begin{ltxsyntax}
\cmditem{blx@filehook@preload@$<$filename with extension$>$}

If \file{$<$filename with extension$>$} is found, this hook is exected before it is loaded.

\cmditem{blx@filehook@postload@$<$filename with extension$>$}

If \file{$<$filename with extension$>$} is found, this hook is exected after it is loaded.

\cmditem{blx@filehook@failure@$<$filename with extension$>$}

This hook is executed if \file{$<$filename with extension$>$} can not be found.
\end{ltxsyntax}

\biblatex generally only loads files once even if they were requested multiple times,
so the hooks will only be executed once.
Naturally, the file hooks need to be populated before the files are loaded, so the safest would be to populate them before \biblatex is loaded.
It is advisable to only append code to avoid overwriting previous hook contents.
Since the name of the file hook include the dot and the file extension they will usually have to be defined with a command like \cmd{csappto} from \sty{etoolbox}.

The \file{.lbx} files are special and may have to be loaded several times in some situations.
Their file hooks are

\begin{ltxsyntax}
\cmditem{blx@lbxfilehook@once@preload@$<$filename with extension$>$}

If \file{$<$filename with extension$>$} is found, this hook is exected before it is loaded in a situation where the \file{.lbx} files are loaded only once.

\cmditem{blx@lbxfilehook@once@postload@$<$filename with extension$>$}

If \file{$<$filename with extension$>$} is found, this hook is exected after it is loaded in a situation where the \file{.lbx} files are loaded only once.

\cmditem{blx@lbxfilehook@once@failure@$<$filename with extension$>$}

This hook is executed if \file{$<$filename with extension$>$} can not be found in a situation where the \file{.lbx} files are loaded only once.

\cmditem{blx@lbxfilehook@simple@preload@$<$filename with extension$>$}

If \file{$<$filename with extension$>$} is found, this hook is exected before it is loaded in a situation where the \file{.lbx} files may be loaded multiple times.

\cmditem{blx@lbxfilehook@simple@postload@$<$filename with extension$>$}

If \file{$<$filename with extension$>$} is found, this hook is exected after it is loaded in a situation where the \file{.lbx} files may be loaded multiple times.

\cmditem{blx@lbxfilehook@simple@failure@$<$filename with extension$>$}

This hook is executed if \file{$<$filename with extension$>$} can not be found in a situation where the \file{.lbx} files may be loaded multiple times.


The following code sets up \sty{beamer} to print the bibliography labels instead of its bibliography icons when \file{numeric.bbx} after is loaded
\begin{ltxexample}
\csappto{blx@filehook@postload@numeric.bbx}{%
  \mode<presentation>{%
    \setbeamertemplate{bibliography item}{%
      \insertbiblabel}}}
\end{ltxexample}

\end{ltxsyntax}

\subsection{提示与警告}%Hints and Caveats
\label{aut:cav}

本节提供了关于biblatex宏包接口的一些附加提示，也将论述一些普遍性的问题和容易误解的概念。
%This section provides some additional hints concerning the author interface of this package. It also addresses common problems and potential misconceptions.

\subsubsection{条目集}%Entry Sets
\label{aut:cav:set}

条目集已经在\secref{use:use:set} 节介绍过，本节主要讨论怎么在著录样式中处理条目集。从驱动的角度看，静态和动态的条目集并无差别。两者都以相同方式处理。只需要使用\secref{aut:bib:dat} 的\cmd{entryset} 命令遍历集的所有成员(以在\bibtype{set} 条目的\bibfield{entryset} 域中的出现的顺序，或者它们传递给\cmd{defbibentryset} 命令的顺序进行遍历)，并在最后加上\cmd{finentry} 命令即可。格式化则由集的成员各自条目类型的驱动控制。
%Entry sets have already been introduced in \secref{use:use:set}. This section discusses how to process entry sets in a bibliography style. From the perspective of the driver, there is no difference between static and dynamic entry sets. Both types are handled in the same way. You will normally use the \cmd{entryset} command from \secref{aut:bib:dat} to loop over all set members (in the order in which they are listed in the \bibfield{entryset} field of the \bibtype{set} entry, or in the order in which they were passed to \cmd{defbibentryset}, respectively) and append \cmd{finentry} at the end. That's it. The formatting is handled by the drivers for the entry types of the individual set members:

\begin{ltxexample}
\DeclareBibliographyDriver{set}{%
  <<\entryset>>{}{}%
  \finentry}
\end{ltxexample}
%
需要注意: 本宏包附带的\texttt{numeric} 样式支持条目集细分，即集成员以一个字母或者其他记号来标记，标注命令可以引用整个集或者其中的某一具体成员。记号由样式文件以如下方式生成:
%You may have noticed that the \texttt{numeric} styles which ship with this package support subdivided entry sets, \ie the members of the set are marked with a letter or some other marker such that citations may either refer to the entire set or to a specific set member. The markers are generated as follows by the bibliography style:

\begin{ltxexample}
\DeclareBibliographyDriver{set}{%
  \entryset
    {<<\printfield{entrysetcount}>>%
     <<\setunit*{\addnbspace}>>}
    {}%
  \finentry}
\end{ltxexample}
%
\bibfield{entrysetcount} 域保存了一个整数用于指示集成员在整个集中的位置。数字是转换为一个字母还是其他记号由域格式\bibfield{entrysetcount} 控制。所有驱动需要做的是打印域和一些空格(或者换行)。在标注中打印记号的方式类似。当顺序编码制样式给出|\printfield{labelnumber}|时，可以简单地加上\bibfield{entrysetcount} 域。
%The \bibfield{entrysetcount} field holds an integer indicating the position of a set member in the entry set. The conversion of this number to a letter or some other marker is handled by the formatting directive of the \bibfield{entrysetcount} field. All the driver needs to do is print the field and add some white space (or start a new line). Printing the markers in citations works in a similar way. Where a numeric style normally says |\printfield{labelnumber}|, you simply append the \bibfield{entrysetcount} field:

\begin{ltxexample}
\printfield{labelnumber}<<\printfield{entrysetcount}>>
\end{ltxexample}
%
因为该域仅在处理标注指向一个集成员时定义，所以没有必要添加任何更多的判断。
%Since this field is only defined when processing citations referring to a set member, there is no need to add any additional tests.

%Citing entry sets directly requires that a meaningful way of identifying sets is available in the style. This is obvious for styles based on numeric or alphabetic labels but not obvious (and rarely required) in styles which construct citations based on textual names/titles/dates etc. The default provided styles which no not construct citations based on labels (\texttt{authoryear}, \texttt{authortitle}, \texttt{verbose} etc.) therefore do not support citing sets directly as there is no obvious default identifier to use in such cases and such styles rarely, if ever, employ sets anyway. Custom styles may of course choose to define and print a citation identifier for directly cited sets.

引用一个条目集，需要样式提供一个有效识别的条目集的方式。
这在基于数字顺序和字母顺序编码的样式中是显然的，但在基于文本比如names/titles/dates等的标签的样式中通常是无法显著区分的，或者极少需要的。
在不基于标签(label)构造标注的样式(\texttt{authoryear}, \texttt{authortitle}, \texttt{verbose} etc.)中，通常不支持直接的条目集引用，
因为没有一个默认的显著的标识符来区分，且这类样式记号以这种方式使用。
定制样式当然可以定义或打印一个标注标识符用于直接引用。



\subsubsection{电子出版信息}%Electronic Publishing Information
\label{aut:cav:epr}
标准样式主要支持arXiv网站的文献\footnote{译者:arXiv 原先是由物理学家保罗·金斯巴格在1991年建立的网站，本意在收集物理学的论文预印本，随后括及天文、数学等其它领域。金斯巴格因为这个网站获得了2002年的麦克阿瑟奖。arXiv 原先挂在洛斯阿拉莫斯国家实验室，是故早期被称为「LANL 预印本数据库」。目前的 arXiv 落脚于康乃尔大学，并在全球各地设有镜像站点。网站在1999年改名为 arXiv.org 。}。其它资源的支持很容易增加。标准样式以如下方式处理\bibfield{eprint} 域:
%The standard styles feature dedicated support for arXiv references. Support for other resources is easily added. The standard styles handle the \bibfield{eprint} field as follows:

\begin{ltxexample}
\iffieldundef{eprinttype}
  {\printfield{eprint}}
  {\printfield[<<eprint:\strfield{eprinttype}>>]{eprint}}
\end{ltxexample}
%
如果\bibfield{eprinttype} 域存在，上述代码将使用域格式\texttt{eprint:\prm{eprinttype}}。如果该格式未定义，\cmd{printfield} 自动退回到使用域格式\texttt{eprint}。有两种预定义的域格式，具体类型的域格式\texttt{eprint:arxiv} 和通用域格式\texttt{eprint}。
%If an \bibfield{eprinttype} field is available, the above code tries to use the field format \texttt{eprint:\prm{eprinttype}}. If this format is undefined, \cmd{printfield} automatically falls back to the field format \texttt{eprint}. There are two predefined field formats, the type"=specific format \texttt{eprint:arxiv} and the fallback format \texttt{eprint}:

\begin{ltxexample}
\DeclareFieldFormat{<<eprint>>}{...}
\DeclareFieldFormat{<<eprint:arxiv>>}{...}
\end{ltxexample}
%
换句话说，增加其他数据源的支持只需要定义一个名为\texttt{eprint:\prm{resource}} 的与格式，其中\prm{resource} 是在\bibfield{eprinttype} 域中使用的标识。
%In other words, adding support for additional resources is as easy as defining a field format named \texttt{eprint:\prm{resource}} where \prm{resource} is an identifier to be used in the \bibfield{eprinttype} field.

\subsubsection{外部摘要和注解}% External Abstracts and Annotations
\label{aut:cav:prf}

外部摘要和注解已经在\secref{use:use:prf} 节讨论过，本节为样式作者提供更多的背景知识。标准样式使用如下的宏(来自 \path{biblatex.def})来处理摘要和注解:
%External abstracts and annotations have been discussed in \secref{use:use:prf}. This section provides some more background for style authors. The standard styles use the following macros (from \path{biblatex.def}) to handle abstracts and annotations:

\begin{ltxexample}
\newbibmacro*{annotation}{%
  \iffieldundef{annotation}
    {\printfile[annotation]{<<\bibannotationprefix\thefield{entrykey}.tex>>}}%
    {\printfield{annotation}}}
\newcommand*{<<\bibannotationprefix>>}{bibannotation-}

\newbibmacro*{abstract}{%
  \iffieldundef{abstract}
    {\printfile[abstract]{<<\bibabstractprefix\thefield{entrykey}.tex>>}}%
    {\printfield{abstract}}}
\newcommand*{<<\bibabstractprefix>>}{bibabstract-}
\end{ltxexample}
%
如果\bibfield{abstract}\slash \bibfield{annotation} 域未定义，上述代码将从外部文件中加载摘要和注解。\cmd{printfile} 将根据用户定义的前缀来搜索文件名。注意:必须显式地设置\secref{use:opt:pre:gen} 节的\opt{loadfiles} 包选项来启用\cmd{printfile} 功能。基于性能原因该功能默认是关闭的。
%If the \bibfield{abstract}\slash \bibfield{annotation} field is undefined, the above code tries to load the abstracts\slash annotations from an external file. The \cmd{printfile} commands also incorporate file name prefixes which may be redefined by users. Note that you must enable \cmd{printfile} explicitly by setting the \opt{loadfiles} package option from \secref{use:opt:pre:gen}. This feature is disabled by default for performance reasons.

\subsubsection[消除姓名歧义]{消除姓名歧义}%Name Disambiguation
\label{aut:cav:amb}
在\secref{use:opt:pre:int} 节引入的\opt{uniquename} 和\opt{uniquelist} 选项支持多种操作模式。本节用举例方式介绍不同模式的差别。\opt{uniquename} 选项消除\bibfield{labelname} 列表中各姓名间的歧义，而\opt{uniquelist} 则消除因\opt{maxnames}\slash \opt{minnames} 截短导致的\bibfield{labelname} 列表歧义。两个选项可以单独使用也可以联合使用:
%The \opt{uniquename} and \opt{uniquelist} options introduced in \secref{use:opt:pre:int} support various modes of operation. This section explains the differences between these modes by way of example. The \opt{uniquename} option disambiguates individual names in the \bibfield{labelname} list. The \opt{uniquelist} option disambiguates the \bibfield{labelname} list if it has become ambiguous after \opt{maxnames}\slash \opt{minnames} truncation. You can use either option stand-alone or combine both.

消除姓名歧义原理是根据由一个或多个姓名成分构成的<base>，来确定需要在其基础上添加什么(如果存在的话)，使得姓名在当前参考文献节中是唯一的。消除姓名歧义由如下命令声明的 uniquename 模板控制:
%Name disambiguation works by taking a <base> which is composed of one or more nameparts and then determining what needs to be added, if anything, to this <base> to make the name unique in the current refsection. Name disambiguation is controlled by the uniquename template declared with the following command:

\begin{ltxsyntax}

\cmditem{DeclareUniquenameTemplate}[name]{specification}

Defines the \opt{uniquename} template \prm{name}. The \prm{name} is optional and defaults to \prm{<global>}.
\prm{specification} 是\cmd{namepart} 命令的一个有序列表，定义了确定 uniquename 信息所使用的姓名成分。
%The \prm{specification} is an ordered list of \cmd{namepart} commands which define the nameparts to use in determining the uniquename information

\cmditem{namepart}[options]{namepart}

\prm{namepart} 是数据模型中的姓名成分，由\cmd{DeclareDatamodelConstant} 命令定义(见\secref{aut:bbx:drv})。选项包括:
%\prm{namepart} is one of the datamodel nameparts defined with the \cmd{DeclareDatamodelConstant} command (see \secref{aut:bbx:drv}). The \opt{options} are:

\begin{optionlist*}

\boolitem[false]{use}

在构建 uniquename 信息中仅使用\prm{namepart}，如果存在相应的选项\opt{use<namepart>} 并且值为true。
%Only use the \prm{namepart} in constructing the uniquename information if there is a corresponding option \opt{use<namepart>} and that option is true.

\boolitem[false]{base}


%The \prm{namepart} is part of the <base> which is the main piece of namepart(s) information which is being disambiguated by uniqueness information. For example, a family name which may be disambiguated by further given names. <base> \prm{namepart}s must occur before any non-<base> \prm{nameparts}.

 There \emph{must} be at least one <base> \prm{namepart} and \biber will report an error if this is not the case.

\prm{namepart} 是<base>的部分，<base>是用作唯一性区分的namepart(s)信息的主段。

\choitem{disambiguation}{none, init, initorfull, full}

The \prm{namepart} will be disambiguated at most by information at the given value. If this option is not present then the default is inferred from the \opt{uniquename} package option setting (see \secref{use:opt:wu}). The <disambiguation> option is ignored for \prm{namepart}s which have the <base> option set to <true> since it is these nameparts which are being disambiguated by the value of the non-base \prm{namepart}s and therefore <disambiguation> does not apply.

\begin{description}
\item[none]~Do not use the \prm{namepart} to perform any name disambiguation
\item[init]~Use only the initials of the \prm{namepart} to perform name disambiguation
\item[initorfull]~Use initials and if necessary the full \prm{namepart} to perform name disambiguation
\item[full]~Use only the full \prm{namepart} to perform name
  disambiguation even if initials would suffice
\end{description}

\end{optionlist*}

\end{ltxsyntax}
%
默认的uniquename模板是:
%The default uniquename template is:

\begin{ltxexample}
\DeclareUniquenameTemplate{
  \namepart[use=true, base=true]{prefix}
  \namepart[base=true]{family}
  \namepart{given}
}
\end{ltxexample}
%
这意味着要区分的<base>由姓(<family>)和前缀(如果\opt{useprefix} 选项是true)构成。消除歧义主要通过增加模板中任何非<base>姓名成分来实现，这里就是名(<given>)成分。
%This means that the <base> to be disambiguated consists of the <family> namepart, along with any prefix, if the \opt{useprefix} option is true. The disambiguation is performed by adding aspects of any non <base> nameparts in the specification, here just the <given> namepart.

\paragraph{单个姓名(姓名间的区分)(\opt{uniquename})}%Individual Names (\opt{uniquename})

%Let's start off with some \opt{uniquename} examples. Consider the following data:
下面从一些\opt{uniquename} 示例开始，考虑如下数据:

\begin{lstlisting}{}
John Doe   2008
Edward Doe 2008
John Smith 2008
Jane Smith 2008
\end{lstlisting}
%
%Let's assume we're using an author-year style and set \kvopt{uniquename}{false}. In this case, we would get the following citations:
假设我们使用作者年制且设置\kvopt{uniquename}{false}，这种情况下，我们得到如下引用标注:
\begin{lstlisting}{}
Doe 2008a
Doe 2008b
Smith 2008a
Smith 2008b
\end{lstlisting}
%
%Since the family names are ambiguous and all works have been published in the same year, an extra letter is appended to the year to disambiguate the citations. Many style guides, however, mandate that the extra letter be used to disambiguate works by the same authors only, not works by different authors with the same family name. In order to disambiguate the author's family name, you are expected to add additional parts of the name, either as initials or in full. This requirement is addressed by the \opt{uniquename} option. Here are the same citations with \kvopt{uniquename}{init}:
因为姓有歧义，且所有的年都相同，所以年后附加的字符用来区分并消除歧义。然而，很多样式指南强制要求附加字符只能用于相同作者的区分，而不能用于作者相同的姓的区分。为了消除作者姓的歧义，需要增加姓名的其它完整部分或者缩写来区分。这一需要由\opt{uniquename} 选项处理，下面是使用了\kvopt{uniquename}{init} 的引用标注:
\begin{lstlisting}{}
J. Doe 2008
E. Doe 2008
Smith 2008a
Smith 2008b
\end{lstlisting}
%
%\kvopt{uniquename}{init} restricts name disambiguation to initials. Since <J. Smith> would still be ambiguous, no additional name parts are added for the <Smiths>. With \kvopt{uniquename}{full}, names are printed in full where required:
\kvopt{uniquename}{init} 限制了用缩写来区分姓名。但因为<J. Smith>仍然有歧义，所以没有增加。而使用\kvopt{uniquename}{full}，标注如下:
\begin{lstlisting}{}
J. Doe 2008
E. Doe 2008
John Smith 2008
Jane Smith 2008
\end{lstlisting}
%
%In order to illustrate the difference between \kvopt{uniquename}{init\slash full} and \texttt{allinit\slash allfull}, we need to introduce the notion of a <visible> name. In the following, <visible> names are all names at a position before the \opt{maxnames}\slash \opt{minnames}\slash \opt{uniquelist} truncation point. For example, given this data:
为了说明\kvopt{uniquename}{init\slash full} 和\texttt{allinit\slash allfull} 的差别，我们下面介绍 <visible> 姓名的概念。<visible> 姓名是位于\opt{maxnames}\slash \opt{minnames}\slash \opt{uniquelist} 截短点前的姓名，比如，给出数据:
\begin{lstlisting}{}
William Jones/Edward Doe/Jane Smith
John Doe
John Smith
\end{lstlisting}
%
%and \kvopt{maxnames}{1}, \kvopt{minnames}{1}, \kvopt{uniquename}{init/full}, we would get the following names in citations:
当\kvopt{maxnames}{1}, \kvopt{minnames}{1}, \kvopt{uniquename}{init/full} 时，我们得到如下的引用标注:
\begin{lstlisting}{}
Jones et al.
Doe
Smith
\end{lstlisting}
%
%When disambiguating names, \kvopt{uniquename}{init/full} only consider the visible names. Since all visible last names are distinct in this example, no further name parts are added. Let's compare that to the output of \kvopt{uniquename}{allinit}:
在消除歧义的时候，\kvopt{uniquename}{init/full} 仅考虑可见的姓名。因为本例中所有的可见姓名的姓都是不同的，所有没有姓名的其他部分附加进来。比较一下使用\kvopt{uniquename}{allinit} 的输出:
\begin{lstlisting}{}
Jones et al.
J. Doe
Smith
\end{lstlisting}
%
%\texttt{allinit} considers all names in all \bibfield{labelname} lists, including those which are hidden and replaced by <et al.> as the list is truncated. In this example, <John Doe> is disambiguated from <Edward Doe>. Since the ambiguity of the two <Smiths> can't be resolved by adding initials, no initials are added in this case. Now let's compare that to the output of \kvopt{uniquename}{allfull} which also disambiguates <John Smith> from <Jane Smith>:
\texttt{allinit} 认为所有在\bibfield{labelname} 列表中的姓名，包括列表截短后已经隐藏并且由<et al.>代替的姓名。在本例中，<John Doe> 与 <Edward Doe>存在歧义。因为两个 <Smiths> 无法通过添加缩写的方式区分，所以没有添加。现在来比较一下\kvopt{uniquename}{allfull} 的输出:
\begin{lstlisting}{}
Jones et al.
J. Doe
John Smith
\end{lstlisting}
%
%The options \kvopt{uniquename}{mininit/minfull} are similar to \texttt{init\slash full} in that they only consider visible names, but they perform minimal disambiguation. That is, they will disambiguate individual names only if they occur in identical lists of last names. Consider the following data:
\kvopt{uniquename}{mininit/minfull} 选项类似于\texttt{init\slash full} 仅考虑可见姓名，但仅执行最小的歧义消除。即，仅对姓列表的歧义进行处理，考虑如下数据:
\begin{lstlisting}{}
John Doe/William Jones
Edward Doe/William Jones
John Smith/William Edwards
Edward Smith/Allan Johnson
\end{lstlisting}
%
%With \kvopt{uniquename}{init/full}, we would get:
使用\kvopt{uniquename}{init/full}，得到:
\begin{lstlisting}{}
J. Doe and Jones
E. Doe and Jones
J. Smith and Edwards
E. Smith and Johnson
\end{lstlisting}
%
%With \kvopt{uniquename}{mininit/minfull}:
使用\kvopt{uniquename}{mininit/minfull}，得到:
\begin{lstlisting}{}
J. Doe and Jones
E. Doe and Jones
Smith and Edwards
Smith and Johnson
\end{lstlisting}
%
%The <Smiths> are not disambiguated because the visible name lists are not ambiguous and the \opt{mininit/minfull} options serve to disambiguate names occurring in identical last name lists only. Another way of looking at this is that they globally disambiguate family name lists. When it comes to ambiguous lists, note that a truncated list is considered to be distinct from an untruncated one even if the visible names are identical. For example, consider the following data:
<Smiths> 并无歧义，因为姓名列表时没有歧义。\opt{mininit/minfull} 选项仅对姓的列表相同情况进行处理。全局的看姓的列表，注意当未截短的列表的可见名相同的时候，截短的列表时也可能是不同的，比如下面的数据:
\begin{lstlisting}{}
John Doe/William Jones
Edward Doe
\end{lstlisting}
%
%With \kvopt{maxnames}{1}, \kvopt{uniquename}{init/full}, we would get:
使用\kvopt{maxnames}{1}, \kvopt{uniquename}{init/full}:

\begin{lstlisting}{}
J. Doe et al.
E. Doe
\end{lstlisting}
%
%With \kvopt{uniquename}{mininit/minfull}:
使用\kvopt{uniquename}{mininit/minfull}:

\begin{lstlisting}{}
Doe et al.
Doe
\end{lstlisting}
%
%Because the lists differ in the <et al.>, the names are not disambiguated.
因为列表有 <et al.> 的不同，姓名列表就不歧义。

\paragraph{姓名列表(列表间的区分) (\opt{uniquelist})}%Lists of Names (\opt{uniquelist})

%Ambiguity is also an issue with name lists. If the \bibfield{labelname} list is truncated by the \opt{maxnames}\slash \opt{minnames} options, it may become ambiguous. This type of ambiguity is addressed by the \opt{uniquelist} option. Consider the following data:

姓名列表也可能存在歧义问题。如果\bibfield{labelname} 列表由\opt{maxnames}\slash \opt{minnames} 选项截短就可能产生歧义。这类问题由\opt{uniquelist} 选处理，考虑如下数据:
\begin{lstlisting}{}
Doe/Jones/Smith   2005
Smith/Johnson/Doe 2005
Smith/Doe/Edwards 2005
Smith/Doe/Jones   2005
\end{lstlisting}
%
%Many author-year styles truncate long author/editor lists in citations. For example, with \kvopt{maxnames}{1} we would get:

很多作者年制样式需要在标注中截短，比如使用\kvopt{maxnames}{1} 选项，得到:
\begin{lstlisting}{}
Doe et al. 2005
Smith et al. 2005a
Smith et al. 2005b
Smith et al. 2005c
\end{lstlisting}
%
%Since the authors are ambiguous after truncation, the extra letter is added to the year to ensure unique citations. Here again, many style guides mandate that the extra letter be used to disambiguate works by the same authors only. In order to disambiguate author lists, you are usually required to add more names, exceeding the \opt{maxnames}\slash \opt{minnames} truncation point. The \opt{uniquelist} feature addresses this requirement. With \kvopt{uniquelist}{true}, we would get:
因为截短后作者存在歧义，所以添加额外字符确保引用标注的唯一性。同样的，一些样式强制要求额外字符只能用于所有作者都相同的情况。为了区分作者列表，必须增加更多的姓名，这样就会超出\opt{maxnames}\slash \opt{minnames} 选项设定的截短点。\opt{uniquelist} 选项即描述这一需求，当\kvopt{uniquelist}{true}，有:

\begin{lstlisting}{}
Doe et al. 2005
Smith, Johnson et al. 2005
Smith, Doe and Edwards 2005
Smith, Doe and Jones 2005
\end{lstlisting}
%
%The \opt{uniquelist} option overrides \opt{maxnames}\slash \opt{minnames} on a per-entry basis. Essentially, what happens is that the <et al.> part of the citation is expanded to the point of no ambiguity~-- but no further than that. \opt{uniquelist} may also be combined with \opt{uniquename}. Consider the following data:
\opt{uniquelist} 选项以条目为限重设\opt{maxnames}\slash \opt{minnames}。大体上，标注的 <et al.> 部分扩展到无歧义的点--而且也基本到此为止。\opt{uniquelist} 也可以与\opt{uniquename} 联合使用，考虑如下数据:

\begin{lstlisting}{}
John Doe/Allan Johnson/William Jones  2009
John Doe/Edward Johnson/William Jones 2009
John Doe/Jane Smith/William Jones     2009
John Doe/John Smith/William Jones     2009
John Doe/John Edwards/William Jones   2009
John Doe/John Edwards/Jack Johnson    2009
\end{lstlisting}
%
%With \kvopt{maxnames}{1}:
使用\kvopt{maxnames}{1}，得到:

\begin{lstlisting}{}
Doe et al. 2009a
Doe et al. 2009b
Doe et al. 2009c
Doe et al. 2009d
Doe et al. 2009e
Doe et al. 2009f
\end{lstlisting}
%
%With \kvopt{maxnames}{1}, \kvopt{uniquename}{full}, \kvopt{uniquelist}{true}:
使用\kvopt{maxnames}{1}, \kvopt{uniquename}{full}, \kvopt{uniquelist}{true} 则有:

\begin{lstlisting}{}
Doe, A. Johnson et al. 2009
Doe, E. Johnson et al. 2009
Doe, Jane Smith et al. 2009
Doe, John Smith et al. 2009
Doe, Edwards and Jones 2009
Doe, Edwards and Johnson 2009
\end{lstlisting}
%
%With \kvopt{uniquelist}{minyear}, list disambiguation only happens if the visible list is identical to another visible list with the same \bibfield{labelyear}. This is useful for author-year styles which only require that the citation as a whole be unique, but do not guarantee unambiguous authorship information in citations. This mode is conceptually related to \kvopt{uniquename}{mininit/minfull}. Consider this example:

使用\kvopt{uniquelist}{minyear}，消除列表歧义仅在可见列表和\bibfield{labelyear} 相同的时候。这对于仅仅需要整个标注整体具有唯一性的作者年制样式是很有用的，但是不保证作者姓名的非歧义性。这一模式概念上域\kvopt{uniquename}{mininit/minfull} 选项相关。考虑如下示例:
\begin{lstlisting}{}
Smith/Jones   2000
Smith/Johnson 2001
\end{lstlisting}
%
%With \kvopt{maxnames}{1} and \kvopt{uniquelist}{true}, we would get:
使用\kvopt{maxnames}{1} 和\kvopt{uniquelist}{true}，得到:

\begin{lstlisting}{}
Smith and Jones 2000
Smith and Johnson 2001
\end{lstlisting}
%
%With \kvopt{uniquelist}{minyear}:
使用\kvopt{uniquelist}{minyear}，则得到:

\begin{lstlisting}{}
Smith et al. 2000
Smith et al. 2001
\end{lstlisting}
%
%With \kvopt{uniquelist}{minyear}, it is not clear that the authors are different for the two works but the citations as a whole are still unambiguous since the year is different. In contrast to that, \kvopt{uniquelist}{true} disambiguates the authorship even if this information is not required to uniquely locate the works in the bibliography. Let's consider another example:

使用\kvopt{uniquelist}{minyear}，两个文献的作者是否相同并不清楚，但标注的整体是非歧义的，因为年份的不同。与此相反，\kvopt{uniquelist}{true} 需要消除作者列表的歧义即便这一信息对于参考文献表的唯一引用是不必要的，看看如下示例:
\begin{lstlisting}{}
Vogel/Beast/Garble/Rook  2000
Vogel/Beast/Tremble/Bite 2000
Vogel/Beast/Acid/Squeeze 2001
\end{lstlisting}
%
%With \kvopt{maxnames}{3}, \kvopt{minnames}{1}, \kvopt{uniquelist}{true}, we would get:
使用\kvopt{maxnames}{3}, \kvopt{minnames}{1}, \kvopt{uniquelist}{true}，得到

\begin{lstlisting}{}
Vogel, Beast, Garble et al. 2000
Vogel, Beast, Tremble et al. 2000
Vogel, Beast, Acid et al. 2001
\end{lstlisting}
%
%With \kvopt{uniquelist}{minyear}:
使用\kvopt{uniquelist}{minyear} 选项，则有:

\begin{lstlisting}{}
Vogel, Beast, Garble et al. 2000
Vogel, Beast, Tremble et al. 2000
Vogel et al. 2001
\end{lstlisting}
%
%In the last citation, \kvopt{uniquelist}{minyear} does not override \opt{maxnames}\slash \opt{minnames} as the citation does not need disambiguating from the other two because the year is different.
在最后一个引用中，\kvopt{uniquelist}{minyear} 不重写\opt{maxnames}\slash \opt{minnames}，因为年份的不同，所以不需要消除与其它两个间的歧义。

\subsubsection{浮动体和\acr{TOC}/\acr{LOT}/\acr{LOF} 中的追踪器}%Trackers in Floats and \acr{TOC}/\acr{LOT}/\acr{LOF}
\label{aut:cav:flt}

当引用命令出现在浮动体(比如图和表的题注)中，因为浮动体无论是物理上还是逻辑上都在文本流之外，这会导致的学术反向引用(比如<ibidem>，意为“出处同上”)和基于页码追踪器的反向引用难以区分，因此这种引用的逻辑很难在其中应用。为避免这种问题，标注(引用)和页码追踪器在所有的浮动体中临时关闭。并且，这些追踪器加上反向引用追踪器(\opt{backref})在目录，图和表目录中也临时关闭。
%If a citation is given in a float (typically in the caption of a figure or table), scholarly back references like <ibidem> or back references based on the page tracker get ambiguous because floats are objects which are (physically and logically) placed outside the flow of text, hence the logic of such references applies poorly to them. To avoid any such ambiguities, the citation and page trackers are temporarily disabled in all floats. In addition to that, these trackers plus the back reference tracker (\opt{backref}) are temporarily disabled in the table of contents, the list of figures, and the list of tables.

 If a citation is given in a float (typically in the caption of a figure or table), scholarly back references like <ibidem> or back references based on the page tracker get ambiguous because floats are objects which are (physically and logically) placed outside the flow of text, hence the logic of such references applies poorly to them. To avoid any such ambiguities, the citation and page trackers are temporarily disabled in all floats unless explicitly requested with \opt{trackfloats}. In addition to that, these trackers plus the back reference tracker (\opt{backref}) are temporarily disabled in the table of contents, the list of figures, and the list of tables.

\subsubsection{混合编程接口}%Mixing Programming Interfaces
\label{aut:cav:mif}

%The \biblatex package provides two main programming interfaces for style authors. The \cmd{DeclareBibliographyDriver} command, which defines a handler for an entry type, is typically used in \file{bbx} files. \cmd{DeclareCiteCommand}, which defines a new citation command, is typically used in \file{cbx} files. However, in some cases it is convenient to mix these two interfaces. For example, the \cmd{fullcite} command prints a verbose citation similar to the full bibliography entry. It is essentially defined as follows:

\biblatex 宏包给样式作者提供了2个主要的编程接口即: \file{bbx} 文件中使用的\cmd{DeclareBibliographyDriver} 命令用来定义各类参考文献条目的驱动(即条目的格式处理器)，\file{cbx} 文件中使用的\cmd{DeclareCiteCommand} 命令用来定义新的标注命令。然而有时候，混合使用这两个接口会很方便。比如\cmd{fullcite} 命令就可以打印类似于完整参考文献条目的长串标注，该命令定义大体如下:
\begin{ltxexample}
\DeclareCiteCommand{\fullcite}
  {...}
  {<<\usedriver>>{...}{<<\thefield{entrytype}>>}}
  {...}
  {...}
\end{ltxexample}
%
%As you can see, the core code which prints the citations simply executes the bibliography driver defined with \cmd{DeclareBibliographyDriver} for the type of the current entry. When writing a citation style for a verbose citation scheme, it is often convenient to use the following structure:
如上所见，打印标注的核心代码简单地为当前的条目类型
执行了\cmd{DeclareBibliographyDriver} 定义的驱动命令。当为长标注格式(verbose)编写标注样式文件的时候，使用下面的结构是非常方便的:

\begin{ltxexample}
\ProvidesFile{example.cbx}[2007/06/09 v1.0 biblatex citation style]

\DeclareCiteCommand{\cite}
  {...}
  {<<\usedriver>>{...}{<<cite:\thefield{entrytype}>>}}
  {...}
  {...}

\DeclareBibliographyDriver{<<cite:article>>}{...}
\DeclareBibliographyDriver{<<cite:book>>}{...}
\DeclareBibliographyDriver{<<cite:inbook>>}{...}
...
\end{ltxexample}
%
%Another case in which mixing interfaces is helpful are styles using cross"=references within the bibliography. For example, when printing an \bibtype{incollection} entry, the data inherited from the \bibtype{collection} parent entry would be replaced by a short pointer to the respective parent entry:

混合接口的另一个有用情况是在参考文献表中使用交叉引用(cross"=references)时。比如当打印\bibtype{incollection} 类型的条目，数据继承自\bibtype{collection} 父条目，可由一个指向对应父条目的简短指针来代替。
\begin{enumerate}
\renewcommand*\labelenumi{[\theenumi]}
\setlength{\leftskip}{0.5em}
\item Audrey Author: \emph{Title of article}. In: [\textln{2}], pp.~134--165.
\item Edward Editor, ed.: \emph{Title of collection}. Publisher: Location, 1995.
\end{enumerate}

%One way to implement such cross"=references within the bibliography is to think of them as citations which use the value of the \bibfield{xref} or \bibfield{crossref} field as the entry key. Here is an example:
实现参考文献表内的这种交叉引用的一种方法是将它们当成标注，并使用\bibfield{xref} 或 \bibfield{crossref} 域的值作为条目关键词(条目bibtex键)，示例如下:

\begin{ltxexample}
\ProvidesFile{example.bbx}[2007/06/09 v1.0 biblatex bibliography style]

\DeclareCiteCommand{<<\bbx@xref>>}
  {}
  {...}% code for cross-references
  {}
  {}

\DeclareBibliographyDriver{incollection}{%
  ...
  \iffieldundef{xref}
    {...}% code if no cross-reference
    {<<\bbx@xref>>{<<\thefield{xref}>>}}%
  ...
}
\end{ltxexample}
%
%When defining \cmd{bbx@xref}, the \prm{precode}, \prm{postcode}, and \prm{sepcode} arguments of \cmd{DeclareCiteCommand} are left empty in the above example because they will not be used anyway. The cross"=reference is printed by the \prm{loopcode} of \cmd{bbx@xref}. For further details on the \bibfield{xref} field, refer to \secref{bib:fld:spc} and to the hints in \secref{bib:cav:ref}. Also see the \cmd{iffieldxref}, \cmd{iflistxref}, and \cmd{ifnamexref} tests in \secref{aut:aux:tst}. The above could also be implemented using the \cmd{entrydata} command from \secref{aut:bib:dat}:
当定义\cmd{bbx@xref} 命令时，\cmd{DeclareCiteCommand} 命令的\prm{precode}, \prm{postcode}, 和 \prm{sepcode} 参数留空，是因为上面示例中没有用到。交叉引用由\cmd{bbx@xref} 命令的\prm{loopcode} 参数打印。更多的关于\bibfield{xref} 域的细节见\secref{bib:fld:spc} 节以及\secref{bib:cav:ref} 节中的注意事项。在\secref{aut:aux:tst} 节我们也看到了\cmd{iffieldxref}, \cmd{iflistxref}, 和\cmd{ifnamexref} 测试命令。这些都也可以用\secref{aut:bib:dat} 节的\cmd{entrydata} 命令来实现。

\begin{ltxexample}
\ProvidesFile{example.bbx}[2007/06/09 v1.0 biblatex bibliography style]

\DeclareBibliographyDriver{incollection}{%
  ...
  \iffieldundef{xref}
    {...}% code if no cross-reference
    {<<\entrydata>>{<<\thefield{xref}>>}{%
      % code for cross-references
      ...
    }}%
  ...
}
\end{ltxexample}

\subsubsection{使用标点追踪}%Using the Punctuation Tracker
\label{aut:cav:pct}

\paragraph{标点基础}%The Basics

%There is one fundamental principle style authors should keep in mind when designing a bibliography driver: block and unit punctuation is handled asynchronously. This is best explained by way of example. Consider the following code snippet:

样式作者设计参考文献驱动时需要记住一点原则:块和单元的标点是异步处理的。用示例最容易解释这一点，看下面一段代码:
\begin{ltxexample}
\printfield{title}%
\newunit
\printfield{edition}%
\newunit
\printfield{note}%
\end{ltxexample}
%
%If there is no \bibfield{edition} field, this piece of code will not print:
如果没有\bibfield{edition} 域，那么这段代码的打印结果不会是:

\begin{lstlisting}[style=highlight]{}
Title. . Note
\end{lstlisting}
%
%but rather:
而会是

\begin{lstlisting}[style=highlight]{}
Title. Note
\end{lstlisting}
%
因为单元的标点追踪器是异步方式工作的。\cmd{newunit} 命令将不会立即打印标点。它仅是记录一个单元的边界并且将\cmd{newunitpunct} 命令放入标点缓存中。该缓存会有\emph{接下来的}\cmd{printfield}、\cmd{printlist} 或类似命令进行处理，且仅当这些命令各自处理的域或列表已定义的时候才会处理。像\cmd{printfield} 这样的命令在插入任何块和单元的标点之前将首先考虑3个因素:
%because the unit punctuation tracker works asynchronously. \cmd{newunit} will not print the unit punctuation immediately. It merely records a unit boundary and puts \cmd{newunitpunct} on the punctuation buffer. This buffer will be handled by \emph{subsequent} \cmd{printfield}, \cmd{printlist}, or similar commands but only if the respective field or list is defined. Commands like \cmd{printfield} will consider three factors prior to inserting any block or unit punctuation:

\begin{itemize}
\item 是否有新的单元/块的输出请求？\par
=前面是否有\cmd{newunit} 或者\cmd{newblock} 命令？
%Has a new unit/block been requested at all?\par
%= Is there any preceding \cmd{newunit} or \cmd{newblock} command?

\item 前面的命令是否有打印输出？\par
=前面是否有\cmd{printfield} 或者相似命令？\par
=该命令是否实际打印了任何东西？\par
%Did the preceding commands print anything?\par
%= Is there any preceding \cmd{printfield} or similar command?\par
%= Did this command actually print anything?\par

\item 现在是否要打印一些东西？\par
要进行打印处理的域或列表是否已定义？
%Are we about to print anything now?\par
%= Is the field/list to be processed now defined?

\end{itemize}
%
%Block and unit punctuation will only be inserted if \emph{all} of these conditions apply. Let's reconsider the above example:
块和单元的标点只会在上述\emph{所有} 条件满足的时候才会输出。让我们再次考虑上面的示例:
\begin{ltxexample}
\printfield{title}%
\newunit
\printfield{edition}%
\newunit
\printfield{note}%
\end{ltxexample}
%
如果\bibfield{edition} 域没有定义会发生什么呢？第一个\cmd{printfield} 命令打印了标题并设置一个内部的<new~text>标志。第一个\cmd{newunit} 命令设置一个内部的<new~unit>标志。这使没有任何标点输出。第二个\cmd{printfield} 命令不进行任何处理因为\bibfield{edition} 域未定义。接下来的\cmd{newunit} 命令再次设置<new unit>标志，仍然没有标点输出。第三个\cmd{printfield} 命令检测\bibfield{note} 域是否已定义，如果是，它会寻找<new~text>和<new~unit>标志。如果两个标志都存在，那么它会在打印note前插入标点缓存。然后它会清除<new~unit>标志然后再次设置<new~text>标志。
%Here's what happens if the \bibfield{edition} field is undefined. The first \cmd{printfield} command prints the title and sets an internal <new~text> flag. The first \cmd{newunit} sets an internal <new~unit> flag. No punctuation has been printed at this point. The second \cmd{printfield} does nothing because the \bibfield{edition} field is undefined. The next \cmd{newunit} command sets the internal flag <new unit> again. Still no punctuation has been printed. The third \cmd{printfield} checks if the \bibfield{note} field is defined. If so, it looks at the <new~text> and <new~unit> flags. If both are set, it inserts the punctuation buffer before printing the note. It then clears the <new~unit> flag and sets the <new~text> flag again.

所有这些听起来似乎很复杂，但实际上，这意味着可以用顺序的方式写一个具有很多部件的参考文献驱动。这种方法的优势在不使用标点追踪而实现上述代码功能时会体现的很明显。如果不用标点追踪，那么会因为大量对所有可能存在域的判断产生一个复杂的\cmd{iffieldundef} 判断命令集合。
%This may all sound more complicated than it is. In practice, it means that it is possible to write large parts of a bibliography driver in a sequential way. The advantage of this approach becomes obvious when trying to write the above code without using the punctuation tracker. Such an attempt will lead to a rather convoluted set of \cmd{iffieldundef} tests required to check for all possible field combinations (note that the code below handles three fields; a typical driver may need to cater for some two dozen fields):

\begin{ltxexample}
\iffieldundef{title}%
  {\iffieldundef{edition}
     {\printfield{note}}
     {\printfield{edition}%
      \iffieldundef{note}%
	{}
	{. \printfield{note}}}}
  {\printfield{title}%
   \iffieldundef{edition}
     {}
     {. \printfield{edition}}%
   \iffieldundef{note}
     {}
     {. \printfield{note}}}%
\end{ltxexample}

\paragraph{常见错误}%Common Mistakes

把单元的标点处理认为是同步处理的是一个相当常见的误解。这会导致当驱动中包含抄录文本
%\footnote{这里literal text 理解为原样文本，如实文本，逐字文本，抄录文本，照抄文本}
时出现一些典型错误。考虑下面导致标点错位的错误代码段:
%It is a fairly common misconception to think of the unit punctuation as something that is handled synchronously. This typically causes problems if the driver includes any literal text. Consider this erroneous code snippet which will generate misplaced unit punctuation:

\begin{ltxexample}
\printfield{title}%
\newunit
<<(>>\printfield{series} \printfield{number}<<)>>%
\end{ltxexample}
%
%This code will yield the following result:
这段代码将产生下面的结果:

\begin{lstlisting}[style=highlight]{}
Title <<(.>> Series Number<<)>>
\end{lstlisting}
%
这里发生了什么呢？第一个\cmd{printfield} 命令打印了标题，然后\cmd{newunit} 命令标记了一个新的单元边界但不打印任何内容。单元的标点由\emph{下一个}\cmd{printfield} 命令打印。这是前面提过的异步机制。然而因为左括号在下一个
\cmd{printfield} 命令插入标点前立即打印，所以导致了错误的句点。当插入\emph{任何} 原样文本比如括号(还包括由
\cmd{bibopenparen} 和\cmd{mkbibparens} 命令打印的括号)时，总需要将这些文本用\cmd{printtext} 命令包起来。要让标点追踪正常运转，需要让驱动知道所有插入的原样文本。这是\cmd{printtext} 命令的作用所在。\cmd{printtext} 命令联系标点追踪器确保标点缓存在原样文本打印前插入。它也设定内部 <new~text> 标志。注意本例中还有第三处原样文本即|\printfield{series}|后面的空格。在改正的示例中，我们将使用标点追踪器来处理该空格。
%Here's what happens. The first \cmd{printfield} prints the title. Then \cmd{newunit} marks a unit boundary but does not print anything. The unit punctuation is printed by the \emph{next} \cmd{printfield} command. That's the asynchronous part mentioned before. However, the opening parenthesis is printed immediately before the next \cmd{printfield} inserts the unit punctuation, leading to a misplaced period. When inserting \emph{any} literal text such as parentheses (including those printed by commands such as \cmd{bibopenparen} and \cmd{mkbibparens}), always wrap the text in a \cmd{printtext} command. For the punctuation tracker to work as expected, it needs to know about all literal text inserted by a driver. This is what \cmd{printtext} is all about. \cmd{printtext} interfaces with the punctuation tracker and ensures that the punctuation buffer is inserted before the literal text gets printed. It also sets the internal <new~text> flag. Note there is in fact a third piece of literal text in this example: the space after |\printfield{series}|. In the corrected example, we will use the punctuation tracker to handle that space.

\begin{ltxexample}
\printfield{title}%
\newunit
<<\printtext{(}>>%
\printfield{series}%
<<\setunit*{\addspace}>>%
\printfield{number}%
<<\printtext{)}>>%
\end{ltxexample}
%
尽管上面的代码能够如常工作，但处理括号、引号和其它包围某个域的标点是，推荐的方式是定义一个域格式:
%While the above code will work as expected, the recommended way to handle parentheses, quotes, and other things which enclose more than one field, is to define a field format:

\begin{ltxexample}
\DeclareFieldFormat{<<parens>>}{<<\mkbibparens{#1}>>}
\end{ltxexample}
%
域格式可以同时用于\cmd{printfield} 和\cmd{printtext} 命令，因此我们可以利用它对若干个域用一堆括号进行包裹。
%Field formats may be used with both \cmd{printfield} and \cmd{printtext}, hence we can use them to enclose several fields in a single pair of parentheses:

\begin{ltxexample}
<<\printtext[parens]{>>%
  \printfield{series}%
  \setunit*{\addspace}%
  \printfield{number}%
<<}>>%
\end{ltxexample}
%
这里我们还需要处理没有series信息时的情况，因此进一步改进代码如下:
%We still need to handle cases in which there is no series information at all, so let's improve the code some more:

\begin{ltxexample}
<<\iffieldundef{series}>>
  {}
  {\printtext[parens]{%
     \printfield{series}%
     \setunit*{\addspace}%
     \printfield{number}}}%
\end{ltxexample}
%
最后的一点提示: 本地化字符串对于标点追踪器来说不是原样文本。因为\cmd{bibstring} 和相似命令能联系标点追踪器，因此就不需要用\cmd{printtext} 包裹起来。
%One final hint: localisation strings are not literal text as far as the punctuation tracker is concerned. Since \cmd{bibstring} and similar commands interface with the punctuation tracker, there is no need to wrap them in a \cmd{printtext} command.

\paragraph{高级用法}%Advanced Usage
标点追踪器也可用来处理更复杂的情况。比如，考虑需要对\bibfield{location}、 \bibfield{publisher} 和 \bibfield{year} 根据数据是否提供以如下的格式打印：
%The punctuation tracker may also be used to handle more complex scenarios. For example, suppose that we want the fields \bibfield{location}, \bibfield{publisher}, and \bibfield{year} to be rendered in one of the following formats, depending on the available data:

\begin{ltxexample}
...text<<. Location: Publisher, Year.>> Text...
...text<<. Location: Publisher.>> Text...
...text<<. Location: Year.>> Text...
...text<<. Publisher, Year.>> Text...
...text<<. Location.>> Text...
...text<<. Publisher.>> Text...
...text<<. Year.>> Text...
\end{ltxexample}
%
这个问题可以用一个相当复杂的\cmd{iflistundef} 和\cmd{iffieldundef} 判断集进行处理，通过这些判断可以确定所有可能的域的组合：
%This problem can be solved with a rather convoluted set of \cmd{iflistundef} and \cmd{iffieldundef} tests which check for all possible field combinations:

\begin{ltxexample}
\iflistundef{location}
  {\iflistundef{publisher}
     {\printfield{year}}
     {\printlist{publisher}%
      \iffieldundef{year}
        {}
        {, \printfield{year}}}}
  {\printlist{location}%
   \iflistundef{publisher}%
     {\iffieldundef{year}
        {}
        {: \printfield{year}}}
     {: \printlist{publisher}%
      \iffieldundef{year}
        {}
        {, \printfield{year}}}}%
\end{ltxexample}
%
可以应用\cmd{ifthenelse} 命令和\secref{aut:aux:ife} 讨论的布尔运算可使上面的代码更具可读性。但本质上是一样的。然而，也可以按顺序写成如下方式:
%The above could be written in a somewhat more readable way by employing \cmd{ifthenelse} and the boolean operators discussed in \secref{aut:aux:ife}. The approach would still be essentially the same. However, it may also be written sequentially:

\begin{ltxexample}
\newunit
\printlist{location}%
\setunit*{\addcolon\space}%
\printlist{publisher}%
\setunit*{\addcomma\space}%
\printfield{year}%
\newunit
\end{ltxexample}
%
在实际使用中，你会经常使用标点追踪器执行一些显式或隐式的组合判断，比如，考虑如下格式(注意当没有publisher时location后面的标点)
%In practice, you will often use a combination of explicit tests and the implicit tests performed by the punctuation tracker. For example, consider the following format (note the punctuation after the location if there is no publisher):

\begin{ltxexample}
...text. Location: Publisher, Year. Text...
...text. Location: Publisher. Text...
...text<<. Location, Year.>> Text...
...text. Publisher, Year. Text...
...text. Location. Text...
...text. Publisher. Text...
...text. Year. Text...
\end{ltxexample}
%
这可以用如下代码进行处理:
%This can be handled by the following code:

\begin{ltxexample}
\newunit
\printlist{location}%
\iflistundef{publisher}
  {\setunit*{\addcomma\space}}
  {\setunit*{\addcolon\space}}%
\printlist{publisher}%
\setunit*{\addcomma\space}%
\printfield{year}%
\newunit
\end{ltxexample}
%
因为当没有publisher时location后面的标点的特殊性，我们需要用一个\cmd{iflistundef} 判断来确保正确性。剩下其它的则有标点追踪器处理。
%Since the punctuation after the location is special if there is no publisher, we need one \cmd{iflistundef} test to catch this case. Everything else is handled by the punctuation tracker.

\subsubsection{本地化定制模型}%Custom Localization Modules
\label{aut:cav:lng}

参考文献格式要求可能包含某些规定，比如像<edition>之类的字符串怎么缩写或者需要表示成一些固定的形式。例如\acr{mla} 格式要求作者在参考文献表的标题中使用<Works~Cited>而不是<Bibliography>或<References>。本地化命令比如\secref{use:lng} 节的\cmd{DefineBibliographyStrings} 可以在\file{cbx} 和\file{bbx} 文件中处理这些情况。然而，用翻译内容重载样式文件是相当不便的。而这正是\secref{aut:lng:cmd} 节的\cmd{DeclareLanguageMapping} 命令发挥作用的地方。这一命令将一个\file{lbx} 文件映射为某一\sty{babel}/\sty{polyglossia} 语言的替代翻译。例如，可以创建一个名为\path{french-humanities.lbx} 的文件提供适用于人文学科的法语翻译并在导言区或者配置文件中将其映射为\sty{babel}/\sty{polyglossia} 语言\texttt{french}。
%Style guides may include provisions as to how strings like <edition> should be abbreviated or they may mandate certain fixed expressions. For example, the \acr{mla} style guide requires authors to use the term <Works~Cited> rather than <Bibliography> or <References> in the heading of the bibliography. Localization commands such as \cmd{DefineBibliographyStrings} from \secref{use:lng} may indeed be used in \file{cbx} and \file{bbx} files to handle such cases. However, overloading style files with translations is rather inconvenient. This is where \cmd{DeclareLanguageMapping} from \secref{aut:lng:cmd} comes into play. This command maps an \file{lbx} file with alternative translations to a \sty{babel}/\sty{polyglossia} language. For example, you could create a file named \path{french-humanities.lbx} which provides French translations adapted for use in the humanities and map it to the \sty{babel}/\sty{polyglossia} language \texttt{french} in the preamble or in the configuration file:

\begin{ltxexample}
\DeclareLanguageMapping{french}{french-humanities}
\end{ltxexample}
%
如果正文的语言设置为\texttt{french}，\path{french-humanities.lbx} 将替换\path{french.lbx}。回到前述的\acr{mla} 示例，一个\acr{mla} 样式可能带有一个\path{american-mla.lbx} 文件来提供符合\acr{mla} 格式规要求的字符串。它将在\file{cbx} 和/或 \file{bbx} 文件中声明如下映射:
%If the document language is set to \texttt{french}, \path{french-humanities.lbx} will replace \path{french.lbx}. Coming back to the \acr{mla} example mentioned above, an \acr{mla} style may come with an \path{american-mla.lbx} file to provide strings which comply with the \acr{mla} style guide. It would declare the following mapping in the \file{cbx} and/or \file{bbx} file:

\begin{ltxexample}
\DeclareLanguageMapping{american}{american-mla}
\end{ltxexample}
%
%Use \cmd{DeclareLanguageMappingSuffix} (see \secref{aut:lng:cmd}) to define such a mapping for all languages.
使用\cmd{DeclareLanguageMappingSuffix}(see \secref{aut:lng:cmd})来定义针对所有语言的映射。

因为替换的\file{lbx} 文件可以从标准的\path{american.lbx} 模型中继承字符串，所以\path{american-mla.lbx} 可以简化为:
%Since the alternative \file{lbx} file can inherit strings from the standard \path{american.lbx} module, \path{american-mla.lbx} may be as short as this:

\begin{ltxexample}
\ProvidesFile{american-mla.lbx}[2008/10/01 v1.0 biblatex localization]
<<\InheritBibliographyExtras>>{<<american>>}
\DeclareBibliographyStrings{%
  <<inherit>>          = {<<american>>},
  bibliography     = {{Works Cited}{Works Cited}},
  references       = {{Works Cited}{Works Cited}},
}
\endinput
\end{ltxexample}
%
替换的\file{lbx} 文件必须保证本地化模型是完整的。这可以通过从相应的标准模型中继承来实现。如果语言\texttt{american} 映射为\path{american-mla.lbx}，\biblatex 将不会加载\path{american.lbx} 除非该模型被明确要求加载。在上述示例中，继承<strings>和<extras>将使得\biblatex 在\path{american-mla.lbx} 中应用修改前加载\path{american.lbx}。
%Alternative \file{lbx} files must ensure that the localisation module is complete. They should do so by inheriting data from the corresponding standard module. If the language \texttt{american} is mapped to \path{american-mla.lbx}, \biblatex will not load \path{american.lbx} unless this module is requested explicitly. In the above example, inheriting <strings> and <extras> will cause \biblatex to load \path{american.lbx} before applying the modifications in \path{american-mla.lbx}.

注意:\cmd{DeclareLanguageMapping} 不用于处理语言的变体(比如American English 和 British English))或者\sty{babel}/\sty{polyglossia} 语言别名(比如\texttt{USenglish} vs. \texttt{american})。例如，\sty{babel}/\sty{polyglossia} 提供了\texttt{USenglish} 选项类似于\texttt{american}。因此\biblatex 附带一个\path{USenglish.lbx} 文件，该文件简单的从\path{american.lbx} 文件中继承所有数据(而该文件又从\path{english.lbx} 文件中获取字符串)。换句话说，语言变体和\sty{babel}/\sty{polyglossia} 语言别名的映射发射在文件层，因此\biblatex 的语言支持可以简单地增加额外的\file{lbx} 文件来实现拓展。没有必要进行集中的映射，如果需要支持比如Portuguese (babel/polyglossia: \file{portuges})，可以创建一个名为\path{portuges.lbx} 的文件。如果\sty{babel}/\sty{polyglossia} 提供一个名为\texttt{brasil} 的别名，可以创建一个\path{brasil.lbx} 文件并可从\path{portuges.lbx} 中继承数据。相比之下，\cmd{DeclareLanguageMapping} 主要用于处理\emph{文体} 上的变化，像<humanities 对 natural sciences> or <\acr{mla} 对 \acr{apa}> 等，这通常是建立在现有的\file{lbx} 文件基础上的。
%Note that \cmd{DeclareLanguageMapping} is not intended to handle language variants (\eg American English vs. British English) or \sty{babel}/\sty{polyglossia} language aliases (\eg \texttt{USenglish} vs. \texttt{american}). For example, \sty{babel}/\sty{polyglossia} offers the \texttt{USenglish} option which is similar to \texttt{american}. Therefore, \biblatex ships with an \path{USenglish.lbx} file which simply inherits all data from \path{american.lbx} (which in turn gets the <strings> from \path{english.lbx}). In other words, the mapping of language variants and \sty{babel}/\sty{polyglossia} language aliases happens on the file level, the point being that \biblatex's language support can be extended simply by adding additional \file{lbx} files. There is no need for centralized mapping. If you need support for, say, Portuguese (babel/polyglossia: \file{portuges}), you create a file named \path{portuges.lbx}. If \sty{babel}/\sty{polyglossia} offered an alias named \texttt{brasil}, you would create \path{brasil.lbx} and inherit the data from \path{portuges.lbx}. In contrast to that, the point of \cmd{DeclareLanguageMapping} is handling \emph{stylistic} variants like <humanities vs. natural sciences> or <\acr{mla} vs. \acr{apa}> etc. which will typically be built on top of existing \file{lbx} files.

\subsubsection{编组}%Grouping
\label{aut:cav:grp}

在标注和著录样式中，可能需要设置标志或保存一些值以便后面使用。这种情况下，理解宏包执行的基本编组结构很关键。一条经验法则是，无论诸如\secref{aut:aux} 节讨论的样式作者命令是否存在，所有的工作都是在一个大的编组内进行的，因为本宏包的作者接口都是局部的。当存在参考文献数据时，至少存在一个额外的编组，下面是一些基本规则:
%In a citation or bibliography style, you may need to set flags or store certain values for later use. In this case, it is crucial to understand the basic grouping structure imposed by this package. As a rule of thumb, you are working in a large group whenever author commands such as those discussed in \secref{aut:aux} are available because the author interface of this package is only enabled locally. If any bibliographic data is available, there is at least one additional group. Here are some general rules:

\begin{itemize}

\item 由\cmd{printbibliography} 或类似命令打印的整个文献表是在一个编组中处理。表中的每个条目都是在一个额外的编组中，这一编组包含了\cmd{defbibenvironment} 的\prm{item code} 和所有的驱动代码。
%The entire list of references printed by \cmd{printbibliography} and similar commands is processed in a group. Each entry in the list is processed in an additional group which encloses the \prm{item code} of \cmd{defbibenvironment} as well as all driver code.

\item 由\cmd{printbiblist} 命令打印的整个文献表是在一个编组中处理。表中的每个条目都是在一个额外的编组中，这一编组包含了\cmd{defbibenvironment} 的\prm{item code} 和所有的驱动代码。
%The entire bibliography list printed by \cmd{printbiblist} is processed in a group. Each entry in the list is processed in an additional group which encloses the \prm{item code} of \cmd{defbibenvironment} as well as all driver code.

\item 所有由\cmd{DeclareCiteCommand} 命令定义的标注命令都是在一个编组中处理，该编组包含由\prm{precode}, \prm{sepcode}, \prm{loopcode}, 和\prm{postcode} 等参数构成的完整标注代码。每次执行的\prm{loopcode} 都包含在一个额外的编组中。如果指定了任何的\prm{wrapper}，包含\prm{wrapper} 代码和标注代码的整个单元都在一个额外的编组中。
%All citation commands defined with \cmd{DeclareCiteCommand} are processed in a group holding the complete citation code consisting of the \prm{precode}, \prm{sepcode}, \prm{loopcode}, and \prm{postcode} arguments. The \prm{loopcode} is enclosed in an additional group every time it is executed. If any \prm{wrapper} code has been specified, the entire unit consisting of the wrapper code and the citation code is wrapped in an additional group.

\item 除了由\cmd{DeclareCiteCommand} 定义的所有后端命令会产生编组外，所有的<autocite> 和 <multicite>定义也都会产生一个额外的编组。
%In addition to the grouping imposed by all backend commands defined with \cmd{DeclareCiteCommand}, all <autocite> and <multicite> definitions imply an additional group.

\item \cmd{printfile}, \cmd{printtext}, \cmd{printfield}, \cmd{printlist}, 和\cmd{printnames} 命令也形成编组。这意味着所有的格式化指令都是在它们自身的编组中处理。
%\cmd{printfile}, \cmd{printtext}, \cmd{printfield}, \cmd{printlist}, and \cmd{printnames} form groups. This implies that all formatting directives will be processed within a group of their own.

\item 所有的\file{lbx} 文件都是在一个编组中加载和处理。如果一个\file{lbx} 文件包含的一些代码不是\cmd{DeclareBibliographyExtras} 的一部分，那么这些定义是全局的。
%All \file{lbx} files are loaded and processed in a group. If an \file{lbx} file contains any code which is not part of \cmd{DeclareBibliographyExtras}, the definitions must be global.

\end{itemize}

注意:在标注和著录样式中使用\cmd{aftergroup} 是不可靠的，因为在一定环境中应用的编组的精确层数在宏包的未来版本中可能发生变化。上述说明中如果说某些东西在一个编组中处理，这意味着至少存在一个编组，也可能存在多层嵌套的编组。
%Note that using \cmd{aftergroup} in citation and bibliography styles is unreliable because the precise number of groups employed in a certain context may change in future versions of this package. If the above list states that something is processed in a group, this means that there is \emph{at least one} group. There may also be several nested ones.

\subsubsection{命名空间}%Namespaces
\label{aut:cav:nam}
为减小命名冲突的风险， \latex 宏包通常在其内部宏名前加上一个代表该宏包的短字符串。例如: 如果\sty{foobar} 宏包需要一个内部使用的宏，它通常会命名为\cmd{FB@macro} 或\cmd{foo@macro} 而不是\cmd{macro} or \cmd{@macro}。下面是\biblatex 使用或推荐使用的前缀字符串:
%In order to minimize the risk of name clashes, \latex packages typically prefix the names of internal macros with a short string specific to the package. For example, if the \sty{foobar} package requires a macro for internal use, it would typically be called \cmd{FB@macro} or \cmd{foo@macro} rather than \cmd{macro} or \cmd{@macro}. Here is a list of the prefixes used or recommended by \biblatex:

\begin{marglist}

\item[\texttt{blx}] 所有的宏名像\cmd{blx@name} 的宏严格作为内部使用。这也应用于计数器名，长度名，布尔开关等。这些宏可能会以非后向兼容的方式改变，它们可能会重命名设置删除掉而不会有更多的说明。这种改变也不会在版本修改历史和版本发布信息中出现。简而言之: 不要在任何样式中使用以\texttt{blx} 字符串开头的宏。
%All macros with names like \cmd{blx@name} are strictly reserved for internal use. This also applies to counter names, length registers, boolean switches, and so on. These macros may be altered in backwards"=incompatible ways, they may be renamed or even removed at any time without further notice. Such changes will not even be mentioned in the revision history or the release notes. In short: never use any macros with the string \texttt{blx} in their name in any styles.

\item[\texttt{abx}] 以\texttt{abx} 为前缀的宏也是内部使用，但会相当稳定。但仍应优先使用正式的作者接口提供的工具，但有些情况下使用某一\texttt{abx} 宏可能会比较方便。
%Macros prefixed with \texttt{abx} are also internal macros but they are fairly stable. It is always preferable to use the facilities provided by the official author interface, but there may be cases in which using an \texttt{abx} macro is convenient.

\item[\texttt{bbx}] 建议在著录样式中内部使用的宏名的前缀
%This is the recommended prefix for internal macros defined in bibliography styles.

\item[\texttt{cbx}] 建议在标注样式中内部使用的宏名的前缀
%This is the recommended prefix for internal macros defined in citation styles.

\item[\texttt{lbx}] 建议在本地化模型中内部使用的宏名的前缀。本地化模型需要添加第二个前缀来指定语言，比如一个为西班牙语本地化模型定义的内部宏可以命名为\cmd{lbx@es@macro}。
%This is the recommended base prefix for internal macros defined in localisation modules. The localisation module should add a second prefix to specify the language. For example, an internal macro defined by the Spanish localisation module would be named \cmd{lbx@es@macro}.

\end{marglist}




